<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: roads and bridges | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/roads-and-bridges/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2020-09-30T16:47:59+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What is TypeScript?]]></title>
    <link href="http://artsy.github.io/blog/2019/04/05/omakase-typescript/"/>
    <updated>2019-04-05T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/04/05/omakase-typescript</id>
    <content type="html"><![CDATA[<p>TypeScript is a language from Microsoft which builds on JavaScript. This post is a non-technical overview of what
JavaScript is, how TypeScript extends JavaScript and why we choose to adopt TypeScript at Artsy.</p>

<!-- more -->


<a name="What.is.JavaScript."></a>
<h2>What is JavaScript?</h2>

<p>First up, you can't describe TypeScript without talking about JavaScript. To create a website (and a bunch of other
types of things) you work in three languages: HTML, CSS and JavaScript (JS). Broadly speaking: HTML defines the
content that will appear on the page, CSS defines the visual style of the page, and JS defines the interactive
behaviours of the page.</p>

<p>We describe having these sets of skills as being a "front-end" developer. You have to understand those three
languages to present anything inside a web browser like Safari, Firefox or Chrome. So, given how popular the web
is, there is a massive demand for people who are good at using these three languages.</p>

<p>There is also the set of skills for the "back-end" developers, which are to create computer services that
communicate either to a web browser (by passing it HTML/CSS/JS) or to another service (by sending a raw data.) You
don't need to use HTML, CSS or JS to write this type of code, but it's usually an end-product of your work. We
mostly build our back-ends in Ruby or JavaScript at Artsy.</p>

<a name="What.do.Programming.Languages.do."></a>
<h3>What do Programming Languages do?</h3>

<p>Programming languages are an interesting problem to solve. People read code many, many multiples of times more than
they write it - so developers create languages which are good at solving particular problems with a small amount of
code. Here's an example using JavaScript:</p>

<pre><code class="js">var name = "Danger"
console.log("Hello, " + name)
</code></pre>

<p>The first line makes a variable (a kind of box you can keep things in) and then the second line outputs text to the
console (think DOS, or the terminal) <code>"Hello, Danger"</code>. JavaScript is designed to work as a scripting language,
which means the code starts at the top of the file and then goes through line by line. To provide some contrast,
here is the <a href="https://repl.it/repls/VioletredGlisteningInfo">same behavior</a> in Java, which is built with different
language constraints:</p>

<pre><code class="java">class Main {
  public static void main(String[] args) {
    String name = "Danger";
    System.out.println("Hello, " + name);
  }
}
</code></pre>

<blockquote><p>Note: if you find the naming of Java and JavaScript confusing, it is (they are two completely separate
programming languages, no link at all.) JavaScript was <a href="https://medium.com/@benastontweet/lesson-1a-the-history-of-javascript-8c1ce3bffb17">named that way</a> because Java was looking to be
really the next hot language (it did turn out that way for a decade or two, but now JavaScript is usually the
first language people have heard of.)</p></blockquote>

<p>Aside from having a lot more lines, the Java version comes with a lot of words that aren't necessarily about
telling the computer exactly what to do, e.g. <code>class Main {</code>, <code>public static void main(String[] args) {</code>, <code>}</code> and
<code>}</code> again. It also has semi-colons at the end of some lines. Java is aimed at building different things from
JavaScript, and these extra bits of code make sense within the constraints of building a Java app.</p>

<p>To get to my main point though, there is one standout line I'd like us to compare:</p>

<pre><code>// JavaScript
var name = "Danger"
// Java
String name = "Danger";
</code></pre>

<p>Both of these lines declare variables called <code>name</code> which contain the value <code>"Danger"</code>.</p>

<p>In JavaScript you use the abbreviation <code>var</code> to declare a variable. Meanwhile, in Java you need to say <em>what kind
of data</em> the variable contains. In this case the variable contains a <code>String</code>. (A string is a programming term for
a collection of characters. They <code>"look like this"</code>. This <a href="https://www.youtube.com/watch?v=czTWbdwbt7E">5m video</a>
is a good primer if you want to learn more.)</p>

<p>Both of these variables contain a string, but the difference is that in Java the variable can <em>only</em> ever contain a
<em>string</em>, because that's what we said when we created the variable. In JS the variable can change to be <em>anything</em>,
like a number, or a list of dates.</p>

<p>To illustrate:</p>

<pre><code class="js">// Before in JS
var name = "Danger"
// Also OK
var name = 1
var name = false
var name = ["2018-02-03", "2019-01-12"]

// Before in Java
String name = "Danger";
// Not OK, the code wouldn't be accepted by Java
String name = 1;
String name = false
String name = new String[]{"2018-02-03", "2019-01-12"};
</code></pre>

<p>These trade-offs make sense in the context for which these languages were built back in 1995. JavaScript was
originally designed to be a small programming language which handled simple interactions on websites. Java on the
other hand was built specifically to make big apps which could run on any computer. Their needs had different
scales, so the language required programmers write different types of code.</p>

<p>Java required programmers to be more explicit with the values of their variables because the programs they expected
people to build were more complex. While JavaScript opted for ease of reading, and aimed to do less.</p>

<a name="What.is.TypeScript."></a>
<h3>What is TypeScript?</h3>

<p>TypeScript is a programming language - it contains all of JavaScript, and then a bit more. Using our example above,
let's compare the scripts for "Hello, Danger" in JavaScript vs TypeScript:</p>

<pre><code class="js">// JavaScript
var name = "Danger"
console.log("Hello, " + name)

// TypeScript
var name = "Danger"
console.log("Hello, " + name)

// Yep, you're not missing something, there's no difference
</code></pre>

<p>Due to TypeScript's aim to only <em>extend</em> JavaScript, your normal JavaScript code should work fine with TypeScript.
The things TypeScript adds to JavaScript are intended to help you be more explicit about what kinds of data are
used in your code, a bit like Java.</p>

<pre><code class="diff">- var name = "Danger"
+ var name: string = "Danger"
console.log("Hello, " + danger)
</code></pre>

<p>This extra <code>: string</code> allow the reader to be certain that <code>name</code> will only be a string. Annotating your variables
also gives TypeScript the chance to verify this for you. This is <em>very</em> useful because keeping track of changes
like the type of value in a variable seems easy when it's one or two, but once it starts hitting the hundreds,
that's a lot to keep track of. Types help programmers be more confident about their code because types catch
mistakes.</p>

<p>Simply speaking, we call these annotations "Types". Hence the name <i>Type</i>Script. The tag-line for TypeScript
is "JavaScript which scales" which is a statement that these extra type annotations allows you to work on bigger
projects. This is because you can verify up-front how correct your code is. This means you have less need to
understand how every change affects the rest of the program.</p>

<p>In the 90s, and maybe until a 5-10 years ago the trade-off for not having types in your JavaScript application was
fine because the size and complexities of the programs being built were constrained to just the front-end of
websites. Today though, JavaScript is being used everywhere:</p>

<ul>
<li>Apps like Slack, or Spotify for your computer are built in mostly JavaScript</li>
<li>Some iOS apps, including Artsy's are mostly JavaScript</li>
<li>The back-end and front-end of Artsy.net are JavaScript</li>
</ul>


<p>These are all considerably more complicated to build and understand, adding types drastically reduces the
complexity of making improvements to those programs.</p>

<a name="Why.does.Artsy.use.TypeScript."></a>
<h3>Why does Artsy use TypeScript?</h3>

<p>Artsy definitely isn't the size of Microsoft! Artsy is about 30 engineers, and Microsoft are about 60,000. However,
some of our problems are the same. Developers at Artsy build apps which are made up of thousands of files. A change
to one individual file can affect the behaviour of any number of other files, like throwing a pebble into a pond
and causing ripples to spread out to the bank.</p>

<p>Typically, the need to ensure there are no bugs is less of a problem for people building websites. Websites are
easy to make changes to, because if you change the site - everyone gets the update instantly. We also build our iOS
app with JavaScript, but a change to our app requires Apple to review the changes and for users to download the new
version from the App Store.</p>

<p>This means that the iOS team needs to have more checks that everything is OK before shipping the app to the world.
Using TypeScript gives our team the ability to feel good that the changes we have made are only the changes we
want.</p>

<p>TypeScript isn't the only programming language to tackle the problem of making JavaScript code safer, but it's the
one with the biggest community, allows people to re-use their JavaScript knowledge, can be added in small steps,
and has really good tools to help developers work faster.</p>

<p>These qualities made it worth adding an extra tool to our developers' toolbelt, and we're not the only ones because
TypeScript is growing to be <a href="https://www.wired.com/story/typescript-microsoft-javascript-alternative-most-popular">one of the most popular programming languages in the world</a> with almost 6
million downloads a week.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Peril Architecture Deep Dive]]></title>
    <link href="http://artsy.github.io/blog/2019/04/04/peril-architecture-deep-dive/"/>
    <updated>2019-04-04T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/04/04/peril-architecture-deep-dive</id>
    <content type="html"><![CDATA[<p>For the <a href="/blog/2017/09/04/Introducing-Peril/">last two years</a>, we've used <a href="https://github.com/danger/peril">Peril</a> to automate quite a lot of process at Artsy. You can see
a full overview of what <a href="https://github.com/artsy/README/blob/master/culture/peril.md">we automate in <code>artsy/README</code></a>. As a service, Peril is a bit of an iceberg
of complexity, most tooling-y developers at Artsy have <a href="https://github.com/artsy/peril-settings/graphs/contributors">contributed</a> to our user-land Dangerfiles
but very few have touched the server itself.</p>

<p>To lower that barrier, I gave our Engineering team a run through of how the server works and how a lot of the
pieces come together. Jump <a href="https://www.youtube.com/watch?v=3HNmiNHCvdA">to YouTube</a> for the video, or click more
for a smaller inline preview.</p>

<!-- more -->


<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/3HNmiNHCvdA ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Native at Artsy, 3 years later]]></title>
    <link href="http://artsy.github.io/blog/2019/03/17/three-years-of-react-native/"/>
    <updated>2019-03-17T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/03/17/three-years-of-react-native</id>
    <content type="html"><![CDATA[<p>On Valentine's day in 2014, @alloy made our first commit moving the Artsy Mobile team to JavaScript, and paving the
way to the <a href="https://www.youtube.com/watch?v=1Z3loALSVQM">shared Omakase JavaScript stack across web + iOS</a>. We've done a write-up at <a href="/blog/2016/08/15/React-Native-at-Artsy/">6 months</a>, <a href="/blog/2017/02/05/Retrospective-Swift-at-Artsy/">1 year</a>,
<a href="/blog/2018/03/17/two-years-of-react-native/">2 years</a> and at 2.5 years we collaborated on a React Native conference with Facebook which features a <a href="http://artsy.net/x-react-native">very long
Q&amp;A</a> session with the people who worked on, and with our React Native stack.</p>

<p>Our experience has been really positive building a single platform data-driven app. We've been able to drastically
increase the number of contributors to the codebase and with minimal guidance, web-developers are able to be
productive and ship features to our iOS apps.</p>

<p>That said, for this 3 year anniversary, I want to dive deeper into some of the less positive aspects of our
transition. We think these trade-offs are worth it, and that this may be what a successful cultural transition
eventually looks like for some companies.</p>

<!-- more -->


<a name="De-nativification"></a>
<h2>De-nativification</h2>

<p>When adopting React Native, we de-emphasized iOS as a unique platform for Artsy.</p>

<p>From an engineering team's perspective, we think of it as skill <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#de-silo-engineers">de-siloing</a>. Prior to the move, if you
were on the mobile team you only worked on the iOS apps. This meant you had a limited scope to make change at
Artsy. This comes from two factors:</p>

<ul>
<li>Skills in Obj-C and Swift are only useful in the context of Apple's platforms.</li>
<li>Internally and externally, Artsy is considered a website first.</li>
</ul>


<p>Within 2 years we had de-siloed mobile engineering completely. We started with a team of 5 experienced native iOS
developers and by the end everyone had very solid skills across the board in JavaScript, React, GraphQL and the
build tools we'd need to make it all come together. These engineers kept their native skills, but they became
frozen in time.</p>

<p>With time, we redistributed the native engineers across many teams, with the native Engineers effectively acting as
a conduit for ensuring that we keep quality high and providing guidance to the rest of that team on how to make it
feel right. A simple way to think of it, is that the native engineer's job was to make sure we still conformed to
the <a href="https://developer.apple.com/design/human-interface-guidelines/">Apple Human Interface Guidelines</a> to ensure
the user experience is consistent with the platform and the user’s expectations.</p>

<p>We're reasonably lucky here too, the mobile team at Artsy has pre-dominantly hired folks interested in improving
behind-the-scenes (<a href="https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/">Roads and Bridges</a> style) infrastructure. Once we had wrapped up the move, we effectively
took all of our native product developers and moved them into JavaScript platform infrastructure roles.</p>

<p>This was one of the major blocking points for AirBnB's adoption of React Native, specifically their native teams
felt uncomfortable at the introduction of JavaScript and a whole new toolchain inside their apps. There are people
who really love being a product developer in a native codebase, and React Native as a technology will de-value that
as more work would happen in JavaScript.</p>

<p>(Note: this is a gross simplification, and me reading between the lines, you should read from the horse’s mouth and
check out <a href="https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c">Airbnb’s posts</a> (and <a href="https://ashfurrow.com/blog/airbnb-and-react-native-expectations/">Ash's continuation</a> on the subject ))</p>

<p>After a year of adopting React Native, the ex-mobile team used to joke that no-one enjoyed working in the native
codebase anymore. They still did. Three years down the line, with most screens now in React Native, that's not a
joke anymore.</p>

<p>This has consequences.</p>

<a name="Platform.Concerns"></a>
<h2>Platform Concerns</h2>

<p>De-siloing our mobile team obviously wasn't without its risk. In expanding the scope of our mobile engineering
team, and opening up the iOS app for contributions to the rest of the company we:</p>

<ul>
<li>Moved the engineers with a native focus to act more like platform engineers vs product engineers.</li>
<li>Had iOS native platform engineers with the skills to now also work on the web's platform.</li>
</ul>


<p>This is what started to make our third year tricky. In Artsy, web is the <a href="https://en.wikipedia.org/wiki/The_squeaky_wheel_gets_the_grease">squeaky wheel</a>.</p>

<p>After figuring out the JavaScript infrastructure for React Native on iOS, we replicated that infrastructure on the
web to consolidate tooling and ideas across all of Artsy. We call that infrastructure for both <a href="https://www.youtube.com/watch?v=1Z3loALSVQM">the Artsy
Omakase</a>. Maintaining, and keeping the infrastructure up-to-date on the web side is a much bigger task and
requires a lot more engineering time.</p>

<p>The web-aspect of the Omakase has more client consumers (1 iOS app vs 3 large websites), and its corresponding repo
has more than double the number of commits per day on average. The web team has its own people running and
improving infrastructure, which affects the iOS side too.</p>

<p>We explicitly worked towards shared common infrastructure across all front-end at Artsy. It wasn't surprising when
the aspect with the most company focus became much larger and more complex. What creates tricky constraints are
that the few people with the interest and skills to work on our React Native infrastructure also happen to have the
skills to work on the web problems too.</p>

<p>Those web problems tend to be a lot more valuable to the business.</p>

<p>There's some work that can be done to benefit both, but in the last year it has been hard to prioritise
iOS-specific platform work. For example, it took almost a year to get around to upgrading our version of React
Native. This is a pretty risky place to be for a platform which we care about.</p>

<p>At the end of 2018, we came to the conclusion that this was something we wanted to work to improve. So, we
specifically brought back an explicit iOS-specific culture to Artsy - when we split our front-end practice into web
and <a href="https://github.com/artsy/README/commit/95c9b93ab966ed269b5ebd9f0bdec8d2434bab52#diff-342d3433f36fbedadc5a8f167985fdf3">iOS</a>.</p>

<p>Maybe this is a small admission of failure to the idea of a purely de-silo'd team, but realistically while product
work across the two front-ends teams is consistent - the platform concerns just aren't.</p>

<a name="Keeping.up.with.the.Jobs."></a>
<h2>Keeping up with the Jobs'</h2>

<p>As individual developers, it's much less important for us to keep up to date with the latest Apple developer news.
WWDCs and iOS releases just kinda happen, and we keep moving independently. We still write native code to make use
of any iOS API available when we need to, but right now we don’t go out of our way to try to make use of all the
shiny new things when they are released.</p>

<p>This is a side-effect to the openness of the JavaScript toolchain, and our ability to contribute and fix a lot of
our own problems at JavaScript level instead of needing to dive deeper into the native side to work on problems. We
still support iOS 9, and have very little incentive to bump it - new APIs from Apple just aren't that interesting
anymore.</p>

<p>Without a focused iOS team, it's not easy to pitch for iOS specific projects. This means that features like moving
to Apple's new app store review API or using iOS features which don't exist on web get spoken about in meetings,
but never started. This lack of a focused team makes it really hard to implement fixes to e.g. bad App Store
reviews.</p>

<p>That said, in the last year we did manage to ship a pretty hefty <a href="/blog/2018/03/18/ar/">ARKit feature</a> - which is a positive
example of an iOS-specific feature which is both forward-thinking tech and a super great fit for Artsy's product.
React Native basically played no part in that.</p>

<a name="Community.Disconnection"></a>
<h2>Community Disconnection</h2>

<p>There are maybe four communities at play if you're doing React Native:</p>

<ul>
<li>JavaScript (Babel/TypeScript/Storybooks/VSCode)</li>
<li>React (Relay/Styled Components)</li>
<li>React Native (Mostly people creating cross-platform tools)</li>
<li>Native (Obj-C/Swift/CocoaPods/fastlane etc)</li>
</ul>


<p>It's hard to keep on-top of any one community, and it's very hard to keep on track of four. Realistically, if you
want to be writing apps at the level of quality we want to - you need to, though.</p>

<p>Artsy's principle of <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#own-your-dependencies">owning our dependencies</a> means involved in all of these communities, however it's
hard to engage in the native community with too much excitement anymore. Most of their problems aren't the same as
ours anymore, and the dependencies we want to improve live in the JavaScript realms.
4</p>

<a name="Universal.Issues."></a>
<h2>Universal Issues?</h2>

<p>Are these the kind of problems most teams would have? It depends, with React Native at Artsy our focus on:</p>

<ul>
<li>Offering a consistent way to write code across web and iOS, which doesn’t water down either platform.</li>
<li>Ensuring we are able to meaningfully own our dependencies across the stacks.</li>
</ul>


<p>Means that we took on some technical and cultural debt, specifically around the platform aspect of our native
codebase. There are a few levers we can use to fix some of these issues:</p>

<ul>
<li>Let iOS be a bit more webby, by using more JavaScript instead of enforcing stricter platform standards.</li>
<li>Use more of the React Native community’s infra-structure, we generally don't use React Native JavaScript
dependencies. These dependencies usually are cross-platform on Android and iOS which tends to mean making
compromises per-platform. Often we are forcing ourselves into extra work to ensure platform consistency.</li>
<li>Find a way to ensure clearer engineering and product ownership for iOS at Artsy.</li>
<li>Hire more iOS infrastructure engineers to allow for a better mix of native infra vs JavaScript product engineers.</li>
</ul>


<p>How and if we'll tweak these levers will make for an interesting retrospective. Till then, I'd like to finish with
a showcase of some of the React Native work we shipped over the course of the last 4 months:</p>

<p></article>
<a href='/images/react-native-3/rn_3_1.jpg' style="">
  <img src="/images/react-native-3/rn_3_1.jpg" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<p></article>
<a href='/images/react-native-3/rn_3_2.jpg' style="">
  <img src="/images/react-native-3/rn_3_2.jpg" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<p>We wouldn't have been able to ship this without React Native.</p>

<!-- prettier-ignore-start -->


<!-- prettier-ignore-end -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Automation Encourages More Automation]]></title>
    <link href="http://artsy.github.io/blog/2019/01/08/automation-encourages-more-automation/"/>
    <updated>2019-01-08T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/01/08/automation-encourages-more-automation</id>
    <content type="html"><![CDATA[<p>Last year, <a href="http://artsy.github.io/blog/2018/05/07/fully-automated-standups/">I wrote about the process of fully automating our weekly engineering-wide standup</a>. One of
the benefits of automating what <em>was</em> a meeting run by a single person to a meeting run by everyone is that we
removed a <a href="https://en.wikipedia.org/wiki/Single_point_of_failure">single point of failure</a>. However, I may have fibbed just slightly when I called our standups
<em>fully</em> automated.</p>

<p>This blog post is going to cover how (and more importantly, <em>why</em>) I finally automated the last 5% of our weekly
standups. Let's go!</p>

<!-- more -->


<hr />

<p>Our weekly standup process is a finely tuned machine. The meeting is run every Monday morning by a different pair
of engineers, based on our <a href="http://artsy.github.io/blog/2018/05/25/support-process/">on-call rotation</a>. The process is <a href="https://github.com/artsy/README/blob/eb2f23c835983223877a6031475153db93e98e8c/events/open-standup.md">documented</a> in the open, and we
improve it over time. I'm really proud of it! But there's just one problem... someone needs to make sure that the
people responsible for the meeting <em>know</em> about that responsibility.</p>

<p>So for the past 8 months, I've begun every week by sending Slack DMs to the responsible engineers to remind them to
run the standup, including a link to the docs. This made me a single point of failure: when I was out of the
office, I always made sure to ask someone else to remind them about the meeting. What if I had forgot? Or I was
sick that day? What would happen to our finely-tuned machine?!</p>

<p>Okay, so what would probably happen is that people would remember anyway or someone would post to Slack "hey who is
running standup today?" Automating this reminder was a pretty small priority, but it was a gap in our process, and
I wanted to patch it.</p>

<p>When I discussed all of this with my colleagues, it wasn't long before someone brought up <a href="https://xkcd.com/1319/">the xkcd comic on
automation</a>. Oh, you know the one.</p>

<p><a href="https://xkcd.com/1319/"><center><img src="https://imgs.xkcd.com/comics/automation.png" srcset="//imgs.xkcd.com/comics/automation_2x.png 2x" alt="xkcd comic about automation" title="I wonder if people would read the hover text of an xkcd comic linked to from a different site, just out of habit? I probably would." /></center></a></p>

<p>The comic observes that, often, the work necessary to automate a task often exceeds the amount of work necessary to
just do the task manually. Pretty funny! You could be forgiven for taking the logical leap to say that automating
tasks isn't worth it, generally, based on this observation. But that analysis would be incomplete because it
focuses entirely on saving <em>time</em>. In my experience, automating a task often yields far more value than it costs in
time.</p>

<p>Let's take the task of sending the on-call engineers their Monday morning standup reminder. How would we even
automate that?</p>

<p>Well, first I think about how <em>I</em> do this task. First I look at the on-call schedule, shared in Google Calendar.
Then I open a DM in Slack with the engineers. I copy the pre-composed message from my recurring OmniFocus task and
send it in the DM.</p>

<p>Okay so how would I automate that? <a href="http://artsy.github.io/blog/2017/09/04/Introducing-Peril/">Artsy uses Peril already</a> to automate reminders about open RFCs, so I
piggy-backed on that existing automation. This is key: I'm not starting from scratch, I'm building upon the
existing automation infrastructure that we've already built.</p>

<p>Next, I find out how to access the Google Calendar API using a <a href="https://cloud.google.com/iam/docs/understanding-service-accounts">Google Services Account</a>. It has an
authentication method purpose-built for server-to-server communication, which is perfect for our needs. I write
some code to pick the correct calendar events based on the current time, extract the email addresses of those
events' attendees, and handle an edge case. Then I look up the <a href="https://github.com/slackapi/node-slack-sdk#features">Slack API</a> for Peril's platform, learn how
to authenticate with it properly from a server, and lookup Slack user IDs based on those email addresses. Finally,
compose the message and use some previously written code to post it to our #dev channel.</p>

<p>Boom. <a href="https://github.com/artsy/peril-settings/pull/87">Open a PR</a>. Add some unit tests. Done.</p>

<p><img alt="screenshot of the peril task working in Slack" src="/images/2019-01-08-automation-encourages-more-automation/success.png"  /></p>

<p>I spent about four hours automating this and by my calculations, I'll recoup that time by... July 2020. But like I
said, there's more value to this than the time I saved.</p>

<p>In the process of automating this, I learned how to use <em>two</em> new APIs <em>and</em> I created infrastructure in our <a href="https://github.com/artsy/peril-settings">Peril
installation</a> to access them. Not only did I build <em>upon</em> the existing automation framework,
but I <em>contributed</em> to it so it's easier for the next person. I even <a href="https://github.com/danger/peril/pull/407">fixed a Peril bug</a> in the process.</p>

<p>Automation encourages automation. Every time you automate a task, it gets easier to automate the next one. With
sufficient infrastructure, a sort of exponential takeoff happens: all of a sudden you're not just automating
<em>existing</em> tasks, you're using that infrastructure for <em>new</em> tasks. Tasks that add value to your team, like
<a href="https://github.com/artsy/peril-settings/blob/master/org/mergeOnGreen.ts">merge-on-green</a> or <a href="https://github.com/artsy/peril-settings/blob/master/tasks/compareSchemas.ts">notifying engineers of recent API changes</a>.</p>

<p>As a consequence of the nature of engineering, we often consider ideas in only terms of constraints. We define
what's possible by what we can already accomplish. Automation is a way to hack around that habit; it encourages
engineers to think outside the box by giving us a larger box. Simple, but effective!</p>

<hr />

<p>So. Four hours of work. Was it worth it?</p>

<p>Well, let's evaluate this in terms of <em>impact</em>. Those four hours could have kept our standups running until next
July, or they could have automated that task <em>and</em> further enhanced our automation infrastructure. And, personally,
it was very satisfying.</p>

<p>I would say that's <em>definitely</em> worth it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[It's time to use Swift Package Manager]]></title>
    <link href="http://artsy.github.io/blog/2019/01/05/its-time-to-use-spm/"/>
    <updated>2019-01-05T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/01/05/its-time-to-use-spm</id>
    <content type="html"><![CDATA[<p>It's been three years, and <a href="https://swift.org/package-manager/">Swift Package Manager</a> (SPM) is at a point where it can be useful for iOS
projects. It'll take a bit of sacrifice and a little bit of community spirit to fix some holes probably but <strong>in my
opinion, it's time for teams to start adopting SPM for their 3rd party dev tools</strong>.</p>

<p><strong>TLDR:</strong> You should be using SPM for 3rd party dev tools like: <a href="https://github.com/realm/SwiftLint">SwiftLint</a>, <a href="https://github.com/nicklockwood/SwiftFormat">SwiftFormat</a>, <a href="https://danger.systems/swift/">Danger</a>,
<a href="https://github.com/krzysztofzablocki/Sourcery">Sourcery</a>, <a href="https://github.com/SwiftGen/SwiftGen/">SwiftGen</a> and <a href="https://github.com/orta/Komondor">Git Hook management</a>.</p>

<p>This post covers: What made it feasible to use SPM now? What are the downsides of the status quo? Why use SPM at
all? What are the downsides to using SPM?</p>

<!-- more -->


<a name="What.changed.to.make.SPM.usable."></a>
<h3>What changed to make SPM usable?</h3>

<p>From my perspective, David Hart's <a href="https://github.com/apple/swift-package-manager/pull/1187">addition of <code>swift run</code></a> to SPM which shipped with Swift 4.0 is what
pushed the project over the finish line to being useful for iOS developers. <code>swift run</code> is contextually the same as
<code>bundle exec</code> in that it will run a locally bundled version of your executable.</p>

<p>This means you can run <code>swift run swiftlint</code> and reliably get the same results as your CI and fellow developers.</p>

<p>Second, all of the big third party tools support SPM already. So, you probably don't need to send any upstream PRs.</p>

<a name="What.are.the.downsides.of.the.status.quo"></a>
<h3>What are the downsides of the status quo</h3>

<p><strong>Using Homebrew</strong></p>

<p>Right now, a lot of folks use <a href="https://brew.sh">homebrew</a> to manage these types of dependencies. Homebrew is useful for rarely
updated tools (like unix-y CLI apps) but it does not handle having different versions of tool available. This is a
totally reasonable call from Homebrew's perspective but it makes homebrew a bad choice for your <strong>project</strong>
dependencies - because it only installs things globally.</p>

<p>This means a developer (or your CI) would get the most recent version of that tool when they last installed the
tool. This isn't a problem for many projects (for example, check out their <a href="https://formulae.brew.sh/analytics/install/90d/">most installed</a> formulas to
see that it's lot of system libraries, languages and global tools like <code>node</code>, <code>git</code> and <code>python</code>)</p>

<p><strong>Using CocoaPods</strong></p>

<p>You can hijack CocoaPod's dependency resolver, and locking system mixed with consistent dependency paths to handle
your tools. This is better than using Homebrew, because everyone has the same version - and so you could reliably
run SwiftLint via <code>./Pods/SwiftLint/swiftlint</code>.</p>

<p>This is a great hack, and CocoaPods is smart here - because these dependencies don't ship any code for your app for
compiling it won't set up a library or framework for you. You can even use CocoaPods to set up <a href="https://guides.cocoapods.org/syntax/podfile.html#script_phase">a build
phase</a> for you too (I have feelings on this but we'll get to those later.)</p>

<p>I don't really have much of a "you shouldn't do this" for using hacking CocoaPods for your tools, outside of SPM
it's probably the right way to do it.</p>

<a name="Why.Use.SwiftPM."></a>
<h3>Why Use SwiftPM?</h3>

<ol>
<li>SPM works</li>
<li>SPM can lock your dependencies correctly. <code>:tada:</code></li>
<li>The primary tools used in our ecosystem already support it, so you don't need to do any extra work</li>
<li>Easy to cache (everything lives in <code>.build</code>) which means fast CI builds</li>
<li>You're using Swift's tools to manage tools built in Swift, promoting and encouraging the ecosystem you want to
thrive</li>
<li>Your team can get used to how SPM works now, because it should be useful for code dependencies some day</li>
<li>SPM is still in a pretty early phase for usage like this, maybe you can find features to add once you've got
started and contribute back</li>
</ol>


<a name="What.are.the.downsides."></a>
<h3>What are the downsides?</h3>

<ol>
<li><p>Running a tool will compile it the first time you use <code>swift run</code>. Running <code>swift run danger-swift</code> would first
build <code>danger-swift</code> from source and then it would run the executable.</p></li>
<li><p>SPM's dependency resolution step is very naive, and will clone all the dependencies in the tree - even if you
don't need them. So, the dependencies of your dependencies (a.k.a transitive dependencies) will have full clones
locally - e.g. the test runner for SwiftLint has to be fully cloned locally in <code>.build</code> if you use SPM for
SwiftLint. I'm hoping <a href="https://github.com/apple/swift-package-manager/pull/1918">this PR</a> and subsequent
improvements will fix this.</p></li>
<li><p>You need to reference a single Swift file in your project to make this work. SPM today does not support a
dependencies only project (it won't build), so you'll need to reference one Swift file in your codebase.</p></li>
</ol>


<p>All of these are fixable, and the first two can be worked around on CI, by caching the <code>.build</code> directory. Locally
these actions normally only happens once when you install, or update.</p>

<a name="Show.me.it.in.action"></a>
<h3>Show me it in action</h3>

<p>What would this look like for a project? IMO, for a reasonably complex Swift app, I think you should have:</p>

<ul>
<li><a href="https://github.com/realm/SwiftLint">SwiftLint</a> for catching potential code issues</li>
<li><a href="https://github.com/nicklockwood/SwiftFormat">SwiftFormat</a> so you don't argue about code style</li>
<li><a href="https://github.com/orta/Komondor">Komondor</a> to automate the above tools, so people don't have to remember to run the tools</li>
<li><a href="https://danger.systems/swift/">Danger Swift</a> to handle cultural rules for PRs like "Please add Changelogs entries"</li>
</ul>


<p>You would write a <code>Package.swift</code> file like this:</p>

<pre><code class="swift">// swift-tools-version:4.2
import PackageDescription

let package = Package(
    name: "Eigen",
    dependencies: [
      .package(url: "https://github.com/danger/swift.git", from: "1.0.0"),
      .package(url: "https://github.com/nicklockwood/SwiftFormat", from: "0.35.8"),
      .package(url: "https://github.com/Realm/SwiftLint", from: "0.28.1"),
      .package(url: "https://github.com/orta/Komondor", from: "1.0.0"),
    ],
    targets: [
        // This is just an arbitrary Swift file in the app, that has
        // no dependencies outside of Foundation, the dependencies section
        .target(name: "eigen", dependencies: ["Danger"], path: "Artsy", sources: ["Stringify.swift"]),
    ]
)

// The settings for the git hooks for our repo
#if canImport(PackageConfig)
    import PackageConfig

    let config = PackageConfig([
        "komondor": [
            // When someone has run `git commit`, first run
            // SwiftFormat and the auto-correcter for SwiftLint
            "pre-commit": [
                "swift run swiftformat .",
                "swift run swiftlint autocorrect --path Artsy/",
                "git add .",
            ],
        ]
    ])
#endif
</code></pre>

<p>Which gives you access to the following commands:</p>

<ul>
<li><code>swift run komondor install</code> - to set up your repo's git hooks</li>
<li><code>swift run swiftformat .</code> - to run SwiftFormat over your project</li>
<li><code>swift run swiftlint --autocorrect</code> - to highlight your linter issues</li>
<li><code>swift run danger-swift ci</code> - to run Danger Swift on your CI</li>
</ul>


<p>Because you can reliably run both SwiftFormat and SwiftLint via Komondor on a git hook, you can remove build phase
steps that run these tools.</p>

<p>An iOS app's compile and run cycle already takes on the order of seconds, so you should avoid adding extra build
steps in Xcode. I realise that people are only doing this due to the (unreasonably) limited extension support in
Xcode, but the build steps are critical path code. When your build and run cycle is already on the order of many
seconds that iteration cycle has to be as tight as possible.</p>

<p>This setup gives you version-locked access to common linting/formating tools (with the ability to use komondor to
add extra checks if needed) in a self-contained <code>Package.swift</code>.</p>

<p>We've started migrating our Artsy projects to use this setup when we work on our native codebases. With our main
iOS app Eigen already using this pattern for Danger Swift, but we don't created/modify enough <code>*.swift</code> files to
warrant linters/formatters yet.</p>
]]></content>
  </entry>
  
</feed>
