<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dependencies | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/dependencies/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2024-10-30T17:33:51+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Why We Run Our Own Blog]]></title>
    <link href="https://artsy.github.io/blog/2019/01/30/why-we-run-our-blog/"/>
    <updated>2019-01-30T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/01/30/why-we-run-our-blog</id>
    <content type="html"><![CDATA[<p>This blog just passed the 7 year mark from our initial <a href="/blog/2012/01/05/hello-world/">“Hello World”</a> post. We’ve always built and hosted our
own blog, initially <a href="/blog/2012/01/18/octopress-and-jekyll/">using OctoPress</a> but eventually migrating to just plain old Jekyll.</p>

<p>Artsy uses 3 separate editorial platforms now, we built our own for <a href="https://www.artsy.net/articles">Artsy Magazine</a>, use Medium for our <a href="https://www.artsy.net/life-at-artsy">Life
at Artsy blog</a> and Jekyll for the engineering blog. There was a healthy debate about whether we would migrate
to one, or two systems, but I had pretty strong opinions on migrating the engineering blog to Medium and nipped
that in the bud pretty quickly.</p>

<p>With <a href="https://m.signalvnoise.com/signal-v-noise-exits-medium/">Signal vs Noise</a> being a high profile of a example of migrating to Medium and back again, I thought it’s
worth taking the time to examine our reasoning for doing it ourselves.</p>

<!-- more -->

<h2 id="dependencies">Dependencies</h2>

<p>In programming, the process of creation rely on you depending on others. That ranges from operating systems, to
system dependencies like SQLite or VSCode to app level dependencies from CocoaPods/Node/Whatever. For this blog,
that we rely on GitHub’s static site hosting, RubyGems + Bundler and Jekyll. Luckily for us, there are powerful
incentives for those projects to continue long into the future.</p>

<p>That’s not even too much of a worry either:</p>

<ul>
  <li>If GitHub pages stop being a priority, we can switch Netlify or plain S3 in an hour (we already ship to netlify
for post draft previews)</li>
  <li>If RubyGems or Jekyll goes down, we can switch to another static site builder in another language,</li>
</ul>

<p>Because the code is some markdown, some HTML and CSS - that’s all portable to whatever we want.</p>

<p>We call the process of making sure you understand and vet the full stack your dependencies <a href="https://github.com/artsy/README/blob/master/culture/engineering-principles.md#own-your-dependencies">“Owning your
Dependencies”</a>, and in this case we’re sitting on a long-lived and mature set of dependencies.</p>

<p>To switch from our mature set of dependencies to a start-up which still hasn’t found out how it can make money
greatly increases the long-term risks.</p>

<p>Medium is totally incentivized to get your post in front of as many people as possible, and that’s awesome.
However, as a business they’ve not found a way to be profitable, and have taken a lot of <a href="https://www.crunchbase.com/organization/medium">VC cash</a> which
eventually needs to be paid back. (Artsy has too, so yeah, that’s kinda hypocritical, but we’re not aiming to
disrupt &amp; replace the existing “writing online” market we’re <a href="https://www.theverge.com/2017/7/18/15983712/artsy-fine-art-galleries-online-auction-sales">augmenting</a> the existing Art Industry.)</p>

<p>When newspapers like <a href="https://www.forbes.com/sites/theodorecasey/2017/08/14/why-medium-doesnt-matter-anymore/#1fea7cdf49ad">Forbes</a> and <a href="https://www.bloomberg.com/opinion/articles/2017-01-05/why-medium-failed-to-disrupt-the-media">Bloomberg</a> are worried about the Medium business model, then
it doesn’t look great for the longevity of your companies blog. For example, today Medium <a href="https://write.as/blog/ending-our-medium-integration">removed the developer
API</a> for your posts. Folks who used Medium to make money have <a href="http://www.niemanlab.org/2018/05/medium-abruptly-cancels-the-membership-programs-of-its-21-remaining-publisher-partners/">found themselves surprised</a> time
and time again when that changes.</p>

<p>It’s important to note here that I think a lot of this churn is reasonable, they are a start-up and that is
literally what start-ups do. Start-ups iterate through business plan ideas until they find one that scales in a way
that they want and that process takes time. It’s when that ambiguity about what a company does or doesn’t do with
your writing which makes it a dependency which doesn’t pay its weight.</p>

<h2 id="branding">#branding</h2>

<p><a href="/images/hosting-our-own-blog/1.png" style="">
  <img src="/images/hosting-our-own-blog/1.png" alt="Screenshots" style="" />
</a></p>

<p>I consider our blog, and the rest of the site, to be the canonical representation of the Artsy Engineering team
online. We’ve carefully grown an Artsy Engineering aesthetic around it.</p>

<p>In contrast, had we chosen to host on Medium, we’d get a few templates and a highlight color. For example, check
out: <a href="https://medium.com/airbnb-engineering">AirBnB</a>, <a href="https://medium.com/harrys-engineering">Harrys</a>,
<a href="https://medium.com/@Pinterest_Engineering">Pintrest</a>, <a href="https://medium.com/vimeo-engineering-blog">Vimeo</a> or
<a href="https://eng.lyft.com">Lyft</a>’s pages.</p>

<p>Not memorable at all, because you can’t really work with the design constraints to do anything creative other than
a banner image and a color.</p>

<p>These constrains become worse on a post page, where you completely lose any sense of connection with the company,
and the team the moment someone scrolls an inch until the footer. Your team’s writing becomes just “a medium post”
at that point. You’ve got limited options for attaching images, and no ability to use HTML/JS to showcase
<a href="/blog/2017/07/06/React-Native-for-iOS-devs/#React">problems</a> <a href="/blog/2018/03/18/ar/">interactively</a> or explore <a href="http://artsy.github.io/blog/2019/01/23/artsy-engineering-hiring/">new post styles</a>.</p>

<p>These aren’t blockers in any way, most of our posts don’t do that - but the constraints mean you will never think
to try and explain something outside of those constraints.</p>

<p>Then at the bottom of your post, readers are redirected to other posts from other teams. For example, when I opened
a post on Vimeo’s announcement of <a href="https://medium.com/vimeo-engineering-blog/announcing-psalm-v3-76ec78e312ce">Psalm v3</a> (a cool looking PHP dev tool), there were three recommended
posts: one was about missiles being fired in Syria, another was a beginners guide to PHP and then a third was how
to set up Docker to work with a PHP framework. They’re not that related, maybe they all have the keyword of PHP
behind the scenes?</p>

<p><a href="/images/hosting-our-own-blog/3.jpg" style="">
  <img src="/images/hosting-our-own-blog/3.jpg" alt="Artsy x React Native" style="" />
</a></p>

<p>Writing takes a lot of time, and provides so much value. It should be presented as <a href="https://github.com/artsy/README/blob/cb73cb/culture/what-is-artsy.md#quality-worthy-of-art">quality worthy of art</a>.
By using to a generic platform for your writing, you’re trading that simplicity for building your team’s online
presence.</p>

<h2 id="breaking-the-sandbox">Breaking the Sandbox</h2>

<p>We’ve grown to need to showcase quite a few different types of posts:</p>

<ul>
  <li>Small posts that with only a few paragraphs</li>
  <li>Long-form posts that take forever to read</li>
  <li>Long-form interview style posts for many contributors</li>
  <li>Sequential posts, in the form of a series</li>
  <li>YouTube embed posts</li>
  <li>Announcements</li>
  <li>Guest Posts</li>
</ul>

<p>None of these need to be treated the same, and since we created the blog, we’ve added:</p>

<ul>
  <li>Category pages - <a href="/blog/categories/graphql/">GraphQL</a></li>
  <li>Author pages - <a href="/author/orta/">mine</a></li>
  <li>Site series - <a href="/series/react-native-at-artsy/">React Native at Artsy</a></li>
  <li><a href="https://github.com/artsy/artsy.github.io/tree/9f65b5/_layouts">4 separate post layouts</a></li>
  <li>Multi-author posts - <a href="/blog/2018/10/19/pair-programming/">Pair Programming</a></li>
  <li><a href="/blog/2017/07/15/Comments-are-on/">GitHub Issue Powered Comments</a></li>
  <li>Real-time <a href="https://github.com/artsy/artsy.github.io/pull/332">search</a> on our static pages</li>
</ul>

<p>When we’ve wanted to add a new feature to the blog to fit a particular post, we added the feature. This gave us the
chance to not constrain ourselves in ideas. For example, we’ve explored <a href="https://github.com/artsy/artsy.github.io/issues/355#issuecomment-315605280">building a podcast</a> into our blog
treating it as a first class feature in ways that no-one would ever build if it was a platform. Or we’re interested
in making a way to highlight useful links for the</p>

<p>All of those features were made by people whose background was iOS development, which gave us the chance to expand
the horizons of our engineers knowledge.</p>

<h2 id="blog-as-code">Blog as Code</h2>

<p>Because our <a href="https://github.com/artsy/artsy.github.io/tree/9f65b5/_posts">blog posts</a> are markdown in a <a href="https://github.com/artsy/artsy.github.io">GitHub repo</a>, we don’t treat a review for a blog post any
different than a normal pull request for code. It means our <a href="https://github.com/artsy/README/blob/master/culture/peril.md">company Peril rules</a> will run, and all of
engineering has the ability to contribute to the review process.</p>

<p>Having a static site in a GitHub repo means we don’t have to special case our writing in comparison to every-day
work.</p>

<h2 id="call-to-action">Call to Action</h2>

<p>Using Medium is a very reasonable call if you are just trying to get some writing out and online as fast as
possible. If you want to be scrappy and announce something - do it. If you want to do something more serious
though, you should really consider owning your engineering blog and identity. Giving that away to Medium in
exchange for hosting your content and getting more eyeballs isn’t a great trade.</p>

<p>There aren’t many shortcuts for getting folks to visit your blog, and relying on Mediums’ recommendations or SEO
isn’t a good path compared to say Twitter adverts or just writing interesting stuff and letting folks know via a
mailing list.</p>

<p>If self-hosting is an issue, Medium is not the only payer in eco-system, <a href="https://wordpress.com">Wordpress</a>’s company
<a href="https://automattic.com">Automattic</a> has been profitable for years and hosts all sorts of really big blogs. It’s not going anywhere,
and you have the ability to customize it to your style and use a whole massive marketplace of plugins (free and
paid for) - it’s a really great choice.</p>

<p>However, it’s really worth noting how low the barrier to entry it is now to create a blog using a static site
generator:</p>

<ul>
  <li><a href="https://jekyllrb.com">Jekyll</a> - Ruby, the default for GitHub pages and lowest barrier to entry.</li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem <span class="nb">install </span>jekyll bundler
jekyll new myblog
<span class="nb">cd </span>myblog
bundle <span class="nb">exec </span>jekyll serve
</code></pre></div></div>

<ul>
  <li><a href="https://www.gatsbyjs.org">Gatsby</a> - JS, the project we regularly consider moving our blog to. JS folks have such a great focus on
developer experience, and the abstraction of having an in-direction layer for your content via an internal
GraphQL API for your static site is a very, very smart abstraction which will take them a long way.</li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx gatsby new myblog https://github.com/gatsbyjs/gatsby-starter-blog
<span class="nb">cd </span>myblog
yarn dev
</code></pre></div></div>

<ul>
  <li><a href="https://gohugo.io">Hugo</a> - Go, looks pretty reasonable if you have strong opinions against the others somehow</li>
</ul>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install </span>hugo
hugo new site myblog
<span class="nb">cd </span>myblog

git init
git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke
<span class="nb">echo</span> <span class="s1">'theme = "ananke"'</span> <span class="o">&gt;&gt;</span> config.toml

hugo new posts/my-first-post.md
hugo server <span class="nt">-D</span>
</code></pre></div></div>

<p>All of these come with some sort of theme or templating support so getting started could probably take about an
hour to get a static site up and running using a host like <a href="https://pages.github.com">GitHub Pages</a>, <a href="https://www.netlify.com">Netlify</a> or <a href="https://zeit.co/now">Now</a>.
All three of these you can set up automatic hosting from GitHub in about 10-15m.</p>

<!-- prettier-ignore-start -->
<!-- prettier-ignore-end -->
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keeping Artsy's dependencies up to date]]></title>
    <link href="https://artsy.github.io/blog/2018/11/26/keeping-dependencies-updated/"/>
    <updated>2018-11-26T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2018/11/26/keeping-dependencies-updated</id>
    <content type="html"><![CDATA[<p>Hey everyone! I’m Justin, a senior engineer here at Artsy. I’ve been here for about 6 months and I’m a bit overdue
on my first blog post. This will be one of a series of posts I’m dubbing <em>roads and bridges</em> (<a href="https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/">thanks Orta</a>)
describing infrastructure and tooling work here at Artsy.</p>

<h3 id="backstory">Backstory</h3>

<p>Here at Artsy we have a lot of internal dependencies. Keeping these dependencies up to date across all of our
projects can be a bit of a headache. For example, there’s <a href="https://github.com/artsy/palette">Palette</a> (our <a href="https://www.uxpin.com/studio/blog/design-systems-vs-pattern-libraries-vs-style-guides-whats-difference/">design system</a>)
which is consumed by <a href="https://github.com/artsy/reaction">Reaction</a> (our react component/app library), <a href="https://github.com/artsy/emission">Emission</a> (our React Native
application), <a href="https://github.com/artsy/force">Force</a> (our main site), and <a href="https://github.com/artsy/positron">Positron</a> (our editorial creation tool). That’s not
even an exhaustive list. As you can imagine, after making an update to <a href="https://github.com/artsy/palette">Palette</a> we have to make a lot of
Pull Requests to get everything synced up across our many projects. And that’s just <em>one</em> dependency.</p>

<!-- more -->

<h3 id="evaluating-the-problem">Evaluating the problem</h3>

<p>There are a few services out there that connect to GitHub and helps you keep your dependencies up to date. I’d
personally used <a href="https://greenkeeper.io/">Greenkeeper</a> in the past and it seemed to work fairly well for my uses. I’d also
heard about <a href="https://renovatebot.com/">Renovate</a> which is another option that actually supports more package managers than just
yarn/npm. Great! Plenty to evaluate here. Anytime I’m evaluating a new service there are a few questions I ask
myself upfront to help a good decision:</p>

<ol>
  <li>What are my exact needs</li>
  <li>Can this solution scale to meet future needs</li>
</ol>

<p>The first point is straight-forward, but there’s a little twist. We have a <em>lot</em> of dependencies. If we got PRs for
all of them we’d be pretty much unable to do anything. In this case we wanted to specifically limit it to packages
that are published by Artsy (on the <code class="language-plaintext highlighter-rouge">@artsy</code> npm namespace).</p>

<p>The second you have to be a bit careful with. Don’t try to project too far or you’ll end up choosing a solution far
too complex for your current needs. In this case, I wanted something that we could selectively extend in the future
to cover other dependencies. Things like <code class="language-plaintext highlighter-rouge">react</code> and <code class="language-plaintext highlighter-rouge">react-dom</code> or <code class="language-plaintext highlighter-rouge">typescript</code>. Incremental increases without a
ton of noise.</p>

<h3 id="picking-a-solution">Picking a solution</h3>

<p>First things first… we have to have a solution that can update only Artsy’s dependencies. I started digging
through <a href="https://greenkeeper.io/">Greenkeeper</a>’s docs and found a reference to an <a href="https://greenkeeper.io/docs.html#ignoring-dependencies">ignore</a> option.
Essentially any package that you don’t want <a href="https://greenkeeper.io/">GreenKeeper</a> to automatically update you can put in this
ignore list. That’s not really doable in our usecase because we want to ignore everything but a small subset of
packages.</p>

<p>Checking out <a href="https://renovatebot.com/">Renovate</a>’s docs I found a more promising option:
<a href="https://renovatebot.com/docs/configuration-options/#excludepackagepatterns">excludePackagePatterns</a>. All I really want to do is include Artsy packages, but this sounded
like I could do the inverse by excluding all non-Artsy packages. Being as it had that option, supported more
package managers, and had a more friendly pricing scheme than <a href="https://greenkeeper.io/">Greenkeeper</a> I decided to give
<a href="https://renovatebot.com/">Renovate</a> a shot.</p>

<h3 id="making-it-happen">Making it happen</h3>

<p>I began by enabling <a href="https://renovatebot.com/">Renovate</a> on <a href="https://github.com/artsy/force">Force</a>. You can see the PR <a href="https://github.com/artsy/force/pull/3086">here</a>.
<a href="https://renovatebot.com/">Renovate</a> has a <em>really</em> excellent on-boarding experience. It first creates a PR that adds its own
configuration. It shows you what packages will be updated based on that configuration. As you update the config,
Renovate will update the PR body to show you the results of your changes. This gives you the opportunity to update
the configuration before it officially activates. If you click the edited dropdown on the PR body you’ll see all
the changes Renovate made to the issue while I was trying to figure out the configuration.</p>

<p><img src="/images/2018-11-26-keeping-dependencies-updated/issue-history.png" alt="GitHub PR edit history" /></p>

<p>It took me a while to figure everything out, just take a look at the <a href="https://github.com/artsy/force/pull/3086/commits">commit history</a>. I’m going to
work through the final setup just to give you an idea of our setup.</p>

<p>First, I extended <a href="https://renovatebot.com/">Renovate</a>’s base config.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "extends": [
    "config:base"
  ],
  ...
}
</code></pre></div></div>

<p>If you’ve worked with <a href="https://eslint.org">eslint</a>, <a href="https://babeljs.io/docs/en/options#extends">babel</a>, or other tools in the js ecosystem, you’ve probably
seen this type of configuration extension. It essentially allows us to use their best practices out of the box.
Check out their <a href="https://github.com/renovatebot/presets/blob/ef6a6e2e6d3e6ba25239d57d808b0e4dc64f32a3/packages/renovate-config-config/package.json#L19-L34">presets repo</a> if you want to know what it adds specifically.</p>

<p>Next, I set the <a href="https://help.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/">assignees</a>. When <a href="https://renovatebot.com/">Renovate</a> opens a new PR, it’ll assign it to these people
so that the PR doesn’t get missed.</p>

<p>The actual meat of the change is the <code class="language-plaintext highlighter-rouge">packageRules</code> setup.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  ...
  "packageRules": [{
    "packagePatterns": ["*"],
    "excludePackagePatterns": ["^@artsy"],
    "enabled": false
  }],
  ...
}
</code></pre></div></div>

<p><a href="https://renovatebot.com/">Renovate</a> allows you to set up multiple different <code class="language-plaintext highlighter-rouge">packageRules</code> and there’s a lot of configuration for
them. I’m not going to go through more than I did, but feel free to read more in their
<a href="https://renovatebot.com/docs/configuration-options/#packagerules">docs</a>. In the <code class="language-plaintext highlighter-rouge">packageRule</code> that I setup, I specified <code class="language-plaintext highlighter-rouge">packagePatterns</code> with an
asterisk to select all dependencies. Then using <code class="language-plaintext highlighter-rouge">excludePackagePatteners</code> I excluded anything that started with
<code class="language-plaintext highlighter-rouge">@artsy</code>. Finally (and most importantly), I set <code class="language-plaintext highlighter-rouge">enabled</code> to <code class="language-plaintext highlighter-rouge">false</code> to disable the dependencies matching those
combinations of rules. That last part took me a while to figure out. When you’re building package rules in
<a href="https://renovatebot.com/">Renovate</a>, think of it as building out a list of operations to perform.</p>

<p>The last few pieces of config are a little more straight-forward and you can read about those in the docs. The one
thing that I’ll mention is that <a href="https://renovatebot.com/docs/configuration-options/#vulnerabilityalerts">vulnerabilityAlerts</a> <em>ignores</em> <code class="language-plaintext highlighter-rouge">packageRules</code> and
triggers update PRs for anything that’s reported to have a vulnerability. You’ll have to explicitly disable it if
you only want reports on certain packages. Though, having it on probably isn’t a bad idea…</p>

<h3 id="wrapping-up">Wrapping up</h3>

<p>So, that’s how we configured <a href="https://renovatebot.com/">Renovate</a> to automatically update npm dependencies in Artsy’s namespace.
It’s been extremely useful already. I also went ahead and pulled our configuration out into a <a href="https://github.com/artsy/renovate-config">shared
repo</a> so that we didn’t have to copy these configurations across all of our projects. That’s
a blog post for another day.</p>

<p>Be well friends.</p>

<!-- prettier-ignore -->

<!-- prettier-ignore -->

<!-- prettier-ignore -->
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why does my team's Podfile.lock Podspec checksums change?]]></title>
    <link href="https://artsy.github.io/blog/2016/05/03/podspec-checksums/"/>
    <updated>2016-05-03T12:09:00+00:00</updated>
    <id>https://artsy.github.io/blog/2016/05/03/podspec-checksums</id>
    <content type="html"><![CDATA[<p>We use CocoaPods, and <a href="https://github.com/artsy/eigen/issues/418">we don’t check in our Pods</a> directory for one of our fastest moving apps, <a href="https://github.com/artsy/eigen/">Eigen</a>. This sometimes can cause an <a href="https://github.com/artsy/eigen/pull/1464">interesting data churn</a> inside the <code class="language-plaintext highlighter-rouge">Podfile.lock</code> when developers have different sha checksums for their Pods. This is weird, what gives?</p>

<!-- more -->

<h3 id="what-are-the-lockfiles">What are the Lockfiles?</h3>

<p>First off, to ensure we’re talking about the same thing, this is our <a href="https://github.com/artsy/eigen/blob/master/Podfile.lock">Podfile.lock</a>. The lockfile is used on <code class="language-plaintext highlighter-rouge">pod install</code> to ensure all the members of your team have the <em>exact same</em> version of the libraries as each other. Otherwise, with a Podfile like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">platform</span> <span class="ss">:ios</span><span class="p">,</span> <span class="s1">'9.3'</span>
<span class="n">pod</span> <span class="s1">'AFNetworking/Serialization'</span><span class="p">,</span> <span class="s1">'~&gt; 3.0'</span>
<span class="n">target</span> <span class="s1">'MyApp'</span>
</code></pre></div></div>

<p>A developer running <code class="language-plaintext highlighter-rouge">pod install</code> would get the latest <code class="language-plaintext highlighter-rouge">3.x</code> version, which could be <code class="language-plaintext highlighter-rouge">3.1</code> originally, but then 6 months later they could get <code class="language-plaintext highlighter-rouge">3.4</code> - without a lockfile there is no way to keep track of the specific build. This is why it should always be in your code repo. In the case above my lockfile looks like this:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">PODS</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">AFNetworking/Serialization (3.1.0)</span>

<span class="na">DEPENDENCIES</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">AFNetworking/Serialization (~&gt; 3.0)</span>

<span class="na">SPEC CHECKSUMS</span><span class="pi">:</span>
  <span class="na">AFNetworking</span><span class="pi">:</span> <span class="s">5e0e199f73d8626b11e79750991f5d173d1f8b67</span>

<span class="na">PODFILE CHECKSUM</span><span class="pi">:</span> <span class="s">876ceaa409f4ade2b3d58d310dbe026393824bcc</span>

<span class="na">COCOAPODS</span><span class="pi">:</span> <span class="s">1.0.0.beta.8</span>
</code></pre></div></div>

<h3 id="what-do-the-spec-checksums-do">What do the Spec Checksums do?</h3>

<p>With the CocoaPods Master Specs repo, we do our best <a href="https://github.com/CocoaPods/Specs/pull/12199">to try</a> and ensure a write-once repository of Podspecs for the public. However, there are many times when you cannot guarantee that every you have the same version of a Podspec as everyone else in your team.</p>

<p>So, CocoaPods makes a checksum of the JSON representation of your Podspec and keeps that in the lockfile. You can easily <a href="https://github.com/CocoaPods/CocoaPods/issues/3371">replicate</a> the work to generate a checksum with:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/D/MyApp ⏛  pod ipc spec ~/.cocoapods/repos/master/Specs/AFNetworking/3.1.0/AFNetworking.podspec.json  | openssl sha1
5e0e199f73d8626b11e79750991f5d173d1f8b67
</code></pre></div></div>

<h3 id="so-why-am-i-seeing-churn">So why am I seeing churn?</h3>

<p>A normal git development flow when working with libraries is to:</p>

<ul>
  <li>Fork a library, change your Podfile to reflect that change</li>
  <li>Make some changes</li>
  <li>Commit them back to the main repo</li>
  <li>Update the Podspec, then make changes bringing your Podfile back to a real (tagged) release</li>
</ul>

<p>CocoaPods is smart about updating your libraries behind the scenes, but it’s not perfect. In order to avoid re-creating your entire Pods folder every time it will check whether your libraries are at the expected version and skip re-creating the whole process.</p>

<p>In the example above, we used the CocoaPods’ Specs repo version of the Podspec. In forked repos, e,g,</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pod</span> <span class="s1">'AFNetworking/Serialization'</span><span class="p">,</span> <span class="ss">:git</span> <span class="o">=&gt;</span> <span class="s2">"https://github.com/orta/AFNetworking.git"</span><span class="p">,</span> <span class="ss">:commit</span> <span class="o">=&gt;</span> <span class="s2">"6f31b5c7bcbd59d4dac7e92e215d3c2c22f3400e"</span>
</code></pre></div></div>

<p>The Podspec is saved into the <code class="language-plaintext highlighter-rouge">Pods</code> directory in JSON format at <code class="language-plaintext highlighter-rouge">Pods/Local\ Podspecs/AFNetworking.podspec.json</code>, this is to ensure there’s always access within the CocoaPods sandbox for the Podspecs, and speed probably. This is the podspec used for generating the checksum.</p>

<p><strong>So how can this get out of sync?</strong></p>

<ul>
  <li>During the development cycle, when working with a library you would have used <code class="language-plaintext highlighter-rouge">pod update [library]</code> to update just that library you were working on.  This could happen multiple times as you build your changes.</li>
  <li>You continued working against your fork till it was ready for review. At this point you have a working version, you submit a PR for code review on the library.</li>
  <li>There are changes that affect the podspec that come up in review, you don’t do a <code class="language-plaintext highlighter-rouge">pod update [library]</code> but send the code back to review ( maybe you changed some metadata for example, which doesn’t warrant another update to pass CI. )</li>
  <li>Once all code is reviewed, everything is merged back into master.</li>
  <li>You <code class="language-plaintext highlighter-rouge">pod install</code> - which continues to use the older version of the Podspec inside the Pods dir, e.g. <code class="language-plaintext highlighter-rouge">Pods/Local\ Podspecs/AFNetworking.podspec.json</code>.</li>
  <li>You now have the older <code class="language-plaintext highlighter-rouge">AFNetworking.podspec.json</code> inside your local Pods folder, when the next person runs <code class="language-plaintext highlighter-rouge">pod install</code> with your changes merged, they get a different SHA, as they’ve got the version with the metadata changes.</li>
</ul>

<h3 id="simple-fix">Simple Fix</h3>

<p>The best option is to run <code class="language-plaintext highlighter-rouge">pod update [library]</code> on the computer which is causing churn, this will tell CocoaPods specifically to request a new version of the library. If that fails to give the same checksum as the rest of your team, there’s the good old fasioned <code class="language-plaintext highlighter-rouge">rm -rf Pods &amp;&amp;  pod install</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocoa Architecture: Dependencies]]></title>
    <link href="https://artsy.github.io/blog/2015/09/18/Cocoa-Architecture-Dependencies/"/>
    <updated>2015-09-18T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2015/09/18/Cocoa-Architecture-Dependencies</id>
    <content type="html"><![CDATA[<p>As a part of going through the design patterns we’ve found in the creation of the Artsy iOS apps, I’d like to talk a bit about some of
the way in which we decide our apps dependencies.</p>

<p>It’s easy to think of your dependencies as being things in your Podfile, but it’s a bit more nuanced than that. The tools you use for development, deployment, testing and external integrations are all things in which you depend on others to make your app work. I’d like to look into the hows and the whys of the decisions we’ve made.</p>

<!-- more -->
<hr />

<p>The mobile team of is a collection of smart people; we aim to work with people who have different opinions, and different backgrounds. This means we often don’t agree on project direction but moving forwards is about finding compromise. Every technical project within Artsy has a de-facto leader, and they get to make the call at the end of the day.</p>

<p>This means that dependencies and priorities change per-project, because a different developer has more influence on the end result. There isn’t a singular “Artsy Mobile” way.</p>

<h3 id="implicit-dependencies">Implicit Dependencies</h3>

<p>Thinking on the largest macro scope, I think these are our biggest dependencies:</p>

<ul>
  <li>Xcode</li>
  <li>iOS SDK</li>
  <li>Swift</li>
  <li>CocoaPods</li>
  <li>Individual Pods</li>
  <li>Fastlane</li>
</ul>

<p>Some of these are mandatory, mainly Xcode and the iOS SDK. Talk to someone at Facebook however and they’ll tell you even that can become a <a href="http://facebook.github.io/react-native/">much weaker dependency</a> than you’d think. For us though, we still create native apps that eventually get built via <code class="language-plaintext highlighter-rouge">xcodebuild</code> either via Xcode/AppCode/Vim as a part of our individual build processes.</p>

<p>The dependencies provided by Apple are the daily trade-off in order to build apps that are competitive. Apple ships a new SDK each year, developers need to ship new builds. If you can keep pace, then you can get your app in-front of millions of potentially paying customers.</p>

<h3 id="leveraging-oss">Leveraging OSS</h3>

<p>So, allow me to don my best flame-proof suit and answer the intent of the question that was originally asked of us? <em>What qualities do we look for in OSS dependencies?</em></p>

<p>This question is interesting because we’re not just shipping an app in the dark, every app we have is open source and available for inspection. Our choices with OSS dependencies become our implicit public recommendations, why else would we be using them?</p>

<p>To to give the simplest TLDR; I created the <a href="https://guides.cocoapods.org/making/quality-indexes">CocoaPods Quality Indexes</a>. The Quality Indexes (QIs) are a series of metrics that are applied programmatically to every library which generate a single number that <a href="http://cocoapods.org">cocoapods.org</a> uses for search ranking. These are based on conversations within Artsy, and as many contributors as I could during the course of a year. Here are a few QIs that matter a lot to me:</p>

<ul>
  <li>The library is popular, this is measured in GitHub stars.</li>
  <li>Great README, has a CHANGELOG and uses internal appledoc/headerdoc.</li>
  <li>The project has test coverage.</li>
</ul>

<p>If you’re interested in the reasoning behind these, I’d recommend reading the <a href="https://guides.cocoapods.org/making/quality-indexes">full guide for the metrics</a>.</p>

<p>If I could determine that a project was a good dependency via code - I wouldn’t be writing apps, I’d be a millionaire, who has moved on to working in politics or cryptography in Denmark. So what are the key metrics that not Turing-compatible?</p>

<h4 id="can-we-take-over">Can We Take Over?</h4>

<p>We’re a pretty versatile bunch of developers, even with our focus on native iOS development. Being able to understand a foreign codebase when debugging a problem, in order to <a href="http://dictionary.reference.com/browse/grok">grok</a> if a bug lies in our code or a libraries is essential.</p>

<p>Being blocked because you don’t understand how to create an assembly trampoline for message passing on 64 bit processors sucks. Relying on someone else to provide a fix in their spare time, is a nice way to strain a relationship.</p>

<p>There have been times when we’ve taken over libraries completely, which has worked out well for everyone involved. Examples being <a href="https://cocoapods.org/pods/NAMapKit">NAMapKit</a> and <a href="https://cocoapods.org/pods/Specta">Specta</a>/<a href="https://cocoapods.org/pods/Expecta">Expecta</a>. It can be a matter of providing small incremental work on the project, or just being someone with a vision <a href="http://orta.io/rebase/oss-management/">for the project</a>.</p>

<h4 id="features-vs-hidden-dependencies">Features vs Hidden Dependencies</h4>

<p>A dependency can offer you shortcuts to features, new ways to do things or a way to interface with externalities. When you look at the README you get to see all of the best parts of a library, the reasons why it’s worth trying, the easy installation instructions. You don’t get to see some of uglier issues under the surface, that only become exposed once you look a bit harder.</p>

<p>These can be subtle for example, using Fastlane introduces a lot of dependencies.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/dev/scratch ⏛  <span class="nb">cat </span>Gemfile
gem <span class="s1">'fastlane'</span>

~/dev/scratch ⏛  bundle <span class="nb">install</span>
<span class="o">[</span>...]
Bundle <span class="nb">complete</span><span class="o">!</span> 1 Gemfile dependency, 73 gems now installed.
</code></pre></div></div>

<p>There’s a trade-off here, Fastlane provides a great programmable API to a bunch of really annoying time-consuming tasks. There isn’t a system similar to CocoaPods’ subspecs which lets a library consumer choose to use a subset of a dependency graph, so instead everyone gets <code class="language-plaintext highlighter-rouge">slack-notifier</code> regardless of if you need it.</p>

<p>ReactiveCocoa feels quite similar. In exchange for Cocoa-native approach to Functional Reactive Programming you also have:</p>

<ul>
  <li>Swizzling dealloc on objects in order to do it’s magic KVO-unbinding at runtime.</li>
  <li>To pretty much giving up on trying to use the stack trace for understanding flow. Instead you can use their custom dtrace instrument.</li>
  <li>Complicated pre-compiler macros that can get tricky to debug.</li>
</ul>

<p>These trade-offs can be happily made in exchange for ReactiveCocoa’s well thought out API. Functional Reactive Programming is something that the majority of us are particularly interested in. Since Swift came out, a few Swift-only FRP libraries have been released. So we’ve been keeping our eyes <a href="https://cocoapods.org/?q=summary%3Areactive">on the alternatives</a>.</p>

<h4 id="focus">Focus</h4>

<p>Ideally you’re bringing in a dependency for one specific task. Something like <a href="https://cocoapods.org/pods/ObjectiveSugar">ObjectiveSugar</a> is a great example of a small focused library. I studied it’s API when we first integrated it, and it’s not really changed at all since. The library authors have done a great job of ensuring that Objective Sugar stays on-topic.</p>

<h4 id="community-relationships">Community Relationships</h4>

<p>The amount of energy you have to put into using certain dependencies, in an engaging way like we do, also means you have to interact with external people. This is often the case with OSS, so we’re used to that and quite good at it. Sometimes, however, people and their opinions don’t match, it’s a fact of life, and in these cases it can be worth choosing to not use a certain dependency.</p>

<p>One such example has been ReactiveCocoa. While they are free to make whatever decisions they like, we feel that we’ve wasted energy on supporting their dependencies in CocoaPods that took away from our already constraining time-budget. Our interactions consume and creates energy that we don’t want to be associated with. This makes us want to engage less with the community at whole, which is really not something we want. So that, combined with our opinion on the framework itself (as aforementioned) means we’re looking at alternatives.</p>

<p>This contrasts sharply with working on Fastlane, where we’re willing to take the dependency graph in part because working with <a href="https://krausefx.com">Felix Krause</a> is such a pleasure. We’ve sent PRs,  helped out on <a href="https://github.com/KrauseFx/fastlane/pull/173">documentation</a> and provided advice on how we would/are using Fastlane. I actively feel guilty that we’re still not deploying to the App Store using Fastlane because of this relationship.</p>

<h4 id="project-maturity">Project Maturity</h4>

<p>We got burned by working with Swift too early, but coming back at Swift 2.0 feels good. We just started introducing Swift into our Objective-C codebases, as it’s looking like the tooling has matured.</p>

<p>We spent a good chunk of time over the last 6 months discussing and testing out React Native as an approach for building apps. It’s turning into an amazing platform, but for us it’s not mature enough to start building apps with it as a foundation.</p>

<h2 id="not-all-dependencies-are-third-party">Not All Dependencies are Third Party</h2>

<p>We ship a lot of our internal code as Pods. The rubric we use for deciding on when to externalise code is “would we want this in more than 2 apps” at the moment. This is an easy choice for libraries as fundamental as a fonts, or colours schemes. It becomes a more nuanced choice when it comes to <a href="https://github.com/ashfurrow/Forgeries">a class or two</a>, or <a href="https://github.com/orta/ar_dispatch">some functions</a>.</p>

<p>Creating a library that gets popular can also turn into an unexpected time-sink, we’ve been supporting <a href="https://cocoapods.org/pods/ARAnalytics">ARAnalytics</a> for 4 years now and nearly all features for the last 3 years have come from external developers. Ensuring that they don’t break the build, making monthly releases and keeping documentation up to date takes time. <a href="https://cocoapods.org/pods/Moya">Moya</a> has consumed multiple weekends in a row of our time.</p>

<p>Ensuring that we are good stewards for the code we release as a separate consumable library is important to our team values. We’ve not had to deprecate a library, though I look forwards to doing that to <a href="https://cocoapods.org/pods/ORStackView">ORStackView</a> at some point when everyone is building for iOS9+.</p>

<h3 id="nuance">Nuance</h3>

<p>There are no simple answers to “should you use a certain dependency”. The CocoaPods QIs can give you a sense of what libraries are worth looking into, then you can load up a demo for the library by running <code class="language-plaintext highlighter-rouge">pod try [Podname]</code> to dig around and get a feel for how the library works. These decisions end up being quite personal.</p>

<p>We work with external dependencies because we enjoy:</p>

<ul>
  <li>Working with other people.</li>
  <li>Making improvements for the entire community, instead of just ourselves.</li>
  <li>Not having to re-invent the wheel.</li>
</ul>

<p>For us, it’s nearly always win-win.</p>
]]></content>
  </entry>
  
</feed>
