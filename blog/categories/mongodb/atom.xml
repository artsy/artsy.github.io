<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MongoDB | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/mongodb/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2024-08-06T19:48:16+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Are you using the right Mongo geospatial query?]]></title>
    <link href="https://artsy.github.io/blog/2023/02/10/mongo-geospatial-queries/"/>
    <updated>2023-02-10T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2023/02/10/mongo-geospatial-queries</id>
    <content type="html"><![CDATA[<p>We recently got a report from one of our galleries in the Los Angeles area that
they weren’t showing up on our
<a href="https://www.artsy.net/shows/los-angeles-ca-usa">Los Angeles exhibition listings</a>.</p>

<p>I fielded the report and right away confirmed: when we asked our core API for
<code class="language-plaintext highlighter-rouge">/shows?near=&lt;los angeles coordinates&gt;</code>, sure enough this gallery partner didn’t
make the cut.</p>

<p>Turns out they are based in Santa Monica, a separate and neighboring
municipality. They must not be within the 25km radius that we use by default for
these sorts of queries.</p>

<p><em>Case closed</em>. Or so I thought.</p>

<!-- more -->

<p>After some back and forth with our partner I decided to investigate more
thoroughly, this time using some tricks of the trade from
<a href="https://www.anandarooproy.com">my other life</a> outside of Artsy.</p>

<h2 id="casting-a-wider-net">Casting a wider net</h2>

<p>If there was something wrong with our 25km radius query, I wanted to start by
casting a wider net and visualizing the results.</p>

<p>I consulted our Rails application code to find the query logic in question, and
then issued the same query directly to MongoDB. Something like the following
query (simplified for clarity):</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a $geoWithin $center query</span>

<span class="nx">db</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span>
  <span class="na">coordinates</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">$geoWithin</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">$center</span><span class="p">:</span> <span class="p">[[</span><span class="o">-</span><span class="mf">118.24</span><span class="p">,</span> <span class="mf">34.05</span><span class="p">],</span> <span class="mi">25</span> <span class="o">/</span> <span class="mf">111.32</span><span class="p">],</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">})</span>
</code></pre></div></div>

<p>In the query above we are asking MongoDB to give us all events within a 25km
radius around the point 34.05°N, 118.24°W which we have designated as a central
point within Los Angeles. For our purposes in this post we can consider “events”
≈ “exhibitions” ≈ “shows.”</p>

<p>We are not asking for the 25km radius directly, but rather converting it into an
equivalent amount of geographic degrees by using a conversion factor of 1° ≈
111.32 kilometers, a factor which is true at enough the equator.</p>

<p>I modified the above query to cast a 50km net in order to see if there were some
edges cases that needed scrutiny. Taking the resulting JSON response, I fired up
<a href="https://www.placemark.io/">Placemark</a>, my favorite new tool for wrangling
geospatial data.</p>

<p>(Incidentally I recommend reading Tom Macwright’s
<a href="https://macwright.com/2023/01/28/placemark.html">recent reflection on creating Placemark</a>
as a bootstrapped indie developer.)</p>

<figure class="illustration">
  <img src="/images/2023-02-10-mongo-geospatial-queries/1.png" alt="Screenshot of a visualization in Placemark showing Los Angeles area exhibitions within a 50km radius." />
  <figcaption>All shows within a 50km radius</figcaption>
</figure>

<h2 id="ball-of-confusion">Ball of confusion</h2>

<p>One nice feature of Placemark is that it lets us place geodesic circles on the
map, that is, circles that represent a constant radius around a point, as
plotted on a globe.</p>

<p>When I placed a 25km radius circle on the map, something stood out immediately.</p>

<figure class="illustration">
  <img src="/images/2023-02-10-mongo-geospatial-queries/2.png" alt="Screenshot of a visualization in Placemark showing Los Angeles area exhibitions within a 50km radius, with a 25km radius superimposed." />
  <figcaption>25km radius superimposed. <a style="padding-bottom: 1px; border-bottom: solid 1px lightgray" href="https://en.wikipedia.org/wiki/Ball_of_Confusion_%28That%27s_What_the_World_Is_Today%29">Ball of Confusion</a>, that's what the world was that day.</figcaption>
</figure>

<p>The partner in question is highlighted in pink — and is clearly within the 25km
radius. <strong>What gives?</strong></p>

<p>By spot-checking a few points on the map against our current geo query I found
that edge cases near the top or bottom of the circle were likely to be evaluated
correctly, while edges cases at the left and right were being incorrectly
omitted, as our partner gallery was.</p>

<p>A fuller visualization of that finding would look like this:</p>

<figure class="illustration">
  <img src="/images/2023-02-10-mongo-geospatial-queries/3.png" alt="Screenshot of a visualization in Placemark showing the results of a $geoWithin $center query" />
  <figcaption>Results of a <code>$geoWithin $center</code> query around Los Angeles, evaluated against a grid of test points.</figcaption>
</figure>

<p>A distinctly <em>non</em>-circular circle — that rung a bell.</p>

<h2 id="more-than-one-way-to-draw-a-circle-on-the-earth">More than one way to draw a circle on the Earth</h2>

<p>It was at this point that I recalled the specific form of the geospatial query
our code was performing, and consulted the
<a href="https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/">MongoDB docs for the $geoWithin query</a>.</p>

<p>Turns out that you can invoke this as a radius query in one of two ways, by
specifying
<a href="https://www.mongodb.com/docs/manual/reference/operator/query/center/">$center</a>
or
<a href="https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/">$centerSphere</a>.</p>

<p>Per the
<a href="https://www.mongodb.com/docs/manual/reference/operator/query/center/#behavior">docs</a>
for <code class="language-plaintext highlighter-rouge">$center</code>, this query…</p>

<blockquote>
  <p>calculates distances using flat (planar) geometry</p>
</blockquote>

<p>Let us pause for a moment to note that while only some maps are
<a href="https://press.uchicago.edu/ucp/books/book/chicago/H/bo27400568.html">deceitful</a>,
<em>all</em> maps are untruths. In the sense that they flatten three dimensions down to
two, and inevitably distort the world in the process.</p>

<p>The surface of a three-dimensional globe cannot be flattened down to a
two-dimensional plane without some stretching or tearing, any more than an
orange peel can be. The mathematical algorithms for turning those three
dimensions into two are what we know as map projections. (Ah, the good old days
when “dimensionality reduction” meant <em>from three to two</em>.)</p>

<p>If you do your distance calculations in such a flattened, projected coordinate
system — as the <code class="language-plaintext highlighter-rouge">$geoWithin $center</code> query does — then you are accepting
whatever distortions are inherent to that projection.</p>

<p>That’s the situation we were in. We thought we were catching everything inside
the green circle, but in fact we were only catching everything inside the red
egg:</p>

<figure class="illustration">
  <img src="/images/2023-02-10-mongo-geospatial-queries/5.png" alt="Screenshot of a visualization in Placemark showing the results of a $geoWithin $center query compared to the expected results" />
  <figcaption>Actual <code>$geoWithin $center</code> results vs. expected results.</figcaption>
</figure>

<p>And our unfortunate partner was <em>just</em> outside the egg, thus being incorrectly
omitted.</p>

<h2 id="fixing-the-query">Fixing the query</h2>

<p>Luckily the solution was simple.</p>

<p>As noted above MongoDB supports a second variant for radius queries using a
<code class="language-plaintext highlighter-rouge">$centerSphere</code> operator instead of the <code class="language-plaintext highlighter-rouge">$center</code> that we were using.</p>

<p>Per the
<a href="https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/">docs</a>
for <code class="language-plaintext highlighter-rouge">$centerSphere</code>, this version…</p>

<blockquote>
  <p>defines a circle for a geospatial query that uses spherical geometry</p>
</blockquote>

<p>In other words, this query effectively draws our circle on the three-dimensional
globe rather than on the stretched and distorted two-dimensional map.</p>

<p>We just need to rewrite our query as follows:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// a $geoWithin $centerSphere query</span>

<span class="nx">db</span><span class="p">.</span><span class="nx">events</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span>
  <span class="na">coordinates</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">$geoWithin</span><span class="p">:</span> <span class="p">{</span>
      <span class="c1">// $center: [[-118.24, 34.05], 25 / 111.32],    /* BEFORE */</span>
      <span class="na">$centerSphere</span><span class="p">:</span> <span class="p">[[</span><span class="o">-</span><span class="mf">118.24</span><span class="p">,</span> <span class="mf">34.05</span><span class="p">],</span> <span class="mi">25</span> <span class="o">/</span> <span class="mf">6378.1</span><span class="p">]</span> <span class="cm">/* AFTER */</span><span class="p">,</span>
    <span class="p">},</span>
  <span class="p">},</span>
<span class="p">})</span>
</code></pre></div></div>

<p>There is a new conversion factor in play here, this time denoting that the
radius of the earth is approximately 6378.1 km. In this <code class="language-plaintext highlighter-rouge">$centerSphere</code> flavor
of the query we are working in unprojected
<a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">spherical coordinates</a>,
measured in <a href="https://en.wikipedia.org/wiki/Radian">radians</a>. Thus we need to
account for the size of the sphere that we are calculating upon.</p>

<p>We can re-run
<a href="https://gist.github.com/anandaroop/a1b794559615b2bbdea097678321c93f">our test</a>
with this version of the query, and now we see that the results are finally in
line with what we were expecting:</p>

<figure class="illustration">
  <img src="/images/2023-02-10-mongo-geospatial-queries/4.png" alt="Screenshot of a visualization in Placemark showing the results of a $geoWithin $centerSphere query" />
  <figcaption>Results of a <code>$geoWithin $centerSphere</code> query around Los Angeles, evaluated against a grid of test points.</figcaption>
</figure>

<p>Having updated our API to use this variant of the query, we solved the problem
and returned our partner gallery to its rightful place in our listings, as shown
by the pink highlight above.</p>

<p>That was the happy ending we were looking for.</p>

<h2 id="a-postscript-on-map-distortion">A postscript on map distortion</h2>

<p>But if you’re curious to learn a little more about map distortion, let’s dig a
bit deeper into the nature of the problem that we were encountering.</p>

<p>Returning to <a href="https://www.placemark.io/">Placemark</a>’s ability to draw different
kinds of circles on the map, let’s now place a <em>geographic</em> circle on the map
rather than a geodesic one. This one is computed in the simplest possible map
projection — a geographic projection where we simply treat the longitude as the
X coordinate and the latitude as the Y coordinate. (This projection goes by many
names, such as “geographic”, “equirectangular”, “Plate Carrée” or even
<em>“unprojected”</em>, which is not quite accurate.)</p>

<p>This corresponds to what you get when you use MongoDB’s <code class="language-plaintext highlighter-rouge">$geoWithin</code> <code class="language-plaintext highlighter-rouge">$center</code>
query on geospatial data:</p>

<figure class="illustration">
  <img src="/images/2023-02-10-mongo-geospatial-queries/6.gif" alt="Animation showing the distortion a geographic circle encounters at various latitudes" />
  <figcaption>Animation showing the distortion a geographic circle encounters at various latitudes.</figcaption>
</figure>

<p>As you can see, we get: a moderately oblong egg at the latitude of Los Angeles;
a nice circle as we get close to the equator; and a very oblong egg as we
approach the poles.</p>

<p>If you are wondering why you should trust my claims about the egginess of <em>this</em>
two-dimensional image after I just said that all such maps are lies — good
question!</p>

<p>It just so happens that nearly all web-based interactive maps, including
Placemark, use a variation of the Mercator projection, the one you might
remember from schoolroom maps. Mercator is a so-called
“<a href="https://en.wikipedia.org/wiki/Conformal_map_projection">conformal</a>”
projection, meaning that <em>its</em> particular lie is to sacrifice area in favor of
shape.</p>

<p>A shape drawn on a globe will be correctly maintained in a Mercator map, but the
scale will vary across the map: true at the equator and very incorrect towards
the poles. This is the reason for the common complaint that
<a href="https://www.nature.com/nature-index/news-blog/data-visualisation-animated-map-mercater-projection-true-size-countries">Mercator maps show Greenland as about the same size as Africa</a>,
when in fact Africa is about 14 times larger.</p>

<p>The amount and nature of the distortion introduced by map projections is such an
important topic that cartographers have long relied on a clever technique for
communicating this distortion visually, known as
“<a href="https://en.wikipedia.org/wiki/Tissot%27s_indicatrix">Tissot’s indicatrix</a>.”</p>

<p>To give you a sense of the kind of distortion we encountered with the <code class="language-plaintext highlighter-rouge">$center</code>
query, here is what Tissot’s indicatrix looks like for the geographic
projection. This shows essentially the inverse of the animation above — what
does a true circle plotted on the globe look like at various locations on this
map projection?</p>

<figure class="illustration">
  <img src="/images/2023-02-10-mongo-geospatial-queries/7.png" alt="Tissot's indicatrix for equirectangular projection" />
  <figcaption>Tissot's indicatrix for equirectangular projection. Credit: Justin Kunimune, <a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a>, via Wikimedia Commons</figcaption>
</figure>

<p>Now, imagine the inverse operation of this ⤴︎, drawing <em>true</em> circles on this
planar space, in order to get a sense of how distorted your query results on a
globe would be.</p>

<p>Finally, here is Tissot’s indicatrix for the Mercator projection, demonstrating
its ability to preserve shapes at the expense of sizes.</p>

<figure class="illustration">
  <img src="/images/2023-02-10-mongo-geospatial-queries/8.png" alt="Tissot's indicatrix for Mercator projection" />
  <figcaption>Tissot's indicatrix for Mercator projection. Credit: Eric Gaba, <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a>, via Wikimedia Commons</figcaption>
</figure>

<p>An interesting recent development is that the web’s reliance on Mercator is
changing, but only very slowly.
<a href="https://www.theverge.com/2018/8/5/17653122/google-maps-update-mercator-projection-earth-isnt-flat">Google began to make this change</a>
a few years ago, and
<a href="https://www.mapbox.com/blog/adaptive-projections">Mapbox has written about their approach</a>
as well.</p>

<p>Hopefully this digression into the display of geospatial data has been
illuminating. There is much more to say on this topic, since geospatial is more
or less one asterisk after another. For example, we haven’t mentioned that the
Mercator projection above is incapable of depicting the north or south poles at
all! Nor have we touched on MongoDB’s various geospatial
<a href="https://www.mongodb.com/docs/manual/geospatial-queries/#geospatial-data">data formats</a>,
<a href="https://www.mongodb.com/docs/manual/geospatial-queries/#geospatial-indexes">indexes</a>,
or
<a href="https://www.mongodb.com/docs/manual/reference/operator/query/near/">the $near query</a>
and its spherical sibling
<a href="https://www.mongodb.com/docs/manual/reference/operator/query/nearSphere/">the $nearSphere query</a>,
all worthy topics.</p>

<p>But we hope that understanding this crucial distinction between planar
(<code class="language-plaintext highlighter-rouge">$center</code>) and spherical (<code class="language-plaintext highlighter-rouge">$centerSphere</code>) calculations will help you make the
right choice when devising your own radius queries with MongoDB or other
geospatial engines.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Building an English Auction with MongoDB]]></title>
    <link href="https://artsy.github.io/blog/2014/04/17/building-an-english-auction-with-mongodb/"/>
    <updated>2014-04-17T12:21:00+00:00</updated>
    <id>https://artsy.github.io/blog/2014/04/17/building-an-english-auction-with-mongodb</id>
    <content type="html"><![CDATA[<p>Artsy ran several successful auctions over the past few months. The first, <a href="https://artsy.net/feature/two-x-two">TWO x TWO</a>, raised hundreds of thousands of dollars for amfAR (the AIDS Research foundation), and the Dallas Museum of Art. It was followed by <a href="https://artsy.net/feature/ici-benefit-auction">Independent Curators International</a>, at which Artsy launched on-site auction projection screens, which displayed competing bids coming in online from places around the world, like Oslo and Santa Monica, in realtime. Users could place bids on the website, via the iPhone app or with one of the Artsy representatives in the room carrying an iPad.  All the auction lots sold, and Artsy helped ICI to raise 50% more than its target revenue goal. Other, recent Artsy auctions include <a href="https://artsy.net/feature/public-art-fund-2014-spring-benefit">Public Art Fund</a> and the <a href="https://artsy.net/feature/brooklyn-artists-ball">Brooklyn Artists Ball</a>, benefitting the Brooklyn Museum.</p>

<p><img src="/images/2014-04-17-implementing-bidding-in-an-english-auction-with-mongodb/ici-live-auction.jpg" alt="ICI Auction: Live" /></p>

<p>The domain of auctions is a fascinating one, and includes everything from buying items on eBay to trading livestock and selling investment products on the stock exchange. For those interested in the large spectrum of auctions I highly recommend <a href="http://www.sci.brooklyn.cuny.edu/~parsons/projects/mech-design/publications/bluffers-final.pdf">Auctions and bidding: A guide for computer
scientists</a> by Simon Parsons (CUNY), Juan A. Rodriguez-Aguilar (CSIC) and Mark Klein (MIT).</p>

<p>At Artsy we implemented a classic English auction with, so called, “book bids”. I spent a fair amount of time visiting engineering teams that have built internet auctions, most of which were transactional systems where taking a position on an item involved starting a transaction, running an auction round and committing the changes. In contrast, we chose to deliver a simpler, eventually consistent system on top of MongoDB, in which all data is immutable and where some level of serialization occurs within a single background process.</p>

<p>In this post we’ll go over some data modeling and examine the auction engine implementation details.</p>

<!-- more -->

<h3 id="data-modeling">Data Modeling</h3>

<p>In the Artsy platform, an <em>Auction</em> is an specialization of a more general concept of a <em>Sale</em>. A sale typically has an opening and a closing date, during which bidding or purchases can occur. We create a relationship between an artwork and a sale, which, in the case of an auction, includes the opening bid amount. We store all money in cents, and assume the currency to be USD, making it easy to extend the system for other currencies in the future.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SaleArtwork</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>

  <span class="n">field</span> <span class="ss">:opening_bid_cents</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Integer</span>

  <span class="n">belongs_to</span> <span class="ss">:artwork</span><span class="p">,</span> <span class="ss">inverse_of: </span><span class="kp">nil</span>
  <span class="n">belongs_to</span> <span class="ss">:sale</span>

  <span class="n">belongs_to</span> <span class="ss">:highest_bid</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"Bid"</span><span class="p">,</span> <span class="ss">inverse_of: </span><span class="kp">nil</span>

  <span class="c1"># Minimum next acceptable bid amount, in cents.</span>
  <span class="k">def</span> <span class="nf">minimum_next_bid_cents</span>
    <span class="k">return</span> <span class="n">opening_bid_cents</span> <span class="k">if</span> <span class="n">highest_bid</span><span class="p">.</span><span class="nf">nil?</span> <span class="o">&amp;&amp;</span> <span class="n">opening_bid_cents</span><span class="p">.</span><span class="nf">present?</span>
    <span class="c1"># calculate using a bid incrementing strategy ...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>A user registers to bid and creates a <em>Bidder</em> record.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Bidder</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>

  <span class="n">belongs_to</span> <span class="ss">:user</span>
  <span class="n">belongs_to</span> <span class="ss">:sale</span>

  <span class="n">has_many</span> <span class="ss">:positions</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s1">'BidderPosition'</span><span class="p">,</span> <span class="ss">inverse_of: :bidder</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This doesn’t just mimic the real world where bidding typically requires registration - the bidder record doesn’t belong to the user and contains essential data to identify an individual that is placing a bid. It also solves a very peculiar problem where a user decides to delete their account mid-auction. Finally, a bidder could eventually delegate bidding to an agent through this model’s permissions.</p>

<p>A bidder doesn’t actually place any bids, but create a <em>Bidder Position</em>, which indicates the highest amount they are willing to pay for a given artwork.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">BidderPosition</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>

  <span class="n">field</span> <span class="ss">:active</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Boolean</span><span class="p">,</span> <span class="ss">default: </span><span class="kp">true</span>
  <span class="n">field</span> <span class="ss">:max_bid_amount_cents</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Integer</span>

  <span class="n">belongs_to</span> <span class="ss">:bidder</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s1">'Bidder'</span><span class="p">,</span> <span class="ss">inverse_of: :positions</span>
  <span class="n">belongs_to</span> <span class="ss">:sale_artwork</span>
  <span class="n">has_many</span> <span class="ss">:bids</span><span class="p">,</span> <span class="ss">inverse_of: :position</span>

  <span class="n">scope</span> <span class="ss">:active</span><span class="p">,</span> <span class="n">where</span><span class="p">(</span><span class="ss">active: </span><span class="kp">true</span><span class="p">).</span><span class="nf">asc</span><span class="p">(</span><span class="ss">:max_bid_amount_cents</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This is called a “book bid” - before technology took over the auctions world buyers delegated an agent to bid on their behalf after giving them a maximum amount they were willing to part with. Bidder positions belong to a bidder and to the artwork-to-sale relationship. They cannot be changed - if a user wants to increase his maximum bid, he simply creates a new bidder position.</p>

<h3 id="bidding-round">Bidding Round</h3>

<p>Every time a bidder position is created, a <em>Bidding Round</em> is queued for the item being bid on. We can parallelize execution of these by artwork, however all bidding rounds for the same artwork are serialized.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">EnglishAuction</span>
  <span class="c1"># Run multiple rounds of bidding for the given lot, to rest. Return number of bids generated.</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">run!</span><span class="p">(</span><span class="n">sale_artwork</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">0</span> <span class="k">unless</span> <span class="n">sale_artwork</span><span class="p">.</span><span class="nf">sale</span> <span class="o">&amp;&amp;</span> <span class="n">sale_artwork</span><span class="p">.</span><span class="nf">sale</span><span class="p">.</span><span class="nf">biddable?</span>

    <span class="n">round</span> <span class="o">=</span> <span class="no">EnglishAuction</span><span class="o">::</span><span class="no">Round</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">sale_artwork</span><span class="p">)</span>
    <span class="n">round</span><span class="p">.</span><span class="nf">run!</span>

    <span class="n">round</span><span class="p">.</span><span class="nf">bids_generated</span><span class="p">.</span><span class="nf">size</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>A bidding round iterates over all active bidder positions in ascending order by dollar value, outbids any bidders below the max bid, and places new bids, as necessary. The entire round algorithm is below.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># A bidding round for an English auction.</span>
<span class="k">class</span> <span class="nc">Round</span>
  <span class="nb">attr_accessor</span> <span class="ss">:bids_generated</span>

  <span class="c1"># @param sale_artwork A relationship between an artwork and a sale.</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">sale_artwork</span><span class="p">)</span>
    <span class="vi">@sale_artwork</span> <span class="o">=</span> <span class="n">sale_artwork</span>
    <span class="vi">@bids_generated</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">end</span>

  <span class="c1"># Run multiple rounds of bidding, to rest.</span>
  <span class="k">def</span> <span class="nf">run!</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">bids</span> <span class="o">=</span> <span class="n">process_more_bids!</span><span class="p">).</span><span class="nf">any?</span> <span class="k">do</span>
      <span class="vi">@bids_generated</span> <span class="o">+=</span> <span class="n">bids</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># Run one round of bidding. Return bids.</span>
  <span class="k">def</span> <span class="nf">process_more_bids!</span>
    <span class="vi">@sale_artwork</span><span class="p">.</span><span class="nf">bidder_positions</span><span class="p">.</span><span class="nf">active</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">bidder_position</span><span class="o">|</span>
      <span class="n">process_bidder_position!</span><span class="p">(</span><span class="n">bidder_position</span><span class="p">)</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">compact</span>
  <span class="k">end</span>

  <span class="c1"># Process a single bid position.</span>
  <span class="c1"># @returns Generated bid, if any.</span>
  <span class="k">def</span> <span class="nf">process_bidder_position!</span><span class="p">(</span><span class="n">bidder_position</span><span class="p">)</span>

    <span class="c1"># ignore if current position is highest</span>
    <span class="k">return</span> <span class="kp">nil</span> <span class="k">if</span> <span class="n">bidder_position</span> <span class="o">==</span> <span class="vi">@sale_artwork</span><span class="p">.</span><span class="nf">highest_bid</span><span class="p">.</span><span class="nf">try</span><span class="p">(</span><span class="ss">:position</span><span class="p">)</span>

    <span class="c1"># ignore if bidder is already highest</span>
    <span class="k">return</span> <span class="kp">nil</span> <span class="k">if</span> <span class="n">bidder_position</span><span class="p">.</span><span class="nf">bidder</span> <span class="o">==</span> <span class="vi">@sale_artwork</span><span class="p">.</span><span class="nf">highest_bid</span><span class="p">.</span><span class="nf">try</span><span class="p">(</span><span class="ss">:position</span><span class="p">).</span><span class="nf">try</span><span class="p">(</span><span class="ss">:bidder</span><span class="p">)</span>

    <span class="c1"># close if below opening bid</span>
    <span class="k">if</span> <span class="n">bidder_position</span><span class="p">.</span><span class="nf">max_bid_amount_cents</span> <span class="o">&lt;</span> <span class="p">(</span><span class="vi">@sale_artwork</span><span class="p">.</span><span class="nf">opening_bid_cents</span> <span class="o">||</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">bidder_position</span><span class="p">.</span><span class="nf">deactivate!</span> <span class="s2">"Bid must be greater than the minimum bid of </span><span class="si">#{</span><span class="vi">@sale_artwork</span><span class="p">.</span><span class="nf">opening_bid_cents</span><span class="si">}</span><span class="s2">."</span>
      <span class="k">return</span> <span class="kp">nil</span>
    <span class="k">end</span>

    <span class="n">amount_cents</span> <span class="o">=</span> <span class="vi">@sale_artwork</span><span class="p">.</span><span class="nf">minimum_next_bid_cents</span> <span class="c1"># opening bid or an increment thereafter</span>

    <span class="k">if</span> <span class="n">bidder_position</span><span class="p">.</span><span class="nf">max_bid_amount_cents</span> <span class="o">&lt;</span> <span class="n">amount_cents</span>
      <span class="n">highest_bid_amount</span> <span class="o">=</span> <span class="vi">@sale_artwork</span><span class="p">.</span><span class="nf">highest_bid</span><span class="p">.</span><span class="nf">try</span><span class="p">(</span><span class="ss">:amount_cents</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span>

      <span class="c1"># if max is between current and increment (or if it's at current, but earlier), bid max anyway</span>
      <span class="c1"># this means that a bidder who placed an identical max bid earlier becomes the highest bidder</span>
      <span class="k">if</span> <span class="n">bidder_position</span><span class="p">.</span><span class="nf">max_bid_amount_cents</span> <span class="o">&gt;</span> <span class="n">highest_bid_amount</span> <span class="o">||</span>
        <span class="p">(</span><span class="n">bidder_position</span><span class="p">.</span><span class="nf">max_bid_amount_cents</span> <span class="o">==</span> <span class="n">highest_bid_amount</span> <span class="o">&amp;&amp;</span> <span class="n">bidder_position</span><span class="p">.</span><span class="nf">id</span> <span class="o">&lt;</span> <span class="vi">@sale_artwork</span><span class="p">.</span><span class="nf">highest_bid</span><span class="p">.</span><span class="nf">position</span><span class="p">.</span><span class="nf">id</span><span class="p">)</span>
        <span class="n">amount_cents</span> <span class="o">=</span> <span class="n">bidder_position</span><span class="p">.</span><span class="nf">max_bid_amount_cents</span>
      <span class="k">else</span>
        <span class="c1"># outbid, next bid must be at least amount_cents</span>
        <span class="n">bidder_position</span><span class="p">.</span><span class="nf">update_attributes!</span> <span class="ss">active: </span><span class="kp">false</span>
        <span class="k">return</span> <span class="kp">nil</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="c1"># place a bid</span>
    <span class="n">bidder_position</span><span class="p">.</span><span class="nf">bids</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="n">attrs</span><span class="p">).</span><span class="nf">tap</span> <span class="k">do</span> <span class="o">|</span><span class="n">bid</span><span class="o">|</span>
      <span class="vi">@sale_artwork</span><span class="p">.</span><span class="nf">update_attributes!</span> <span class="ss">highest_bid: </span><span class="n">bid</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>One of the interesting aspects of this system is what happens when two users create two identical bidder positions - the earlier one wins and the later one is outbid. In a transactional system we could produce an error message to the second bidder before the position is even created.</p>

<h3 id="bidder-notifications">Bidder Notifications</h3>

<p>Notifying upon being “outbid” is straightforward, because a position only enters that state once, but notifying bidders of when they are the current high bidder or when their bid has been increased is trickier. We don’t want to generate notifications every time a bid is made (i.e., it’s the current high). Rather, we want to allow the round to reach a stable state at which there’s only a single active position and then notify the current high and outbid bidders. This happens after each <code class="language-plaintext highlighter-rouge">round.run!</code>.</p>

<h3 id="beyond-bidding">Beyond Bidding</h3>

<p>Aside of the bidding implementation we’ve built a whole software ecosystem around auctions. We developed a backend system to manage these. We put up projection screens at the event that list works being auctioned and flash every time a bid is placed. We register users’ credit cards and collect their money.</p>

<p>The software part, however, is definitely dwarfed by the amount of logistics and people involved in making one of those auctions a success. We’re only trying to make that a bit more efficient. We’ll see you at the upcoming BAM Art Auction, SFMOMA Modern Ball or the Whitney Museum Art Party!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Upgrading to Mongoid 4.x]]></title>
    <link href="https://artsy.github.io/blog/2013/11/07/upgrading-to-mongoid4/"/>
    <updated>2013-11-07T12:34:00+00:00</updated>
    <id>https://artsy.github.io/blog/2013/11/07/upgrading-to-mongoid4</id>
    <content type="html"><![CDATA[<p>I recently went through an exercise of upgrading one of Artsy’s largest web projects to the current HEAD of Mongoid 4.x. This is going to be a major release with numerous changes and I wanted to flush out bugs before the final version of the ODM is released. All Mongoid changes currently live on <a href="https://github.com/mongoid/mongoid">master</a>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gem</span> <span class="s1">'mongoid'</span><span class="p">,</span> <span class="ss">github: </span><span class="s1">'mongoid/mongoid'</span>
</code></pre></div></div>

<p>In the process I’ve worked on making a few gems compatible with Mongoid 4 and learned a couple of things that should help you make this process smooth for your own applications.</p>

<!-- more -->

<h2 id="mopedbsonobjectid">Moped::BSON::ObjectId</h2>

<p>Moped’s BSON implementation has been removed in favor of the MongoDB bson gem 2.0 and higher. All <code class="language-plaintext highlighter-rouge">Moped::BSON</code> references must change to <code class="language-plaintext highlighter-rouge">BSON</code>. This is rather annoying and forces many libraries to have to fork behavior at runtime.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Mongoid</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">mongoid3?</span>
    <span class="o">::</span><span class="no">Mongoid</span><span class="p">.</span><span class="nf">const_defined?</span> <span class="ss">:Observer</span> <span class="c1"># deprecated in Mongoid 4.x</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">mongoid2?</span>
    <span class="o">::</span><span class="no">Mongoid</span><span class="p">.</span><span class="nf">const_defined?</span> <span class="ss">:Contexts</span> <span class="c1"># deprecated in Mongoid 3.x</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">mongoid2?</code> implementation is borrowed from <a href="https://github.com/pyromaniac/mongoid_orderable">mongoid_orderable</a> and I wrote the <code class="language-plaintext highlighter-rouge">mongoid3?</code> version by parsing the CHANGELOG - observers are deprecated in 4.0.</p>

<p>Now, instead of calling <code class="language-plaintext highlighter-rouge">Moped::BSON::ObjectId.legal?(id)</code>, you have to do something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="no">Mongoid</span><span class="p">.</span><span class="nf">mongoid3?</span>
  <span class="no">Moped</span><span class="o">::</span><span class="no">BSON</span><span class="o">::</span><span class="no">ObjectId</span><span class="p">.</span><span class="nf">legal?</span> <span class="nb">id</span>
<span class="k">else</span>
  <span class="no">BSON</span><span class="o">::</span><span class="no">ObjectId</span><span class="p">.</span><span class="nf">legal?</span> <span class="nb">id</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Furthermore, you can no longer convert a string into a <code class="language-plaintext highlighter-rouge">Moped::BSON::ObjectId(id)</code>, you must explicitly call <code class="language-plaintext highlighter-rouge">from_string</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="no">Mongoid</span><span class="p">.</span><span class="nf">mongoid3?</span>
  <span class="no">Moped</span><span class="o">::</span><span class="no">BSON</span><span class="o">::</span><span class="no">ObjectId</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
<span class="k">else</span>
  <span class="no">BSON</span><span class="o">::</span><span class="no">ObjectId</span><span class="p">.</span><span class="nf">from_string</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Libraries should then adjust their dependencies on Mongoid and specify <code class="language-plaintext highlighter-rouge">&gt;= 3.0</code>, and maybe <code class="language-plaintext highlighter-rouge">&lt; 5.0</code>.</p>

<h2 id="testing-against-multiple-mongoid-versions">Testing Against Multiple Mongoid Versions</h2>

<p>The <a href="https://github.com/pyromaniac/mongoid_orderable">mongoid-orderable</a> gem has a neat system for testing against all versions of Mongoid with <a href="https://travis-ci.org/">Travis CI</a>. First, the <em>.travis.yml</em> file declares a test matrix that sets <code class="language-plaintext highlighter-rouge">MONGOID_VERSION</code>. Note that Mongoid 3.x or newer doesn’t run with Ruby 1.8.x or 1.9.2.</p>

<p>```ruby .travis.yml
rvm:</p>
<ul>
  <li>1.8.7</li>
  <li>1.9.2</li>
  <li>1.9.3</li>
  <li>ruby-head</li>
</ul>

<p>env:</p>
<ul>
  <li>MONGOID_VERSION=2</li>
  <li>MONGOID_VERSION=3</li>
  <li>MONGOID_VERSION=4</li>
</ul>

<p>matrix:
  exclude:
    - rvm: 1.8.7
      env: MONGOID_VERSION=3
    - rvm: 1.8.7
      env: MONGOID_VERSION=4
    - rvm: 1.9.2
      env: MONGOID_VERSION=3
    - rvm: 1.9.2
      env: MONGOID_VERSION=4</p>

<p>services: mongodb</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
The library's *Gemfile* locks a different version depending on the environment variable, defaulting to 3.x. You can also test against a very specific version, if you must.

```ruby Gemfile
source "http://rubygems.org"

gemspec

case version = ENV['MONGOID_VERSION'] || "~&gt; 3.1"
when /4/
  gem "mongoid", :github =&gt; 'mongoid/mongoid'
when /3/
  gem "mongoid", "~&gt; 3.1"
when /2/
  gem "mongoid", "~&gt; 2.8"
else
  gem "mongoid", version
end
</code></pre></div></div>

<h2 id="upgraded-gems">Upgraded Gems</h2>

<p>I used the above method to make a few gems Mongoid 4.x compatible, via the following pull requests.</p>

<ul>
  <li><a href="https://github.com/digitalplaywright/mongoid-slug/pull/146">mongoid-slug</a></li>
  <li><a href="https://github.com/dblock/mongoid-scroll/commit/b67e2867b133cd6bd1b8361ea51409f80ae91ffd">mongoid-scroll</a></li>
  <li><a href="https://github.com/pyromaniac/mongoid_orderable/pull/18">mongoid_orderable</a></li>
  <li><a href="https://github.com/aq1018/mongoid-history/pull/83">mongoid-history</a></li>
  <li><a href="https://github.com/aaw/mongoid_collection_snapshot/pull/5">mongoid_collection_snapshot</a></li>
  <li><a href="https://github.com/joeyAghion/delayed_job_shallow_mongoid/pull/6">delayed_job_shallow_mongoid</a></li>
</ul>

<h2 id="upgrading-a-rails-project">Upgrading a Rails Project</h2>

<p>If you’re using Rails, you’re in for upgrading both Mongoid 4.x and Rails to 4.x. This means you will suffer a lot of pain trying to find compatible versions of various interdependent gems. I suggest locking Rails, Mongoid and ActiveSupport to begin with.</p>

<p>``` ruby Gemfile
gem ‘rails’, ‘4.0.1’
gem ‘activesupport’, ‘4.0.1’
gem ‘mongoid’, github: ‘mongoid/mongoid’</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Bulk search &amp; replace `Moped::BSON::ObjectId` references.

Calls to `inc`, `set` and `add_to_set` now take hashes, eg. `artist.inc(likes_count: 1)`.

If you're converting Mongoid objects to JSON and seeing data such as `{ "$oid" =&gt; "..." }` instead of an ID, monkey-patch `BSON::ObjectId.as_json`. See [this discussion thread](https://groups.google.com/forum/#!msg/mongoid/MaXFVw7D_4s/T3sl6Flg428J).

``` ruby config/initializers/bson/object_id.rb
module BSON
  class ObjectId
    def as_json(options = {})
      to_s
    end
  end
end
</code></pre></div></div>

<p>If you’re using Warden (including via Devise) and/or rely on session cookies that may contain a user ID, add an implementation for the deprecated <code class="language-plaintext highlighter-rouge">Moped::BSON::Document</code>. This will prevent all old cookies from causing a serialization error and logging all those users out.</p>

<p>``` ruby config/initializers/bson/
module Moped
  module BSON
    ObjectId = ::BSON::ObjectId</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Document &lt; Hash
  class &lt;&lt; self
    def deserialize(io, document = new)
      __bson_load__(io, document)
    end

    def serialize(document, io = "")
      document.__bson_dump__(io)
    end
  end
end   end end ```
</code></pre></div></div>

<h2 id="updates">Updates</h2>

<p>Please post your updates below and questions to the <a href="https://groups.google.com/forum/#!forum/mongoid">mongoid mailing list</a>. I’ll update this post up until Mongoid 4.x ships.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Infinite Scroll with MongoDB]]></title>
    <link href="https://artsy.github.io/blog/2013/02/15/infinite-scroll-with-mongodb/"/>
    <updated>2013-02-15T21:21:00+00:00</updated>
    <id>https://artsy.github.io/blog/2013/02/15/infinite-scroll-with-mongodb</id>
    <content type="html"><![CDATA[<p>An infinite scroll can be a beautiful and functional way to present feed data. You can see ours on the <a href="https://artsy.net/">homepage of artsy.net</a>. It works by fetching a few items from the API, then fetching some more items as the user scrolls down the feed. Each API call returns the items along with a “cursor”, which marks the position of the last item retrieved. Subsequent API calls include the cursor in the query string and the iteration resumes from there.</p>

<p>Why use a cursor and not standard pagination? Because inserting an item on top of the feed would shift the existing items down, causing the API to return a duplicate item on the page boundary. Removing an item from the top of the feed would pull the remaining items up, causing an item to be missed in the next request on the page boundary.</p>

<p>Today we’re open-sourcing a small gem called <a href="https://github.com/dblock/mongoid-scroll">mongoid-scroll</a>, which implements this cursor-like behavior for MongoDB using mongoid or moped. Here’s how it works.</p>

<!-- more -->

<h2 id="example">Example</h2>

<p>Define a sample <code class="language-plaintext highlighter-rouge">FeedItem</code> model with an index on <code class="language-plaintext highlighter-rouge">position</code>. We’ll be iterating over our feed, starting with the newest item first.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">Feed</span>
  <span class="k">class</span> <span class="nc">Item</span>
    <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
    <span class="n">field</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span>
    <span class="n">field</span> <span class="ss">:position</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Integer</span>
    <span class="n">index</span><span class="p">({</span> <span class="ss">position: </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="ss">_id: </span><span class="mi">1</span> <span class="p">})</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Insert some sample unordered data manufactured with <a href="https://github.com/stympy/faker">faker</a>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">total_items</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">rands</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">total_items</span><span class="p">).</span><span class="nf">to_a</span><span class="p">.</span><span class="nf">sort</span> <span class="p">{</span> <span class="nb">rand</span> <span class="p">}[</span><span class="mi">0</span><span class="o">..</span><span class="n">total_items</span><span class="p">]</span>
<span class="n">total_items</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
  <span class="no">Feed</span><span class="o">::</span><span class="no">Item</span><span class="p">.</span><span class="nf">create!</span> <span class="ss">title: </span><span class="no">Faker</span><span class="o">::</span><span class="no">Lorem</span><span class="p">.</span><span class="nf">sentence</span><span class="p">,</span> <span class="ss">position: </span><span class="n">rands</span><span class="p">.</span><span class="nf">pop</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Iterate over this collection using a cursor, 7 items at a time.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">next_cursor</span> <span class="o">=</span> <span class="kp">nil</span>
<span class="k">while</span> <span class="kp">true</span>
  <span class="n">current_cursor</span> <span class="o">=</span> <span class="n">next_cursor</span>
  <span class="n">next_cursor</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="no">Feed</span><span class="o">::</span><span class="no">Item</span><span class="p">.</span><span class="nf">desc</span><span class="p">(</span><span class="ss">:position</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">7</span><span class="p">).</span><span class="nf">scroll</span><span class="p">(</span><span class="n">current_cursor</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="p">,</span> <span class="n">cursor</span><span class="o">|</span>
    <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="n">item</span><span class="p">.</span><span class="nf">position</span><span class="si">}</span><span class="s2">: </span><span class="si">#{</span><span class="n">item</span><span class="p">.</span><span class="nf">title</span><span class="si">}</span><span class="s2">"</span>
    <span class="n">next_cursor</span> <span class="o">=</span> <span class="n">cursor</span>
  <span class="k">end</span>
  <span class="k">break</span> <span class="k">unless</span> <span class="n">next_cursor</span>
  <span class="c1"># destroy an item, the scroll is not affected</span>
  <span class="no">Feed</span><span class="o">::</span><span class="no">Item</span><span class="p">.</span><span class="nf">desc</span><span class="p">(</span><span class="ss">:position</span><span class="p">).</span><span class="nf">first</span><span class="p">.</span><span class="nf">destroy</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The result is, as expected, all 20 items in reverse order.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>20: Quae eveniet est a.
19: Ab voluptatem aut possimus.
18: Tenetur voluptatem aut modi eos et fugiat ipsa impedit.
17: Autem enim qui illum ut sed et et pariatur.
16: Est molestias quidem adipisci culpa non.
15: Incidunt ad atque minus fuga illum ex earum.
14: Ullam et cum harum tempore nostrum consequatur.
13: Porro nostrum laboriosam aperiam blanditiis est.
12: Facere non a vel est sapiente sit officiis.
11: Itaque commodi deserunt aut exercitationem aut voluptatem.
10: Veritatis mollitia libero hic velit quos.
9: Iste ea dicta ut culpa.
8: Voluptatibus vel et minima.
7: Possimus molestiae quis consectetur iusto sed.
6: Aut fugit omnis incidunt.
5: Recusandae corrupti est in dolor est commodi aut.
4: Tenetur veniam ut id.
3: Voluptas exercitationem eos quia rem quia quas qui quae.
2: Eveniet repellendus corrupti molestiae molestias qui ullam.
1: Sapiente impedit iste quos eligendi cupiditate accusantium ad.
</code></pre></div></div>

<p>We’ve used 4 queries to iterate over this collection.</p>

<h2 id="first-query">First Query</h2>

<p>The first ordered query without an existing cursor uses a <code class="language-plaintext highlighter-rouge">limit</code>.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">feed_items</span><span class="p">.</span><span class="nx">find</span><span class="p">().</span><span class="nx">sort</span><span class="p">({</span> <span class="na">position</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="na">_id</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">}).</span><span class="nx">limit</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</code></pre></div></div>

<p>The last item returned has a position of 14 (we scrolled from 20 down to 14, including the boundaries).</p>

<h2 id="second-and-third-query">Second and Third Query</h2>

<p>The second ordered query has to fetch any item that comes after 14, including any other item that has the same position further in the same direction as the MongoDB order (there’re no duplicates in our example, but it’s entirely possible).</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">db</span><span class="p">.</span><span class="nx">feed_items</span><span class="p">.</span><span class="nx">find</span><span class="p">({</span> <span class="dl">"</span><span class="s2">$or</span><span class="dl">"</span> <span class="p">:</span> <span class="p">[</span>
 <span class="p">{</span> <span class="dl">"</span><span class="s2">position</span><span class="dl">"</span> <span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">$lt</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">14</span> <span class="p">}},</span>
 <span class="p">{</span> <span class="dl">"</span><span class="s2">position</span><span class="dl">"</span> <span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="dl">"</span><span class="s2">_id</span><span class="dl">"</span><span class="p">:</span> <span class="p">{</span> <span class="dl">"</span><span class="s2">$lt</span><span class="dl">"</span> <span class="p">:</span> <span class="nx">ObjectId</span><span class="p">(</span><span class="dl">"</span><span class="s2">511d7c7c3b5552c92400000e</span><span class="dl">"</span><span class="p">)</span> <span class="p">}}</span>
<span class="p">]}).</span><span class="nx">sort</span><span class="p">({</span> <span class="na">position</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="na">_id</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">}).</span><span class="nx">limit</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</code></pre></div></div>

<p>Note that we’re sorting by <code class="language-plaintext highlighter-rouge">_id</code> as well because MongoDB may relocate a document and therefore alter the natural order. See <a href="https://github.com/dblock/mongoid-scroll/commit/3cd75ded93f82adfcb1c17a8b9c98715c536b680">this commit</a> for a test that reproduces this behavior.</p>

<h2 id="last-query">Last Query</h2>
<p>We’ve chosen to break out of the loop after getting no data back in the 4th iteration. You can check whether the item retrieved is the last one in the collection as an alternative to prevent this fourth empty database query.</p>

<h2 id="cursors">Cursors</h2>

<p>Cursors consist of the item’s position and the item’s BSON id. The cursor for the item at position 14 is <code class="language-plaintext highlighter-rouge">14:511d7c7c3b5552c92400000e</code>. This cursor is parsed to construct the query on subsequent requests or can be supplied as a <code class="language-plaintext highlighter-rouge">Mongoid::Scroll::Cursor</code> object.</p>

<h2 id="links">Links</h2>

<ul>
  <li><a href="https://github.com/dblock/mongoid-scroll">mongoid-scroll on Github</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Data Corruption and Concurrent Updates to Embedded Objects with MongoDB]]></title>
    <link href="https://artsy.github.io/blog/2013/02/09/data-corruption-and-concurrent-updates-to-embedded-objects-with-mongoid/"/>
    <updated>2013-02-09T21:21:00+00:00</updated>
    <id>https://artsy.github.io/blog/2013/02/09/data-corruption-and-concurrent-updates-to-embedded-objects-with-mongoid</id>
    <content type="html"><![CDATA[<p>We use <a href="http://www.mongodb.org/">MongoDB</a> at Artsy as our primary data store via the <a href="http://mongoid.org/">Mongoid ODM</a>. Eventually, we started noticing data corruption inside embedded objects at an alarming rate of 2-3 records a day. The number of occurrences increased rapidly with load as our user growth accelerated.</p>

<p>The root cause was not a HN-worthy sensational declaration about how MongoDB trashes data, but our lack of understanding of what can and cannot be concurrently written to the database, neatly hidden behind the object data mapping layer.</p>

<!-- more -->

<h3 id="data-model">Data Model</h3>

<p>Consider the following artwork model with embedded images.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Artwork</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
  <span class="n">field</span> <span class="ss">:title</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span>
  <span class="n">embeds_many</span> <span class="ss">:images</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Image</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
  <span class="n">embedded_in</span> <span class="ss">:artwork</span>
  <span class="n">field</span> <span class="ss">:filename</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span>
  <span class="n">field</span> <span class="ss">:width</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Integer</span>  
  <span class="n">field</span> <span class="ss">:height</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Integer</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Let’s create a few objects and examine the database queries executed when constructing this relationship by setting a <code class="language-plaintext highlighter-rouge">DEBUG</code> logger level on the Moped driver used underneath the ODM.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Moped</span><span class="p">.</span><span class="nf">logger</span> <span class="o">=</span> <span class="no">Logger</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="vg">$stdout</span><span class="p">)</span>
<span class="no">Moped</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">level</span> <span class="o">=</span> <span class="no">Logger</span><span class="o">::</span><span class="no">DEBUG</span>

<span class="c1"># db.artworks.insert({</span>
<span class="c1">#   _id: ObjectId("510f22c5db8e540aab000001"),</span>
<span class="c1">#   title: "Mona Lisa"</span>
<span class="c1"># })</span>
<span class="n">artwork</span> <span class="o">=</span> <span class="no">Artwork</span><span class="p">.</span><span class="nf">create!</span><span class="p">(</span><span class="ss">title: </span><span class="s2">"Mona Lisa"</span><span class="p">)</span>

<span class="n">image1</span> <span class="o">=</span> <span class="no">Image</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">filename: </span><span class="s2">"framed.jpg"</span><span class="p">)</span>

<span class="c1"># db.artworks.update(</span>
<span class="c1">#   { _id: ObjectId("510f22c5db8e540aab000001") },</span>
<span class="c1">#   { $push :</span>
<span class="c1">#     { images:</span>
<span class="c1">#       {</span>
<span class="c1">#         _id: ObjectId("510f22c5db8e540aab000002"),</span>
<span class="c1">#         filename: "framed.jpg"</span>
<span class="c1">#       }</span>
<span class="c1">#     }</span>
<span class="c1">#   }</span>
<span class="c1"># )</span>
<span class="n">artwork</span><span class="p">.</span><span class="nf">images</span> <span class="o">&lt;&lt;</span> <span class="n">image1</span>

<span class="n">image2</span> <span class="o">=</span> <span class="no">Image</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">filename: </span><span class="s2">"unframed.jpg"</span><span class="p">)</span>
<span class="c1"># db.artworks.update(</span>
<span class="c1">#   { _id: ObjectId("510f22c5db8e540aab000001") },</span>
<span class="c1">#   { $push :</span>
<span class="c1">#     { images:</span>
<span class="c1">#       {</span>
<span class="c1">#         _id: ObjectId("510f22c5db8e540aab000003"),</span>
<span class="c1">#         filename: "unframed.jpg"</span>
<span class="c1">#       }</span>
<span class="c1">#     }</span>
<span class="c1">#   }</span>
<span class="c1"># )</span>
<span class="n">artwork</span><span class="p">.</span><span class="nf">images</span> <span class="o">&lt;&lt;</span> <span class="n">image2</span>
</code></pre></div></div>

<p>Here’s the artwork data in MongoDB retrieved from a <code class="language-plaintext highlighter-rouge">mongo</code> shell:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.artworks.findOne()
{
  "_id" : ObjectId("510f22c5db8e540aab000001"),
  "title" : "Mona Lisa",
  "images" : [
    {
      "_id" : ObjectId("510f22c5db8e540aab000002"),
      "filename" : "framed.jpg"
    },
    {
      "_id" : ObjectId("510f22c5db8e540aab000003"),
      "filename" : "unframed.jpg"
    }
  ]
}
</code></pre></div></div>

<p>We can modify the attributes of the second image.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># db.artworks.update(</span>
<span class="c1">#   { _id: ObjectId("510f22c5db8e540aab000001") },</span>
<span class="c1">#   { $set : { "images.1.width" : 30, "images.1.height" : 40 } }</span>
<span class="c1"># )</span>
<span class="n">image2</span><span class="p">.</span><span class="nf">update_attributes!</span><span class="p">(</span><span class="ss">width: </span><span class="mi">30</span><span class="p">,</span> <span class="ss">height: </span><span class="mi">40</span><span class="p">)</span>
</code></pre></div></div>

<p>The image has been updated correctly.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.artworks.findOne()
{
  "_id" : ObjectId("510f22c5db8e540aab000001"),
  "title" : "Mona Lisa",
  "images" : [
    {
      "_id" : ObjectId("510f22c5db8e540aab000002"),
      "filename" : "framed.jpg"
    },
    {
      "_id" : ObjectId("510f22c5db8e540aab000003"),
      "filename" : "unframed.jpg",
      "height" : 40,
      "width" : 30
    }
  ]
}
</code></pre></div></div>

<h3 id="incomplete-record-corruption">Incomplete Record Corruption</h3>

<p>Examining the query you will notice that it uses a so-called “positional” operator, <code class="language-plaintext highlighter-rouge">images.1.width</code> to update the second record. Imagine what would happen if the first record was deleted from another process immediately before the update. That’s right, the update will be performed on a record that doesn’t exist, in which case the default MongoDB behavior is to create it!</p>

<p>We can simulate this by loading the object in Ruby, pulling the first record directly from the database and then performing the update.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">artwork</span><span class="p">.</span><span class="nf">images</span> <span class="o">&lt;&lt;</span> <span class="n">image2</span>

<span class="c1"># pull the first artwork directly from the database</span>
<span class="no">Artwork</span><span class="p">.</span><span class="nf">collection</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">_id: </span><span class="n">artwork</span><span class="p">.</span><span class="nf">id</span><span class="p">).</span><span class="nf">update</span><span class="p">(</span>
  <span class="s2">"$pull"</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="s2">"images"</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">_id: </span><span class="n">image1</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span> <span class="p">})</span>

<span class="n">image2</span><span class="p">.</span><span class="nf">update_attributes!</span><span class="p">(</span><span class="ss">width: </span><span class="mi">30</span><span class="p">,</span> <span class="ss">height: </span><span class="mi">40</span><span class="p">)</span>
</code></pre></div></div>

<p>This yields a nasty surprise. We now have two records in the embedded collection, the second one missing an <code class="language-plaintext highlighter-rouge">_id</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.artworks.findOne()
{
  "_id" : ObjectId("510f22c5db8e540aab000001"),
  "title" : "Mona Lisa",
  "images" : [
    {
      "_id" : ObjectId("510f22c5db8e540aab000003"),
      "filename" : "unframed.jpg"
    },
    {
      "height" : 40,
      "width" : 30
    }
  ]
}
</code></pre></div></div>

<p>When reloaded, Mongoid will assign an automatic <code class="language-plaintext highlighter-rouge">_id</code> to the second object, the correct height and width, but no filename.</p>

<h3 id="null-record-corruption">Null Record Corruption</h3>

<p>A similar scenario can play out by pulling both image records out of the embedded collection and making a positional update. This will create a <code class="language-plaintext highlighter-rouge">null</code> record, which is much worse, because Mongoid can’t even destroy it, attempting to pull a record with an <code class="language-plaintext highlighter-rouge">_id</code> that does not exist.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">artwork</span><span class="p">.</span><span class="nf">images</span> <span class="o">&lt;&lt;</span> <span class="n">image2</span>

<span class="no">Artwork</span><span class="p">.</span><span class="nf">collection</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">_id: </span><span class="n">artwork</span><span class="p">.</span><span class="nf">id</span><span class="p">).</span><span class="nf">update</span><span class="p">(</span>
  <span class="s2">"$pull"</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="s2">"images"</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">_id: </span><span class="n">image1</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span> <span class="p">})</span>
<span class="no">Artwork</span><span class="p">.</span><span class="nf">collection</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">_id: </span><span class="n">artwork</span><span class="p">.</span><span class="nf">id</span><span class="p">).</span><span class="nf">update</span><span class="p">(</span>
  <span class="s2">"$pull"</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="s2">"images"</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="ss">_id: </span><span class="n">image2</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span> <span class="p">})</span>

<span class="n">image2</span><span class="p">.</span><span class="nf">update_attributes!</span><span class="p">(</span><span class="ss">width: </span><span class="mi">30</span><span class="p">,</span> <span class="ss">height: </span><span class="mi">40</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; db.artworks.findOne()
{
  "_id" : ObjectId("510f22c5db8e540aab000001"),
  "title" : "Mona Lisa"
  "images" : [
    null,
    {
      "height" : 40,
      "width" : 30
    }
  ],
}
</code></pre></div></div>

<h3 id="solutions">Solutions</h3>

<p>A first obvious solution is not to use embedded objects or to never modify them. Both <code class="language-plaintext highlighter-rouge">$push</code> and <code class="language-plaintext highlighter-rouge">$pull</code> are atomic operations, but not the positional update.</p>

<p>A general solution to this problem is to make all update operations transactional. You can take a lock on the parent model by using <a href="https://github.com/afeld/mongoid-locker">mongoid-locker</a>. It works, but can be quite tedious depending on the complexity of your application.</p>

<p>Finally, MongoDB supports something called a “positional operator” for embedded objects. This means you can atomically update a record found by its embedded object’s field using a reference to the position of that embedded object. This solves our problem, as long as the object is not embedded below the first level. Mongoid 3.1 (currently HEAD) implements this behavior by default (see <a href="https://github.com/mongoid/mongoid/issues/2545">#2545</a> for details), adjusting the selector to look for the embedded object’s <code class="language-plaintext highlighter-rouge">_id</code> and replacing the position with a <code class="language-plaintext highlighter-rouge">$</code> positional operator.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># db.artworks.update(</span>
<span class="c1">#   {</span>
<span class="c1">#     _id: ObjectId("510f22c5db8e540aab000001"),</span>
<span class="c1">#     "images._id" : ObjectId("510f22c5db8e540aab000003")</span>
<span class="c1">#   },</span>
<span class="c1">#   { $set : { "images.$.width" : 30, "images.$.height" : 40 }}</span>
<span class="c1"># )</span>
<span class="n">image2</span><span class="p">.</span><span class="nf">update_attributes!</span><span class="p">(</span><span class="ss">width: </span><span class="mi">30</span><span class="p">,</span> <span class="ss">height: </span><span class="mi">40</span><span class="p">)</span>
</code></pre></div></div>

<p>We’ve been successfully running this in production for a few weeks now, without any more data corruption issues.</p>

<p>While this is a huge step forward, covering all of our application’s scenarios, we would like complete native support for atomic updates inside MongoDB at all levels of nesting. Please add your +1 to <a href="https://jira.mongodb.org/browse/SERVER-831">SERVER-831</a>.</p>

<h3 id="links">Links</h3>

<ul>
  <li><a href="https://gist.github.com/dblock/4699070">Code to Detect Corrupt Embedded Objects</a></li>
  <li><a href="https://jira.mongodb.org/browse/SERVER-831">MongoDB SERVER-831: Positional Operator Matching Nested Arrays</a></li>
  <li><a href="https://github.com/mongoid/mongoid/issues/2545">Mongoid #2545: Use $ Positional Operator for Updating Embedded Documents</a></li>
  <li><a href="https://github.com/dblock/mongoid/tree/master-issues/spec/dblock">Repro Specs for Mongoid #2545 and Similar</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
