<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Caching | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/caching/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2024-05-17T14:49:02+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Improving Performance of Mongoid-Cached-Json]]></title>
    <link href="https://artsy.github.io/blog/2013/01/20/improving-performance-of-mongoid-cached-json/"/>
    <updated>2013-01-20T21:21:00+00:00</updated>
    <id>https://artsy.github.io/blog/2013/01/20/improving-performance-of-mongoid-cached-json</id>
    <content type="html"><![CDATA[<p>Last year, we have open-sourced and made extensive use of two Ruby libraries in our API: <a href="https://github.com/dblock/mongoid-cached-json">mongoid-cached-json</a> and <a href="https://github.com/artsy/garner">garner</a>. Both transform the procedural nightmare of caching and JSON generation into a declarative and easily manageable DSL. It was worth the investment, since our service spends half of its time generating JSON and reading from and writing to Memcached.</p>

<p>Today we’ve released mongoid-cached-json 1.4 with two interesting performance improvements.</p>

<!-- more -->

<h2 id="bulk-reference-resolving-with-a-local-cache">Bulk Reference Resolving with a Local Cache</h2>

<p>Consider an array of database model instances, each with numerous references to other objects. It’s typical to see such instances reference the same object: for example we have an <code class="language-plaintext highlighter-rouge">Artwork</code> that references an <code class="language-plaintext highlighter-rouge">Artist</code>. It’s common to see multiple artworks reference the same artist in a collection. Retrieving the artist from cache every time it is referenced is clearly inefficient.</p>

<p><code class="language-plaintext highlighter-rouge">Mongoid::CachedJson</code> will now collect all JSON references, then resolve them after suppressing duplicates, in-place within the JSON tree. This significantly reduces the number of cache queries.</p>

<p>Note, that while this optimization reduces load on the Memcached servers, there’s a cost of doing additional work after collecting the entire JSON in Ruby.</p>

<h2 id="fetching-cache-data-in-bulk">Fetching Cache Data in Bulk</h2>

<p>Various cache stores, including Memcached, support bulk read operations. The <a href="https://github.com/mperham/dalli">Dalli</a> gem, which we use in production, exposes this via the <code class="language-plaintext highlighter-rouge">read_multi</code> method. With the bulk reference optimization above we now have the entire list of keys to query from cache, at once. <code class="language-plaintext highlighter-rouge">Mongoid::CachedJson</code> will always invoke <code class="language-plaintext highlighter-rouge">read_multi</code> where available, which significantly reduces the number of network roundtrips to the cache servers.</p>

<p>This is a good example of where declarative models and DSLs have tremendous advantages in enabling massive improvements across the board. Imagine making the <code class="language-plaintext highlighter-rouge">read_multi</code> optimization in hundreds of API endpoints!</p>

<h2 id="benchmarks">Benchmarks</h2>

<p>With the above optimizations the library does more work in order to make less roundtrips to Memcached over the network. Since the network is often the slowest part in any large scale system, the overall production performance should be better as long as we can obtain similar throughput in ideal network conditions on localhost. We’ve added some common case benchmarks in <a href="https://github.com/dblock/mongoid-cached-json/blob/master/spec/benchmark_spec.rb">spec/benchmark_spec.rb</a> and ran them against 1.2.3 and 1.4.0 to obtain <a href="https://gist.github.com/4583039">these results</a>. The overall performance gain averaged 14.6%, which is quite significant. With real world data in a production environment we’re seeing 15-50% less time spent in Memcached, depending on the API.</p>

<h2 id="links">Links</h2>

<p>The concepts behind these improvements should be attributed to <a href="https://github.com/aaw">@aaw</a> and <a href="https://github.com/macreery">@macreery</a>. If you want to learn more about the above-mentioned libraries, check out the following links:</p>

<ul>
  <li><a href="http://confreaks.com/videos/986-goruco2012-from-zero-to-api-cache-w-grape-mongodb-in-10-minutes">From Zero to API-Cache w/ Grape and MongoDB</a>, video recorded at GoRuCo</li>
  <li><a href="/blog/2012/02/20/caching-model-json-with-mongoid-cached-json/">Caching Model JSON with Mongoid-Cached-Json</a></li>
  <li><a href="/blog/2012/03/23/simplifying-model-level-json-versioning-with-mongoid-cached-json/">Simplifying Model Level Versioning with Mongoid-Cched-Json</a></li>
  <li><a href="/blog/2012/05/30/restful-api-caching-with-garner/">RESTful API Caching with Garner</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RESTful API Caching with Garner]]></title>
    <link href="https://artsy.github.io/blog/2012/05/30/restful-api-caching-with-garner/"/>
    <updated>2012-05-30T21:21:00+00:00</updated>
    <id>https://artsy.github.io/blog/2012/05/30/restful-api-caching-with-garner</id>
    <content type="html"><![CDATA[<p>Implementing server-side RESTful API caching is hard. In a straightforward API all the expiry decisions can be made automatically based on the URL, but most real world APIs that add requirements around object relationships or user authorization make caching particularly challenging.</p>

<p>At <a href="http://goruco.com/">GoRuCo</a> we open-sourced <a href="http://github.com/artsy/garner">Garner</a>, a cache implementation of the concepts described in this post. To “garner” means to gather data from various sources and to make it readily available in one place, kind-of like a cache! Garner works today with the <a href="http://github.com/intridea/grape">Grape API framework</a> and the <a href="http://github.com/mongoid/mongoid">Mongoid ODM</a>. We encourage you to fork the project, extend our library to other systems and contribute your code back, if you find it useful.</p>

<p>Garner implements the Artsy API caching cookbook that has been tried by fire in production.</p>

<!-- more -->

<h3 id="enabling-caching-of-static-data">Enabling Caching of Static Data</h3>

<p>Caching static data is fairly easy: set <code class="language-plaintext highlighter-rouge">Cache-Control</code> and <code class="language-plaintext highlighter-rouge">Expires</code> headers in the HTTP response.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">expire_in</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">24</span> <span class="o">*</span> <span class="mi">365</span>
<span class="n">header</span> <span class="s2">"Cache-Control"</span><span class="p">,</span> <span class="s2">"private, max-age=</span><span class="si">#{</span><span class="n">expire_in</span><span class="si">}</span><span class="s2">"</span>
<span class="n">header</span> <span class="s2">"Expires"</span><span class="p">,</span> <span class="no">CGI</span><span class="p">.</span><span class="nf">rfc1123_date</span><span class="p">(</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span><span class="p">.</span><span class="nf">utc</span> <span class="o">+</span> <span class="n">expire_in</span><span class="p">)</span>
</code></pre></div></div>

<p>This example indicates to a cache in front of your service (CDN, proxy or user’s browser) that the data expires in a year and that it’s private for this user. When caching truly static data, such as images, use <code class="language-plaintext highlighter-rouge">public</code>. Your CDN or proxy, such as <a href="https://www.varnish-cache.org/">Varnish</a> that sits in front of Artsy on <a href="http://www.heroku.com/">Heroku</a>, will cache the data and subsequent requests won’t even need to hit your server, even though it could potentially serve different content every time.</p>

<h3 id="disabling-caching-of-dynamic-data">Disabling Caching of Dynamic Data</h3>

<p>Caching dynamic data is slightly more involved. Let’s begin with a simple Ruby API that returns a counter.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">API</span> <span class="o">&lt;</span> <span class="no">Grape</span><span class="o">::</span><span class="no">API</span>
  <span class="k">def</span> <span class="nf">count</span>
    <span class="p">{</span> <span class="n">count</span> <span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This kind of dynamic data cannot have a well-defined expiration time. The counter may be incremented at any time via another API call or process, so we must tell the client not to cache it. This is accomplished by setting the value of <code class="language-plaintext highlighter-rouge">Cache-Control</code> to <code class="language-plaintext highlighter-rouge">private, max-age=0, must-revalidate</code>. The <code class="language-plaintext highlighter-rouge">private</code> option instructs the client that it’s allowed to store data in a private cache (unnecessary, but is known to work around overzealous cache implementations), <code class="language-plaintext highlighter-rouge">max-age</code> that it must check with the server every time it needs this data and <code class="language-plaintext highlighter-rouge">must-revalidate</code> prevents gateways from returning a response if your API server is unreachable. An additional <code class="language-plaintext highlighter-rouge">Expires</code> header set to a past date (usually January 1st 1990), will make double-sure the entire request expires immediately with old browsers.</p>

<p>Garner provides <a href="https://github.com/dblock/garner/blob/master/lib/garner/middleware/cache/bust.rb">Garner::Middleware::Cache::Bust</a> a Rack middleware that accomplishes just that.</p>

<h3 id="if-modified-since-etags-and-if-none-match">If-Modified-Since, ETags and If-None-Match</h3>

<p>Given our API example, a client may want to retrieve the value of the counter and, for example, run a job every time the value changes. As it stands, the current API requires an effort on the client’s part to remember the previous value and compare it every time it makes an API call. This can be avoided by asking the server for a new counter if the value has changed since last time it was retrieved.</p>

<p>One option for the client is to include an <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> header with a timestamp. The server could then choose to respond with <code class="language-plaintext highlighter-rouge">304 Not Modified</code> if the counter hasn’t changed since the timestamp in <code class="language-plaintext highlighter-rouge">If-Modified-Since</code>. While this may be acceptable for certain data, timestamps have a granularity of seconds. A counter may be modified multiple times during the same second, therefore preventing it from retrieving the result of the second modification.</p>

<p>A more robust solution is to generate a unique signature, called ETag, for this data and to use it to find out whether the counter has changed. There exists a generic <a href="https://github.com/rack/rack/blob/master/lib/rack/etag.rb">Rack::ETag</a> middleware that sets ETags on all text bodies. Adding the middleware would produce an ETag for every response from the API. You can now combine <code class="language-plaintext highlighter-rouge">Rack::ETag</code> and <code class="language-plaintext highlighter-rouge">Rack::Cache</code> - a client makes a request with an <code class="language-plaintext highlighter-rouge">If-None-Match: Etag</code> header and the server returns a <code class="language-plaintext highlighter-rouge">304 Not Modified</code> if the data hasn’t changed, without sending the data.</p>

<h3 id="memcached-via-dalli-and-railscache">Memcached via Dalli and Rails.Cache</h3>

<p>There’s an obvious problem with <code class="language-plaintext highlighter-rouge">Rack::Cache</code>. In order for it to serve a <code class="language-plaintext highlighter-rouge">304 Not Modified</code> response it must compare the ETag from the request with the ETag generated from the body of the current response. So it saves bandwidth, but doesn’t save execution time on the server. We’d also like the server to cache the entire response and therefore avoid any heavy processing, such as querying a database.</p>

<p>A typical Ruby cache supports a block syntax. The following example returns a cached copy when available or executes the supplied block and stores the result in the cache. In this context <code class="language-plaintext highlighter-rouge">cache</code> could be <code class="language-plaintext highlighter-rouge">Rails.cache</code> or an instance of <code class="language-plaintext highlighter-rouge">ActiveSupport::Cache::FileStore</code>. We use <code class="language-plaintext highlighter-rouge">Rails.cache</code> with <a href="http://memcached.org/">Memcached</a> via the <a href="https://github.com/mperham/dalli">dalli gem</a> in production.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cache</span><span class="p">(</span><span class="s2">"count"</span><span class="p">)</span> <span class="k">do</span>
  <span class="p">{</span> <span class="n">count</span> <span class="p">:</span> <span class="mi">0</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The parameter of the <code class="language-plaintext highlighter-rouge">cache</code> call is the cache key that uniquely identifies the cache entry. Hard-coding cache keys is tedious, so we can generate a key from the API version, route and request parameters.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cache_key</span>
  <span class="n">options</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:version</span><span class="p">]</span> <span class="o">=</span> <span class="n">version</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:path</span><span class="p">]</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="nf">path</span>
  <span class="n">options</span><span class="p">[</span><span class="ss">:params</span><span class="p">]</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="no">GET</span>
  <span class="no">Digest</span><span class="o">::</span><span class="no">MD5</span><span class="p">.</span><span class="nf">hexdigest</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="nf">to_json</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This generic approach to key generation is fine to get one started, but is largely insufficient for real-world applications.</p>

<h3 id="production-grade-cache-keys-and-model-binding">Production-Grade Cache Keys and Model Binding</h3>

<p>Most large scale web properties operate on data with the following requirements.</p>

<ul>
  <li>Partition cache in sync with object ownership and permissions. For example, a <code class="language-plaintext highlighter-rouge">Widget</code> may have different representations depending on whether <code class="language-plaintext highlighter-rouge">current_user</code> owns it or not or may choose to return a <code class="language-plaintext highlighter-rouge">401 Access Denied</code> in some of the cases.</li>
  <li>Retrieve objects from cache no matter where the calling code appears. The above strategy would generate identical keys from two different locations within the same function.</li>
  <li>Invalidate entire cached collections when one of the objects in a collection has changed. For example, invalidate all cached instances of <code class="language-plaintext highlighter-rouge">Widget</code> when a new <code class="language-plaintext highlighter-rouge">WidgetCategory</code> is created and forces a reorganization of those widgets.</li>
</ul>

<p>Garner will help you introduce such aspects of your domain model into the cache and solve all these.</p>

<p>A cache is a collection of flat name/value pairs. We’ll specify object relationships within each key by chaining model names, field values and by using wildcards where appropriate. For example, <code class="language-plaintext highlighter-rouge">User/id=12,Widget/id=45,Gadget/*</code> binds the cache value to changes in <code class="language-plaintext highlighter-rouge">User</code> with id=12, <code class="language-plaintext highlighter-rouge">Widget</code> with id=45 and any instance of <code class="language-plaintext highlighter-rouge">Gadget</code>.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cache</span><span class="p">(</span><span class="ss">bind: </span><span class="p">[[</span><span class="no">User</span><span class="p">,</span> <span class="p">{</span> <span class="ss">id: </span><span class="n">current_user</span><span class="p">.</span><span class="nf">id</span> <span class="p">}],</span> <span class="p">[</span><span class="no">Widget</span><span class="p">,</span> <span class="p">{</span> <span class="ss">id: </span><span class="n">params</span><span class="p">[</span><span class="ss">:widget_id</span><span class="p">]</span> <span class="p">}],</span> <span class="p">[</span><span class="no">Gadget</span><span class="p">]</span> <span class="p">])</span>
  <span class="no">Widget</span><span class="p">.</span><span class="nf">where</span><span class="p">({</span> <span class="ss">id: </span><span class="n">params</span><span class="p">[</span><span class="ss">:widget_id</span><span class="p">],</span> <span class="ss">user_id: </span><span class="n">current_user</span><span class="p">.</span><span class="nf">id</span> <span class="p">}).</span><span class="nf">first</span><span class="p">.</span><span class="nf">as_json</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Binding to multiple objects or classes can also be reasoned about as a way to partition the cache. Adding structure into the fields lets us reason about the relationships between various instances of data in the cache.</p>

<h3 id="role-based-caching">Role-Based Caching</h3>

<p>Role-Based caching is a subset of the generic problem of binding data to groups of other objects. For example, a <code class="language-plaintext highlighter-rouge">Widget</code> may have a different representation for an <code class="language-plaintext highlighter-rouge">admin</code> vs. a <code class="language-plaintext highlighter-rouge">user</code>. In Garner you can inject something called a “key strategy” into the current key generation pipeline. A strategy is a plain module that must implement two methods: <code class="language-plaintext highlighter-rouge">field</code> and <code class="language-plaintext highlighter-rouge">apply</code>. The former should define a unique key name and the latter applies the strategy within a context.</p>

<p>The following example introduces the role of the current user into the cache key.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">MyApp</span>
  <span class="k">module</span> <span class="nn">Garner</span>
    <span class="k">module</span> <span class="nn">RoleStrategy</span>
      <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span>
        <span class="k">def</span> <span class="nf">field</span>
          <span class="ss">:role</span>
        <span class="k">end</span>
        <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">context</span> <span class="o">=</span> <span class="p">{})</span>
          <span class="n">key</span><span class="p">.</span><span class="nf">merge</span> <span class="p">{</span> <span class="ss">:role</span> <span class="o">=&gt;</span> <span class="n">current_user</span><span class="p">.</span><span class="nf">role</span> <span class="p">}</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Garner key strategies can be currently set at application startup time.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Garner</span><span class="o">::</span><span class="no">Cache</span><span class="o">::</span><span class="no">ObjectIdentity</span><span class="o">::</span><span class="no">KEY_STRATEGIES</span> <span class="o">=</span> <span class="p">[</span>
  <span class="no">Garner</span><span class="o">::</span><span class="no">Strategies</span><span class="o">::</span><span class="no">Keys</span><span class="o">::</span><span class="no">Caller</span><span class="p">,</span> <span class="c1"># support multiple calls from the same function</span>
  <span class="no">MyApp</span><span class="o">::</span><span class="no">Garner</span><span class="o">::</span><span class="no">RoleStrategy</span><span class="p">,</span> <span class="c1"># custom strategy for role-based access</span>
  <span class="no">Garner</span><span class="o">::</span><span class="no">Strategies</span><span class="o">::</span><span class="no">Keys</span><span class="o">::</span><span class="no">RequestPath</span> <span class="c1"># injects the HTTP request's URL</span>
<span class="p">]</span>
</code></pre></div></div>

<h3 id="multiple-calls-from-the-same-function">Multiple Calls from the Same Function</h3>

<p>Binding to the same set of objects within the same function call will produce the same key. To solve this in a generic way we can examine the call stack, find the caller that’s not within the helper module and inject it in the key options.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">api_caller</span> <span class="o">=</span> <span class="nb">caller</span><span class="p">.</span><span class="nf">detect</span> <span class="p">{</span> <span class="o">|</span><span class="n">line</span><span class="o">|</span> <span class="o">!</span><span class="p">(</span><span class="n">line</span> <span class="o">=~</span> <span class="sr">/\/</span><span class="si">#{</span><span class="no">File</span><span class="p">.</span><span class="nf">basename</span><span class="p">(</span><span class="kp">__FILE__</span><span class="p">)</span><span class="si">}</span><span class="sr">/</span><span class="p">)</span> <span class="p">}</span>
<span class="n">api_caller_line</span> <span class="o">=</span> <span class="n">api_caller</span><span class="p">.</span><span class="nf">match</span><span class="p">(</span><span class="sr">/(.*\.rb:[0-9]*):/</span><span class="p">)</span> <span class="k">if</span> <span class="n">api_caller</span>
<span class="n">options</span><span class="p">[</span><span class="ss">:caller</span><span class="p">]</span> <span class="o">=</span> <span class="n">api_caller_line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">api_caller_line</span>
</code></pre></div></div>

<p>Garner implements this as <a href="https://github.com/dblock/garner/blob/master/lib/garner/strategies/keys/caller_strategy.rb">Garner::Strategies::Keys::Caller</a>.</p>

<h3 id="cache-invalidation">Cache Invalidation</h3>

<p>Invalidating a cache entry bound to multiple objects requires keeping an additional index along with the actual cache data. In the example above we’ve bound the resulting Widget to a specific <code class="language-plaintext highlighter-rouge">User</code>, the <code class="language-plaintext highlighter-rouge">Widget</code> instance itself and all instances of <code class="language-plaintext highlighter-rouge">Gadget</code>. Every time a Gadget changes, we’ll want to invalidate this cache entry. Garner will handle this either automatically via a mixin (we’ve provided <a href="https://github.com/dblock/garner/blob/master/lib/garner/mixins/mongoid_document.rb">Garner::Mixins::Mongoid::Document</a> for the Mongoid ODM) or via an explicit <code class="language-plaintext highlighter-rouge">invalidate(Gadget)</code> call.</p>

<p>Since we’re not able to scan the entire cache during invalidation, we keep a key index in the cache as well. The key for each index entry is derived from the individual elements in the binding.</p>

<h3 id="using-with-grape">Using with Grape</h3>

<p>Garner currently ships with <a href="https://github.com/dblock/garner/blob/master/lib/garner/mixins/grape_cache.rb">Garner::Mixins::Grape::Cache</a>. There’re two ways to use it: <code class="language-plaintext highlighter-rouge">cache</code> and <code class="language-plaintext highlighter-rouge">cache_or_304</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">cache</code> implementation will generate a key from the binding by applying all registered cache key strategies within the current context, look up the entry by that key and either cache hit or miss. In summary, it’s an extension to a standard cache, introducing a much more fully featured binding system.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># caches, but always returns the widget</span>
<span class="n">get</span> <span class="s2">"widget/:id"</span> <span class="k">do</span>
  <span class="n">cache</span><span class="p">(</span><span class="ss">bind: </span><span class="p">[</span><span class="no">Widget</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]])</span> <span class="k">do</span>
    <span class="no">Widget</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">cache_or_304({ bind: [ ] })</code> will generate a meta key from the binding by applying all registered cache key strategies within the current context and search the cache index by the meta key. If a value is found, it will be compared to the ETag or the timestamp supplied in the request’s <code class="language-plaintext highlighter-rouge">If-None-Match</code> or <code class="language-plaintext highlighter-rouge">If-Modified-Since</code> and issue a <code class="language-plaintext highlighter-rouge">304 Not Modified</code> where appropriate.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># caches, returns the widget and supports If-Modified-Since or If-None-Match</span>
<span class="n">get</span> <span class="s2">"widget/:id"</span> <span class="k">do</span>
  <span class="n">cache_or_304</span><span class="p">(</span><span class="ss">bind: </span><span class="p">[</span><span class="no">Widget</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]])</span> <span class="k">do</span>
    <span class="no">Widget</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">])</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>

<p>An effective cache implementation for a web service combines server-side caching with client-side expiration. The latter broadly includes proxies, CDNs and browsers, all active actors in the process of exchanging information. The web is, in a way, an eventually consistent data storage and distribution system.</p>

<h3 id="links">Links</h3>

<ul>
  <li><a href="https://github.com/artsy/garner">Garner</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simplifying Model-Level JSON Versioning with Mongoid-Cached-Json]]></title>
    <link href="https://artsy.github.io/blog/2012/03/23/simplifying-model-level-json-versioning-with-mongoid-cached-json/"/>
    <updated>2012-03-23T09:14:00+00:00</updated>
    <id>https://artsy.github.io/blog/2012/03/23/simplifying-model-level-json-versioning-with-mongoid-cached-json</id>
    <content type="html"><![CDATA[<p>Did you know that Netflix has hundreds of API versions, one for each device? Daniel Jacobson’s <a href="http://www.slideshare.net/danieljacobson/techniques-for-scaling-the-netflix-api-qcon-sf">Techniques for Scaling the Netflix API</a> at QConSF 2011 explained why they chose this model. And while we don’t all build distributed services that supply custom-tailored data to thousands of heterogeneous TVs and set-top boxes, we do have to pay close attention to API versioning from day one.</p>

<p>Versioning is hard. Your data models evolve, but you must maintain backward-compatibility for your public interfaces. While many strategies exist to deal with this problem, we’d like to propose one that requires very little programming effort and that is more declarative in nature.</p>

<p>At Artsy we use <a href="http://github.com/intridea/grape">Grape</a> and implement the “path” versioning strategy from the <a href="http://github.com/intridea/grape/tree/frontier">frontier</a> branch. Our initial v1 API is consumed by our own website and services and lives at <a href="https://artsyapi.com/api/v1">https://artsyapi.com/api/v1</a>. We’ve also prototyped v2 and by the time v1 is frozen, it should already be in production.</p>

<p>Grape takes care of version-based routing and has a system that lets you split version-based presentation of a model from the model implementation. I find that separation forcefully induced by unnecessary implementation complexity around wanting to return different JSON depending on the API version requested. What if implementing versioning in <code class="language-plaintext highlighter-rouge">as_json</code> were super simple?</p>

<p>Consider a Person model returned from a v1 API.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">API</span> <span class="o">&lt;</span> <span class="no">Grape</span><span class="o">::</span><span class="no">API</span>
  <span class="n">prefix</span> <span class="ss">:api</span>
  <span class="n">version</span> <span class="ss">:v1</span>
  <span class="n">namespace</span> <span class="ss">:person</span>
    <span class="n">get</span> <span class="s2">":id"</span>
      <span class="no">Person</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">as_json</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>

  <span class="n">field</span> <span class="ss">:name</span>

  <span class="k">def</span> <span class="nf">as_json</span>
    <span class="p">{</span>
      <span class="ss">name: </span><span class="nb">name</span>
    <span class="p">}</span>
  <span class="k">end</span>

<span class="k">end</span>
</code></pre></div></div>

<p>In v2 the model split <code class="language-plaintext highlighter-rouge">:name</code> into a <code class="language-plaintext highlighter-rouge">:first</code> and <code class="language-plaintext highlighter-rouge">:last</code> name and in v3 <code class="language-plaintext highlighter-rouge">:name</code> has finally been deprecated. A version v3 Person model would look as follows.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>

  <span class="n">field</span> <span class="ss">:first</span>
  <span class="n">field</span> <span class="ss">:last</span>

  <span class="k">def</span> <span class="nf">as_json</span>
    <span class="p">{</span>
      <span class="ss">first: </span><span class="n">first</span><span class="p">,</span>
      <span class="ss">last: </span><span class="n">last</span>
    <span class="p">}</span>
  <span class="k">end</span>

<span class="k">end</span>
</code></pre></div></div>

<p>How can we combine these two implementations and write <code class="language-plaintext highlighter-rouge">Person.find(params[:id]).as_json({ :version =&gt; ? })</code>?</p>

<p>In <a href="http://github.com/dblock/mongoid-cached-json">mongoid-cached-json</a> we’ve introduced a declarative way of versioning JSON. Here’s the code for Person v3.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">CachedJson</span>

  <span class="n">field</span> <span class="ss">:first</span>
  <span class="n">field</span> <span class="ss">:last</span>

  <span class="k">def</span> <span class="nf">name</span>
    <span class="p">[</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="p">].</span><span class="nf">join</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">json_fields</span> <span class="p">\</span>
    <span class="ss">name: </span><span class="p">{</span> <span class="ss">:versions</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:v1</span><span class="p">,</span> <span class="ss">:v2</span> <span class="p">]</span> <span class="p">},</span>
    <span class="ss">first: </span><span class="p">{</span> <span class="ss">:versions</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:v2</span><span class="p">,</span> <span class="ss">:v3</span> <span class="p">]</span> <span class="p">},</span>
    <span class="ss">last: </span><span class="p">{</span> <span class="ss">:versions</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:v2</span><span class="p">,</span> <span class="ss">:v3</span> <span class="p">]</span> <span class="p">}</span>

<span class="k">end</span>
</code></pre></div></div>

<p>With the <a href="http://github.com/dblock/mongoid-cached-json">mongoid-cached-json</a> gem you also get caching that respects JSON versioning, for free. Read about it <a href="http://artsy.github.com/blog/2012/02/20/caching-model-json-with-mongoid-cached-json/">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Caching Model JSON with Mongoid-Cached-Json]]></title>
    <link href="https://artsy.github.io/blog/2012/02/20/caching-model-json-with-mongoid-cached-json/"/>
    <updated>2012-02-20T13:06:00+00:00</updated>
    <id>https://artsy.github.io/blog/2012/02/20/caching-model-json-with-mongoid-cached-json</id>
    <content type="html"><![CDATA[<p>Consider the following two <a href="http://mongoid.org">Mongoid</a> domain models, <em>Widget</em> and <em>Gadget</em>.</p>

<p>``` ruby widget.rb
class Widget
  include Mongoid::Document</p>

<p>field :name
  has_many :gadgets
end</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>``` ruby gadget.rb
class Gadget
  include Mongoid::Document

  field :name
  field :extras

  belongs_to :widget
end
</code></pre></div></div>
<p>And an API call that returns a collection of widgets.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">get</span> <span class="s1">'widgets'</span> <span class="k">do</span>
  <span class="no">Widget</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">as_json</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Given many widgets, the API makes a subquery to fetch the corresponding gadgets for each widget.</p>

<p>Introducing <a href="https://github.com/dblock/mongoid-cached-json">mongoid-cached-json</a>. This library mitigates several frequent problems with such code.</p>

<ul>
  <li>Adds a declarative way of specifying a subset of fields to be returned part of <em>as_json</em>.</li>
  <li>Avoids a large amount of subqueries by caching document JSONs participating in the parent-child relationship.</li>
  <li>Provides a consistent strategy for restricting child documents’ fields from being returned via the parent JSON.</li>
</ul>

<p>Using <em>Mongoid::CachedJson</em> we were able to cut our JSON API average response time by about a factor of 10. Find it <a href="https://github.com/dblock/mongoid-cached-json">on Github</a>.</p>
]]></content>
  </entry>
  
</feed>
