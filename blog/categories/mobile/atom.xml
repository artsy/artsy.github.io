<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mobile | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/mobile/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2017-02-06T19:08:59+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Xcode 8 Manual Codesigning with Fastlane]]></title>
    <link href="http://artsy.github.io/blog/2017/01/13/xcode-8-fastlane-codesigning/"/>
    <updated>2017-01-13T14:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/01/13/xcode-8-fastlane-codesigning</id>
    <content type="html"><![CDATA[<p>New year, new deploy process! Late last year our mobile team completed the update to Swift 3 (and thus, the update to Xcode 8). The latest version of Apple's IDE includes a lovely feature: automating provisioning profile management! (Note: not sarcasm, the feature is really nice. Check out the <a href="https://developer.apple.com/videos/play/wwdc2016/401/">WWDC video</a> for an in-depth exploration.)</p>

<p><img src="/images/2017-01-13-xcode-8-fastlane-codesigning/xcode-screenshot.png" alt="Automatic code signing settings" /></p>

<p>However, when I went to make our first <a href="http://artsy.github.io/blog/2015/12/15/Automating-Testflight-Deploys/">automated deploy</a> today, things didn't work; I got a somewhat cryptic error about code signing.</p>

<!-- more -->


<blockquote><p>Code signing is required for product type 'Application' in SDK 'iOS 10.1'</p></blockquote>

<p>Code signing was failing for our project. Hmm. First step in fixing a bug is always to reproduce it, which I could do locally. I started looking into the code that manages our deploys' signing process and got lost. My colleague Orta was kind enough to give me a hand.</p>

<p>Some background: the Fastlane suite of tools includes <a href="https://github.com/fastlane/fastlane/tree/master/match">Match</a>, which manages your signing certificates and provisioning profiles in a private GitHub repository. We don't use match due to complications with our multiple apps, but we use <a href="https://github.com/artsy/eigen/blob/608f60860165dd9b3c376da00492a3cb36bf5214/fastlane/Fastfile#L95-L130">very similar logic</a> to clone the repo, extract the certificate and profile, and install the keys on CI.</p>

<p>So what wasn't working?</p>

<p>Well it turns out that Xcode's fancy new automatic code signing was incompatible with our manual process of specifying certificates and profiles. The easy solution would be to simply disable that setting, but that would be a shame: the new automatic code signing makes developing on devices way easier and we didn't want to sacrifice that for the sake of our deploys.</p>

<p>So we went looking and luckily found <a href="https://github.com/artsy/eigen/pull/2104">the solution</a>. We amended our codesigning setup with the <a href="https://docs.fastlane.tools/actions/#update_project_provisioning">update_project_provisioning</a> and <a href="https://docs.fastlane.tools/actions/#update_project_team">update_project_team</a> Fastlane actions, and the <a href="https://github.com/hjanuschka/fastlane-plugin-update_project_codesigning">update_project_codesigning plugin</a>. Basically, we disable the automatic signing feature and then manually set the provisioning profile to the one we cloned from our private GitHub repo.</p>

<p>So remember folks, if you're ever asked to sacrifice ease of development for the sake of getting computers to behave, there's probably a better way.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Accessing the app's Source Code from your Simulator]]></title>
    <link href="http://artsy.github.io/blog/2016/10/14/Accessing-the-Source-Code-from-your-Simulator/"/>
    <updated>2016-10-14T12:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/10/14/Accessing-the-Source-Code-from-your-Simulator</id>
    <content type="html"><![CDATA[<p>In the last few months twice I've wanted to access the source code of our application. The first time I did it I came up with a pretty neat hack, but it wouldn't really work in many places. The second time however, I <a href="https://twitter.com/orta/status/786470282093625344">asked the internet</a>, and the <a href="https://twitter.com/saniul/status/786470857635827712">internet</a> <a href="https://twitter.com/0xced/status/786619335116750848">replied</a>.</p>

<p>TLDR: You can use your <a href="https://github.com/artsy/emission/pull/350/commits/2a39c743bcaaf2e3b848ad60621198f40365fdd2">project's scheme</a> to expose derived Xcode environment variables to your source code.</p>

<p>The rest of the blog post is a little bit about <em>why</em> I wanted to do that and what I did with it.</p>

<!-- more -->


<p>Both times I've wanted to access the source code of our apps is because I've wanted to make better admin tools. It should come as no surprise to people who know me that I care about tooling, but I also care a lot about making it possible for our admins to do their own thing. As such, our <a href="https://github.com/artsy/eigen/blob/master/Artsy/View_Controllers/Admin/ARAdminSettingsViewController.m">admin settings panel</a> in Eigen is extensive.</p>

<a name="Root.React.Components"></a>
<h3>Root React Components</h3>

<p>The first time came when I started to think about what admin options I'd like to see for people using our React Native side. These are the options I came up with:</p>

<p> <img src="/images/source-code-sim/react-admin-eigen.png" alt="/images/source-code-sim/react-admin-eigen.png" /></p>

<p>There are two interesting things about it:</p>

<ul>
<li>We support running any master commit of our React Native code inside Eigen, for Admins, <a href="https://apphub.io">via AppHub</a></li>
<li>We allow loading arbitrary React components as an admin.</li>
</ul>


<p> It's this last bit that's interesting, right now I'm working on a new root Gene component (read: new view controller) in Emission, our React Native implementation. As this work has not moved upstream into Eigen, I can access it through a commit on AppHub, and then open it using our custom module loader:</p>

<p><img src="/images/source-code-sim/react-module-eigen.png" alt="/images/source-code-sim/react-module-eigen.png" /></p>

<p>In order to show the available root components (Artist/Home/Gene), we use GitHub's raw URLs to download the source code of our Open Source apps. Hah, a nice hack right? I <a href="https://github.com/artsy/eigen/blob/master/Artsy/View_Controllers/Admin/ARAdminNetworkModel.m">created</a> a <code>ARAdminNetworkModel</code> with an API like this:</p>

<pre><code class="objc">@interface ARAdminNetworkModel : NSObject

- (void)getEmissionJSON:(NSString *)path completion:(void (^)(NSDictionary *json, NSError *error))completion;

- (void)getEmissionFile:(NSString *)path completion:(void (^)(NSString *fileContents, NSError *error))completion;

@end
</code></pre>

<p>Which simply uses <code>NSURLSession</code> under the hood:</p>

<pre><code class="objc">- (void)getEmissionData:(NSString *)path completion:(void (^)(NSData *data, NSError *error))completion;
{
    NSURLSession *session = [NSURLSession sharedSession];
    NSString *urlFormat = @"https://raw.githubusercontent.com/artsy/emission/master/%@";
    NSString *url = [NSString stringWithFormat: urlFormat, path];
    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:url]];
    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {
            completion(data, error);
    }];
    [task resume];
}
</code></pre>

<p>Nothing special, but it required a cognitive jump to get there.</p>

<a name="Submodule.Introspection"></a>
<h3>Submodule Introspection</h3>

<p>The second time I wanted this is inside <a href="https://github.com/artsy/emission/tree/master/Example">the example app</a> for Emission. This is a typical example application for a library made by <code>pod lib create</code>. This example app is basically just the admin settings panel from Eigen, shown above.</p>

<p>When I <a href="https://github.com/artsy/emission/pull/347">switched the</a> example app to use a similar theme and menu DSL as Eigen, I also took the chance to expand on the buttons we had available. Previously there was the ability to load the view controller for one specific artist, but I knew we had a <a href="https://github.com/artsy/metaphysics/blob/master/schema/artist/maps/artist_title_slugs.js">giant list of artist slugs</a> inside one of our optional sub-modules. What I wanted to do, was offer a random Artist from that if the submodule was <code>init</code>'d.</p>

<p>This required introspecting the source, which I could have also done via the GitHub API, but it was also feasible to do by accessing the filesystem outside of the simulator. This is totally possible ( and is <a href="https://www.objc.io/issues/15-testing/snapshot-testing/">how FBSnapshots works</a> ) but I needed to access the project root, then I could build relative links. Thus, <a href="https://twitter.com/orta/status/786470282093625344">I asked the internet</a>. I knew these variables existed, but that they were a part of the build process - and not exposed to the app runtime.</p>

<p>There are two ways to do it, both make sense for different contexts:</p>

<ul>
<li><a href="https://github.com/artsy/emission/blob/74d0bc6cc45da906436f8bbc33710ea030657ee8/Example/Emission/Info.plist#L5-L6">Baking the value into your Info.plist</a> - which makes it available for all consumers at runtime, e.g. you could deploy this value, but it's not too useful for my problem.</li>
<li><a href="https://github.com/artsy/emission/pull/350/commits/2a39c743bcaaf2e3b848ad60621198f40365fdd2">Exposing it as an environment variable via your scheme</a> - perfect for this case, the variable won't be exported when you deploy.</li>
</ul>


<p>Now our scheme looks like this:</p>

<p></div></div><a href='/images/source-code-sim/scheme-settings-emission.png'><img src="/images/source-code-sim/scheme-settings-emission.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>I can then use the value of <code>SRCROOT</code> as the start of an absolute path to get to any of the source code in our project. Making the <a href="https://github.com/artsy/emission/blob/dda57636e424ab7d4517de57f3e8bd917fcb3c6f/Example/Emission/ARRootViewController.m#L85-L108">final code</a>:</p>

<pre><code class="obj-c">- (ARCellData *)jumpToRandomArtist
{
  NSString *sourceRoot = [NSProcessInfo processInfo].environment[@"SRCROOT"];
  NSString *artistListFromExample = @"../externals/metaphysics/schema/artist/maps/artist_title_slugs.js";
  NSString *slugsPath = [sourceRoot stringByAppendingPathComponent:artistListFromExample];

  NSFileManager *manager = [NSFileManager defaultManager];

  // Don't have the submodule? bail, it's no biggie
  if (![manager fileExistsAtPath:slugsPath]) { return nil; }

  // Otherwise lets support jumping to a random Artist
  return [self tappableCellDataWithTitle:@"Artist (random from metaphysics)" selection: ^{
    NSString *data = [NSString stringWithContentsOfFile:slugsPath encoding:NSUTF8StringEncoding error:nil];

    ... and so on
</code></pre>

<a name="Tooling"></a>
<h3>Tooling</h3>

<p>Paying attention to your admin tools, and improving your development experience for the whole team is a great way to win friends and influence people. Introspecting your source code may help that.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Eidolon Deploy Process]]></title>
    <link href="http://artsy.github.io/blog/2016/10/08/eidolon-deploy-process/"/>
    <updated>2016-10-08T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/10/08/eidolon-deploy-process</id>
    <content type="html"><![CDATA[<p>Since we <a href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">originally built</a> Eidolon ‚Äì an auction bidding kiosk app ‚Äì the project has largely remained in maintenance mode. Eidolon was one of the first projects that we used automated deploys for, and the deploy process has remained largely unchanged. I believe this stability of the deploy process is a testament to how well the automated deploys have gone.</p>

<p>This post is going to detail the mechanics of automated deploys for an enterprise-distributed iOS application, discuss lessons we learned and applied to other projects' deploy processes, and describe some of the changes we'd like to make. Our project is entirely open source, so you can check out any part of the code on your own or <a href="https://github.com/artsy/eidolon/issues/new">open an issue</a> with questions.</p>

<!-- more -->


<a name="Deploying.Eidolon"></a>
<h2>Deploying Eidolon</h2>

<p>It's one command on the terminal to deploy Eidolon:</p>

<pre><code class="sh">bundle exec fast lane deploy version:X.Y.Z
</code></pre>

<p>This command does a lot of things. It uses <a href="https://fastlane.tools">Fastlane</a>, and you can <a href="https://github.com/artsy/eidolon/blob/a0aad31bccfe2b4abf648fc64892cc165be400b4/fastlane/Fastfile#L40-L131">read the entire script here</a>. We're going to go over each part line-by-line. A few notes:</p>

<ul>
<li>We run this command locally on a development machine that has the keys installed to sign a deploy.</li>
<li>Our changelog is formatted in <a href="https://en.wikipedia.org/wiki/YAML">yaml</a>, our script uses this strategically.</li>
<li>Our deploy script modifies the project's Info.plist version and build number, as well as the changelog.</li>
</ul>


<p>Let's dive in!</p>

<a name="The.Script"></a>
<h2>The Script</h2>

<p>The first thing we do is verify that the version number we've been given is in the proper <a href="http://semver.org">SemVer</a> format.</p>

<pre><code class="rb">version = options[:version]
raise "You must specify a version in A.B.X format to deploy." if version.nil? || version.scan(/\d+\.\d+\.\d+/).length == 0
</code></pre>

<p>We deploy using Hockey, so make sure that an environment variable with the Hockey API key is set.</p>

<pre><code class="rb">hockey_api_token = ENV['HOCKEY_API_TOKEN']
raise "You must specify a HOCKEY_API_TOKEN environment variable to deploy." if hockey_api_token.nil?
</code></pre>

<p>We also want to verify that we have valid API keys for analytics, the Artsy API, and a few other services the app uses. This validation only makes sure the keys have been set to non-empty values. And we don't want to accidentally deploy uncommited changes, so we check the git status first.</p>

<pre><code class="rb">verify_pod_keys
ensure_git_status_clean
</code></pre>

<p>Next we need to set the build number. These need to be unique, and we use the current date. This could be a problem if we need to deploy more than once in a day. It hasn't been a problem yet, though, since we rarely deploy.</p>

<p>We also want to set the Info.plist's version to the one specified when we run the <code>fastlane</code> command.</p>

<pre><code class="rb">build_number = Time.new.strftime("%Y.%m.%d")
increment_build_number build_number: build_number

increment_version_number version_number: version
</code></pre>

<p>Okay, now it's time to generate markdown release notes from the changelog. Our changelog is in the following format:</p>

<pre><code class="yaml">upcoming:
- Upcoming version bug fix.

releases:
- version: X.Y.Z
  date: Month Day Year
  notes:
  - Previous version bug fix.
</code></pre>

<p>We want to grab the <code>upcoming</code> notes for the changelog, and then move them to the <code>releases</code> section. Let's generate the notes first:</p>

<pre><code class="rb">changelog_filename = '../CHANGELOG.yml'
changelog_yaml = YAML.load_file(changelog_filename)
release_notes = changelog_yaml['upcoming'].map{ |note| note.prepend '- ' }.join("\n")
</code></pre>

<p>Updating the changelog is a little messy. I tried parsing the changelog as yaml, modifying it, and then writing it back as yaml, but kept running into trouble. Instead, I treat it as plain text. We open the changelog, split on <code>releases:</code>, prepend the existing releases with a the generated release notes, and write the changelog.</p>

<pre><code class="rb">changelog_contents = File.read(changelog_filename)
existing_releases = changelog_contents.split('releases:').last
this_release = changelog_yaml['upcoming'].map{ |note| note.prepend '  ' }.join("\n")
changelog_contents = &lt;&lt;-EOS
upcoming:
releases:
- version: #{version}
  date: #{Time.new.strftime("%B %d %Y")}
  notes:
#{this_release}
#{existing_releases}
EOS

File.open(changelog_filename, 'w') { |file| file.puts changelog_contents }
</code></pre>

<p>At this point, we're ready to start the actual deploy process. First we need to download the provisioning profiles, which is only one step with Fastlane:</p>

<pre><code class="rb">sigh
</code></pre>

<p>Next we build our app using <code>gym</code>. We need to use the legacy build API, I can't remember why.</p>

<pre><code class="rb">gym(
  scheme: "Kiosk",
  export_method: 'enterprise',
  use_legacy_build_api: true
)
</code></pre>

<p>With our build finished, we upload to Hockey.</p>

<pre><code class="rb">hockey(
  api_token: hockey_api_token,
  notes: release_notes
)
</code></pre>

<p>Okay, our build is deployed. Time to let the team know there's a new version available:</p>

<pre><code class="rb">slack(
  message: "There is a new version of the Kiosk app available. Download it at http://artsy.net/kioskbeta",
  success: true,        # optional, defaults to true
  payload: {            # optional, lets you specify any number of your own Slack attachments
    'Version' =&gt; version,
    'What\'s new' =&gt; release_notes,
  },
  default_payloads: [],
)
</code></pre>

<p><code>default_payloads</code> needs to be empty I think, I can't remember why. Seems like "I can't remember why" is a common theme here...</p>

<p>Before committing the changes we've made to the changelog and Info.plist files, we need to clean any build artefacts. This includes the actual binary that was compiled, unit test coverage reports, and downloaded provisioning profiles.</p>

<pre><code class="rb">clean_build_artifacts
</code></pre>

<p>Finally, we commit, tag the build, and push to GitHub. Fastlane's built-in commands to commit to git reject any changes except to Info.plist files, and we've modified the changelog, so I used <code>sh</code> and used git directly.</p>

<pre><code class="rb">sh "git add .. ; git commit -m 'Deploying version #{version}.'"
add_git_tag tag: version
push_to_git_remote
</code></pre>

<p>And that's it! With one terminal command, we've done all the following:</p>

<ul>
<li>Verified version number format.</li>
<li>Verified the local environment is set up to deploy.</li>
<li>Verified API keys used by the app aren't empty.</li>
<li>Incremented the build number and version.</li>
<li>Updated the changelog.</li>
<li>Built and signed the app.</li>
<li>Uploaded the build to Hockey.</li>
<li>Posted a notification to Slack.</li>
<li>Tagged the release and pushed to GitHub.</li>
</ul>


<a name="Lessons.Learned"></a>
<h2>Lessons Learned</h2>

<p>Automating Eidolon deploys was one of the first automated deploys we built on Artsy's iOS team. Now, based on Eidolon's successful deploy process, all our iOS deploys are automated.</p>

<p>We've learned a few lessons.</p>

<p>First, running deploys locally is <em>so 2015</em>. Our more modern deploy processes run on continuous integration servers like Circle CI. This poses some problems around securing certificates necessary to deploy, maybe we'll cover that in a future blog post.</p>

<p>We deploy on CI based on pushes to a specific branch, and we run our deploy script only if the unit tests pass. This is a huge incentive to keep CI green.</p>

<p>On other iOS projects, we sometimes deploy more than once a day, so we use <code>Year.Month.Day.Hour</code> as the build number format, which is unique enough to do one deploy per hour. This is good enough for now.</p>

<p>One thing I really wish I'd done when I set up automated deploys is to document things a little better. To be honest, that's part of the motivation to write this blog post (better late than never!).</p>

<a name="Conclusion"></a>
<h2>Conclusion</h2>

<p>Overall, automating deploys for Eidolon has been a huge win. The other night, we had an emergency at an auction: the Eidolon app was no longer working and we needed a new deploy.</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Guess who‚Äôs got two thumbs and forgot that their enterprise distribution certificates expire in September.<br><br>üëçthis guyüëç</p>&mdash; Ash vs NSThread (@ashfurrow) <a href="https://twitter.com/ashfurrow/status/784548214527627266">October 8, 2016</a></blockquote>


<p> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script></p>

<p>From the time the team let me know about the problem to the time they had a fresh deploy with a new certificate, less than twenty minutes had passed. I issued one command and watched it do all the work for me. If I had to manually follow a set of arcane steps I hadn't done in a long time, our team might not have had the new build in time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Learn Swift at Artsy, Beginners Lesson Three]]></title>
    <link href="http://artsy.github.io/blog/2016/08/30/swift-at-artsy-beginners-lesson-three/"/>
    <updated>2016-08-30T09:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/08/30/swift-at-artsy-beginners-lesson-three</id>
    <content type="html"><![CDATA[<p>And we're back! With lesson three of the beginners' Swift-at-Artsy course. To recap, Orta and I <a href="http://artsy.github.io/blog/2016/01/26/swift-at-artsy/">led a course at Artsy</a> to teach our colleagues Swift <em>last</em> August, and we're doing it again. I'm leading the stream for people who've never programmed before.</p>

<p>Yesterday was lesson three and I have a <a href="https://youtu.be/e2ErzD8ibG8">screen recording</a> of my walkthrough of <a href="https://github.com/artsy/Swift-at-Artsy/tree/master/Beginners/Lesson%20Three">the material</a>.</p>

<!-- more -->


<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/e2ErzD8ibG8 ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On our implementation of React Native]]></title>
    <link href="http://artsy.github.io/blog/2016/08/24/On-Emission/"/>
    <updated>2016-08-24T12:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/08/24/On-Emission</id>
    <content type="html"><![CDATA[<center>
 <img src="/images/emission/emission-logo-artsy.svg" style="height:300px;">
</center>


<p>I arrived fashionably late to the <a href="/blog/2016/08/15/React-Native-at-Artsy/">React Native party</a> in Artsy. I had been a part of our <a href="/blog/2016/08/09/the-tech-behind-live-auction-integration/">Auctions Team</a>, where we worked in Swift with <a href="https://cocoapods.org/pods/Interstellar">some light-FRP</a>. We were not affected by the 4 months of simultaneous work on moving to React Native, at all.</p>

<p>It was a quiet revolution. I did not have to install <code>npm</code>, I made zero changes to the code for auctions and the whole app's infrastructure barely changed. Yet we moved to making all new code inside our 3 year old iOS app use React Native. What gives?</p>

<p>Well, first up we weren't planning a re-write, we don't have that kind of luxury and the scope of our app is too big compared to the team working on it. Second, we reused existing dependency infrastructure to support JavaScript based apps. Read on to find out what that looks like.</p>

<!-- more -->


<a name="Why.we.were.in.a.good.position.to.do.this"></a>
<h3>Why we were in a good position to do this</h3>

<p>Let's talk a little about the Artsy flagship app, <a href="https://github.com/artsy/eigen/">Eigen</a>. It's an app that aimed to comprehensively cover the art world. From <a href="https://www.artsy.net/shows">Shows</a> to <a href="https://www.artsy.net/galleries">Galleries</a>, <a href="https://www.artsy.net/art-fairs">Fairs</a> to <a href="https://www.artsy.net/auctions">Auctions</a>, <a href="https://www.artsy.net/institutions">Museums</a> to <a href="https://www.artsy.net/articles">Magazines</a>.</p>

<p>It all looks a bit like this:</p>

<p></div></div><a href='/images/emission/eigen-overview.jpg'><img src="/images/emission/eigen-overview.jpg"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Our app neatly splits into two areas of view controllers, ones that act as a browser chrome, and individual view controllers that normally map 1:1 to <a href="https://github.com/artsy/eigen/blob/master/Artsy/App/ARSwitchBoard.m#L122">routes</a> on the Artsy website.</p>

<p>For example, the route <code>artsy.net/artwork/glenn-brown-suffer-well</code> maps to the native <code>ARArtworkViewController</code>.</p>

<p></div></div><a href='/images/emission/eigen.svg'><img src="/images/emission/eigen.svg"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Just as a browser knows very little about the individual content of the pages that it's rendering, the eigen chrome exists <em>relatively</em> independent of the view controllers that are showing.</p>

<p>Each view controller also knows very little about each-other, so actions that trigger a new view controller are generally done by creating a string route and passing it through the routing system. I've wrote about this pattern in <a href="https://artsy.github.io/blog/2015/08/15/Cocoa-Architecture-Router-Pattern/">Cocoa Architecture: Router Pattern</a>.</p>

<p>Interestingly, if the router cannot route a view controller, it will pass through to a web view. This is why we consider the app a <a href="http://artsy.github.io/blog/2015/08/24/Cocoa-Architecture-Hybrid-Apps/">hybrid app</a>. This pattern means adding new view controllers is extremely easy.</p>

<a name="Introducing.Emission"></a>
<h3>Introducing Emission</h3>

<p>Emission is what we use to contain all of our React Native components. Our flagship app Eigen, can depend on and use without needing to bother with the implementation details of React Native. At it's core, Emission is:</p>

<ul>
<li>A node module.</li>
<li>A CocoaPod.</li>
<li>An iOS App.</li>
</ul>


<a name="The.Node.Module"></a>
<h4>The Node Module</h4>

<p>Emission itself, is a node module. In our case, it is a JavaScript library that exposes 3 JavaScript objects.</p>

<pre><code class="javascript">/* @flow */
'use strict';

import Containers from './lib/containers';
import Components from './lib/components';
import Routes from './lib/relay/routes';

import './lib/relay/config';
import './lib/app_registry';

export default {
  Containers,
  Components,
  Routes,
};
</code></pre>

<p>Another node project can have Emission as a dependency - then can access our <code>Container</code>s, <code>Component</code>s and <code>Route</code>s. A container is a <a href="https://facebook.github.io/relay/docs/api-reference-relay-container.html">Relay container</a>, a component is a <a href="https://facebook.github.io/react/docs/component-api.html">React Component</a> and a Route is a <a href="https://facebook.github.io/relay/docs/guides-routes.html#content">Relay Route</a>.</p>

<p>The thing that's interesting from the integration side, is that each <code>Container</code> is effectively a View Controller that Emission provides to a host application. React Native ignores  the concept of view controllers from the Cocoa world, so we have an <a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Pod/Classes/ViewControllers/ARComponentViewController.m">ARComponentViewController</a> which is subclassed for each exposed <code>Component</code> class.</p>

<a name="The.iOS.App"></a>
<h4>The iOS App</h4>

<p>The iOS app acts as a host target for the CocoaPod, and provides an instance of an <a href="https://github.com/artsy/emission/blob/master/Pod/Classes/Core/AREmission.m">AREmission</a> object to the view controllers using React Native. The app is nothing special, it is the default app that is created using <code>pod lib create</code>. We then <a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Example/Podfile">use CocoaPods</a> to bring in React from inside the <code>node_modules/</code> folder the Emission node module creates.</p>

<p>The <code>AREmission</code> instance is the intermediary between the host-app (<a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Example/Emission/AppDelegate.m#L56">The Emission Example app</a>, or <a href="https://github.com/artsy/eigen/blob/41b00f6fe497de9e902315104089370dea417017/Artsy/App/ARAppDelegate%2BEmission.m">Eigen</a>.) It has an API for handling routing, and passing authentication credentials into the React Native world.</p>

<p>We use the example app to do development inside React Native. As of right now, it is simply a tableview that provides a list of view controllers <a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Example/Emission/AppDelegate.m#L159-L169">that represent an exposed Container</a>. Once you are in the right view controller, you can rely on <a href="http://facebook.github.io/react-native/releases/0.31/docs/debugging.html#automatic-reloading">Hot Reloading</a> to simplify your work.</p>

<a name="The.Pod"></a>
<h4>The Pod</h4>

<p>An important part of working with React Native, is that you can choose to use native code when appropriate. The <a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Emission.podspec">Pod for</a> Emission, created entirely in Objective-C, provides:</p>

<ul>
<li>Communication between React Native and the host app objects via <a href="https://facebook.github.io/react-native/docs/native-modules-ios.html">native modules</a>.</li>
<li><code>UIViewController</code> subclasses for Host apps to consume.</li>
<li>Bridges for existing native views (like our <a href="https://github.com/artsy/extraction/blob/d6a32186f7098eb2ec5d05e2fb5302a8378eff70/Extraction/Classes/ARSwitchView.m">SwitchView</a>) into React Native.</li>
</ul>


<p>The choice of Objective-C is for simplicity, and language stability. Swift is technically an option, but it's not  worth the complications for <a href="https://github.com/artsy/emission/tree/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/Pod/Classes">a few simple objects</a>.</p>

<p>In order to share native views with our host app, Eigen, we created a library to just hold the shared UI components, <a href="https://github.com/artsy/extraction">Extraction</a>. These are <a href="https://github.com/artsy/extraction/tree/d6a32186f7098eb2ec5d05e2fb5302a8378eff70/Extraction/Classes">factored out of Eigen</a>, and into a pod. Emission and Eigen have this as a dependency.</p>

<a name="Pod.Deployment"></a>
<h4>Pod Deployment</h4>

<p>What makes this work well, from the perspective of Eigen is that the React Native comes in atomically. The Podspec <a href="https://github.com/artsy/emission/blob/master/Emission.podspec#L17-L18">references</a> the few native classes, and a single JavaScript file.</p>

<p>This JavaScript file is the bundled version of all our React Native code. It's <a href="https://github.com/artsy/emission/blob/eb9d0f6ca0edd3eb9f07dd9ff3b8499f095bc45b/package.json#L7">updated  by running</a> <code>npm run bundle</code>. This generates both the minified JS, and a source map so that we can transcribe the error reports into the code we write.</p>

<p>Using the CocoaPod, Emission can provide native view controllers that use React Native under the hood. The host app does not need to know the underlying details like <code>npm</code>.</p>

<a name="On.Emission"></a>
<h3>On Emission</h3>

<p>Whether this is a pattern other apps can follow is hard to say, we were in a great position to do this. Our app has view controllers that have very little communication with each other and the host app does not need to bridge large amounts of information.</p>

<p>As ever, our work is open source, and we ensure that anyone can download and run Emission, so if you'd like to understand more, clone <a href="https://github.com/artsy/emission#reactions--emissions">artsy/emission</a> and study the implementation.</p>
]]></content>
  </entry>
  
</feed>
