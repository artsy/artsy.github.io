<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: danger | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/danger/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2017-08-29T15:08:54-04:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Danger]]></title>
    <link href="http://artsy.github.io/blog/2017/06/30/danger-one-oh-again/"/>
    <updated>2017-06-30T00:00:00-04:00</updated>
    <id>http://artsy.github.io/blog/2017/06/30/danger-one-oh-again</id>
    <content type="html"><![CDATA[<p>Danger came out of two needs. One from the needs of a growing dev team working together full-time, and the other from the needs of a completely asymmetric large Open Source project.</p>

<p>A work environment dev team is a complex place. You naturally grow, and to grow safely you add process. Process is a mixed bag, it's a net benefit at the trade-off of individual's time vs team cohesion. You want to grow your team guided by smart applications of process.</p>

<p>On the other hand, working on a large open source project, it's easy to feel overwhelmed at the amount of work that needs to get done on a daily basis. The growth of your OSS team probably doesn't tie to the amount of work that needs to be done. Especially if you're like me, and you don't want to be maintaining OSS as a 2nd full-time job.</p>

<p>So what do you do? Well in a work environment you don't really have a choice, as a team you hold each other to the rules that you set. In OSS, you sacrifice your spare time or you can find time at work, you could stop or you could burn out.</p>

<p>And this is the environment in which the idea of Danger was incubated.</p>

<p>Today mark version 1.0 of the second version of Danger. I'm going to cover what they are, how they continue to grow and what I see their trajectory as.</p>

<!-- more -->


<a name="Why."></a>
<h1>Why?</h1>

<p>Danger came from a need to customise the GitHub workflow for pull requests. In a work context, we wanted to add process like CHANGELOGs and be more thorough about testing. In Open Source, we needed to stop asking the same things to drive-by contributors. Their patches are valuable for sure, but asking for the same changes each time gets tiring. We want to work at a higher level of abstraction.</p>

<p>In both cases you want a way to give instant feedback for things that are "Unit Tests have failed" or "Code could not compile". However, it's hard to give feedback that says "You have not added a CHANGELOG entry in the right format."</p>

<p>Typically CI would only provide a binary: true or false response to the changes for review. We want a more shades of grey.</p>

<a name="What.does.Danger.do."></a>
<h2>What does Danger do?</h2>

<p>Danger acts as a way of creating unit tests at code review level. It gives you the ability to write tests that say: "has this file changed?", "does the contents of new files include this string?", "does the build log include a warning we know is bad news?" then the results of those tests are moved back into the place you're talking about the code.</p>

<p>To do this, you need to be able to create your own rules. Every team has different dynamics, and while it makes sense to offer a set of a set of standard rules that can work across a lot of projects - I'm pretty sure that the needs of the Artsy engineering team is different from the needs of your team.</p>

<p>Danger runs your code, and provides a set of easy to use APIs for you to build these useful culture rules. You write your rules in code, we call these files Dangerfiles. Similar to how a testing framework would give a set of expectations. The general gist is Danger provides access to:</p>

<ul>
<li>Changes from Git</li>
<li>Changes from GitHub/GitLab/BitBucket</li>
<li>Interacting with Danger</li>
</ul>


<p>By making per-project rules with these APIs, you can cover most rote tasks involved in code review. To make it easy for anyone to run Danger on every pull request, Danger was made to run during continuous integration.</p>

<a name="OK..so..2.versions.of.Danger.."></a>
<h1>OK, so "2 versions of Danger"?</h1>

<p>I first implemented Danger in Ruby. Ruby is a great language for building terminal apps, in the iOS community it's the language in which the largest OSS projects are built in. So, as someone used to building apps in that space, it wasn't really a debate what language to work with.</p>

<p>The Ruby build of Danger is now at 5.x with almost 100 releases, it's a solid exploration into code review automation. Ultimately though, I started to feel three main pain-points:</p>

<ul>
<li><p>At Artsy, we moved our mobile team to React Native, and other teams were also consolidating on JavaScript everywhere. It felt weird using a Ruby inside a strictly JS only context.</p></li>
<li><p>Trying to re-create the environment of a PR was tricky from inside the CI. For example most providers are good at about saving on space and bandwidth during a run, and Danger often has to ruin that in order to replicate the PR locally.</p></li>
<li><p>I wanted to explore server-side Dangerfiles. I wouldn't feel comfortable hosting a server that allows anyone to run their own Ruby code. Ruby isn't built with sandboxing in mind.</p></li>
</ul>


<a name="JavaScript"></a>
<h2>JavaScript</h2>

<p>First I explored the idea of having JavaScript based Dangerfiles inside the Ruby version of Danger. I did this by <a href="https://github.com/danger/danger/pull/422">bridging Danger's Ruby objects into a JavaScript context</a> and allowing bi-directional communication between the two. This handled some of the immediate needs, but proved inadequate when working with JavaScript's simple system library and it ignored all other JavaScript tooling.</p>

<p>After enough time, I came to the conclusion that realistically, to use JavaScript properly, you need node modules and npm.</p>

<p>So 10 months ago I decided it was worth starting from scratch and re-created Danger in JavaScript. I had time to consider what I would do differently, and this time I added one key additional restraints on the system: Data can only come from an API.</p>

<p>This constraint negates one of the key problems with running running a Dangerfile on a server - having to have a copy of the code and the PR's environment.</p>

<p>In addition, JavaScript has a much simpler model for evaluating, importing and exporting code and so whitelisting modules and functions can be feasible for a hosted version of Danger.</p>

<center><img src ="/images/danger/danger.png" style="width:50%"></center>


<a name="L1.0.is.my.middle.name"></a>
<h1>1.0 is my middle name</h1>

<p>Any software project used in production should probably be 1.0, but in addition to production use a library needs documentation to be 1.0.</p>

<p>Calling Danger production ready means doing the entire <a href="http://artsy.github.io/blog/2016/07/03/handling-big-projects/">Defensive OSS</a> process: Documentation, Guides, API Reference, Website and Branding.</p>

<p>Once each version of Danger had started to mature to a point that the user-facing aspect stopped changing I started focusing on the documentation engine and website. In both cases, a considerable amount of documentation is generated from the source code of Danger. I'm a big fan of keeping that inside the source code and building documentation sites which import it directly.</p>

<a name="So.what.can.I.do.with.Danger."></a>
<h1>So what can I do with Danger?</h1>

<p>In one way this is a bit like asking, so what can I test with unit tests? Anything, within the scope of: the PR, build artifacts and introspecting the codebase.</p>

<p>I'll cover a quick API overview, then talk about how you can work with these:</p>

<a name="Git"></a>
<h3>Git</h3>

<ul>
<li>What files have been added, removed or changed.</li>
<li>Changes specific to a file.</li>
<li>Looking into Commits.</li>
<li>Exploring the Diff.</li>
</ul>


<a name="GitHub...GitLab...BitBucket"></a>
<h3>GitHub / GitLab / BitBucket</h3>

<ul>
<li>Access to the PR's JSON representation.</li>
<li>Consistent access for PR body, title, author across all platforms.</li>
<li>Util functions for linking to files.</li>
</ul>


<a name="Danger"></a>
<h3>Danger</h3>

<ul>
<li>Handle running other Dangerfiles.</li>
<li>Handles plugin management.</li>
<li>Provides a set of utility functions that would often get used.</li>
</ul>


<a name="Messaging"></a>
<h3>Messaging</h3>

<ul>
<li>Leave warnings, messages and markdown comments.</li>
<li>Leave errors, marking the build as failed.</li>
<li>Post any of the above of the above inside a file.</li>
<li>Create a GitHub review, and use the above messaging.</li>
</ul>


<a name="Plugins"></a>
<h3>Plugins</h3>

<ul>
<li>Infrastructure for shared rules.</li>
<li>Opens up the ability to validate tricky things with an easy API.</li>
</ul>


<p>The API differs between the JS and Ruby version, not drastically - but there are no plugins for Danger JS yet. That's still a bit away.</p>

<a name="OK..got.it."></a>
<h2>OK, got it.</h2>

<p>Let's cover a few examples of the kind of tests can you write.</p>

<a name="Checking.for.changes.to.a.specific.file"></a>
<h4>Checking for changes to a specific file</h4>

<p>Checking for a CHANGELOG. This was the first rule imagined for Danger, I add it to every project.</p>

<p>The first implementation of this rule can just be a check if the file <code>CHANGELOG.md</code> is modified in any PR, that can then be
revised to also check whether there are git changes related to your app. Then documentation, README, tooling updates
don't require an entry. We also check if the PR title says "trivial" and skip the CHANGELOG check.</p>

<p>If you're interested in standardizing on the <a href="http://keepachangelog.com/en/0.3.0/">keepachangelog.com</a> format there is <a href="https://github.com/dblock/danger-changelog">danger-changelog</a>.</p>

<p>Some other examples around this is pinging specific people when a file has changed, or failing if a file that's never meant
to be modified is changed, warning about potential semantic version updates for changes to specific files.</p>

<a name="Checking.the.results.of.command-line.tools"></a>
<h4>Checking the results of command-line tools</h4>

<p>The Artsy developer blog runs both a spell checker, and a prose linter. These report back on files added or
modified during the PR. As someone known for writing loose and quick, having a machine provide some automatic feedback
makes it easy to not waste my reviewers time.</p>

<p>This is done by the <a href="https://github.com/dbgrandi/danger-prose">danger-prose</a> plugin, which wraps both an <a href="https://github.com/lukeapage/node-markdown-spellcheck">npm module</a> and a <a href="https://github.com/amperser/proselint/">python egg</a>.
The plugin handles installing and running the CLI, then converts the output into markdown for github.</p>

<a name="Handling.build.artifacts"></a>
<h4>Handling build artifacts</h4>

<p>If Danger runs after the build process, you can read build logs to provide better feedback. This can range from taking
the results of a test run and posting what has failed (e.g. <a href="https://github.com/orta/danger-junit">danger-junit</a>), to finding specific strings inside
build logs and highlighting them.</p>

<p>In our native iOS app, when a developer accidentally adds code which accesses the network in a test. That is logged out
during the build. Then later, danger will read the logs to find any mentions of this and post it in the comment.</p>

<a name="PR.Metadata"></a>
<h4>PR Metadata</h4>

<p>Every team's workflow is different, but it's pretty common to use a tool other than code review for keeping track of a project's momentum. You can use Danger to warn people that they haven't included a Trello, or JIRA ticket reference on
every PR.</p>

<p>A similar approach could be to warn if someone is sending a PR to a branch other than the preferred branch. This works
well if you use the git-flow model for branches.</p>

<p>We nearly always add a check to see if someone is assigned to a PR, and warn it it's unassigned in front-end projects.</p>

<a name="Using.the.platform.API"></a>
<h4>Using the platform API</h4>

<p>There's no limits here, by using the API from your platform you can perform any sorts of checks. In the Danger repo
we use the GitHub API to note whether someone is in the Danger org, to remind the core team to invite them to the org
after submitting a PR.</p>

<a name="Introducing.Danger"></a>
<h2>Introducing Danger</h2>

<p>OK, maybe that's got you thinking <em>"ah, I know a process I can automate"</em>.</p>

<p>It can be easy to try and jump straight from no Dangerfile to a many-hundred lined complex set of cultural rules. I'd advise against introducing a long list of rules for Danger all at once. In my experience, gradual integration works better. The entire team may have agreed on the changes upfront, but slower adoption has worked better for teams new to working with Danger.</p>

<p>At Artsy we've found that first just integrating Danger with a single simple rule (like checking for a CHANGELOG entry) then starting to introduce them piece-meal from different contributors has made it easier to go from "Ah, we shouldn't do that again" to "Oh, we could make a Danger rule for that" to "Here's the PR".</p>

<a name="Which.Danger.should.I.use."></a>
<h2>Which Danger should I use?</h2>

<p>This definitely depends on the project, there's a longer discussion <a href="http://danger.systems/js/js-vs-ruby.html">on the site</a> too, but here's the main gist:</p>

<ul>
<li><p><strong>Danger Ruby</strong> is more mature, has more features, a solid plugin eco-system and covers more platforms. It's in a great place and is unlikely to have breaking changes from this point onwards.</p></li>
<li><p><strong>Danger JS</strong> has a bigger potential for growth, is "stable enough", you can create plugins and will be able to do things that the Ruby version could not - eventually. Right now it only works with GitHub.</p></li>
</ul>


<a name="Onwards.and.Upwards"></a>
<h2>Onwards and Upwards</h2>

<p>With the JavaScript version of Danger in a great place ready for production, I can start more serious work on <a href="https://github.com/danger/peril#peril">Peril</a>. Peril is a hosted web-service that runs Dangerfiles against GitHub events, see <a href="https://github.com/danger/peril/blob/master/VISION.md">the VISION.md</a>. Those events span from a new user being created, to a new issue on a repo. Peril lets you run your own complex rules across an entire org. This can be a really powerful way to audit and improve entire-company culture.</p>

<p>We started using Peril in Artsy <a href="https://github.com/artsy/reaction-force/pull/184">last week</a>. So it's starting to become a thing internally. It'll be awesome to explore the idea of org-wide rules. I think we're starting with making sure we assign someone on a PR.</p>

<p>So give Danger a shot, and if you're bold. give <a href="https://github.com/danger/peril#peril">Peril</a> a shot.</p>

<hr />

<p>This post uses the CC license image from <a href="https://twitter.com/CloudyConway/status/880426417024114688">this tweet</a> with some changes to make it fit with the design of the blog. Thanks <a href="https://www.patreon.com/vexorian">Vexorian</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Glossary for 2017]]></title>
    <link href="http://artsy.github.io/blog/2016/11/14/JS-Glossary/"/>
    <updated>2016-11-14T12:17:00-05:00</updated>
    <id>http://artsy.github.io/blog/2016/11/14/JS-Glossary</id>
    <content type="html"><![CDATA[<p>Getting to grips with the entire JavaScript ecosystem is a tough job when you're getting started. Coming from the native mobile space, there's a lot to learn. I've spent a few months immersed in the environment now, and can try summerize a lot of topics. This should make it easier to find more information when you need it. This post is semi-opinionated, with links for further reading so you can get a different perspective too.</p>

<p>This post focus specifically on the JavaScript tooling around React Native projects, but is applicable to all JavaScript projects.</p>

<!-- more -->


<p>Lets start with the entire reason we are using JavaScript for mobile in the first place: React and React Native,</p>

<a name="React"></a>
<h1>React</h1>

<a name="React"></a>
<h3>React</h3>

<p>React is a Facebook project which offers a uni-direction Component model that <em>can</em> replace MVC in a front-end application. React was built out of a desire to abstract away a web page's true view hierarchy (called the DOM) so that they could make changes to all of their views and then React would handle finding the differences between view states.</p>

<p>Its model is that you would create a set of Components to encapsulate each part for the state of the page. React makes it easy to make components that are functional in the <a href="https://en.wikipedia.org/wiki/functional_reactive_programming">Functional Reactive Programming</a> sense. They act like a function which takes some specially declared state and it is rendered into HTML.</p>

<p>A component optionally uses a language called <a href="#jsx">JSX</a> to visualise how each component's child components are set up,here's an example of a React component using JSX <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/home/search_bar.js">from Emission, our React Native library</a>:</p>

<pre><code class="js">export default class SearchBar extends React.Component {
  render() {
    return (
      &lt;TouchableWithoutFeedback onPress={this.handleTap.bind(this)}&gt;
        &lt;View style={styles.container}&gt;
          &lt;Image style={styles.searchIcon} source={require('../../../images/SearchButton.png')}/&gt;
          &lt;Text style={styles.text}&gt;Search for artists and artworks...&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/TouchableWithoutFeedback&gt;
    )
  }

  handleTap() {
    Switchboard.presentModalViewController(this, '/search')
  }
}
</code></pre>

<p>By providing a well encapsulated Component model, you can aggressively reduce the amount of redundant code you need to build an application. By not initially writing to the DOM, React can decide what has changed between user actions and that means you have to juggle significantly less <a href="#state">state</a>.</p>

<a name="React.Native"></a>
<h3>React Native</h3>

<p>I came to this conclusion early this year that writing native apps using compiled code is a pain, and it's been amazing to be able to work in React Native in contrast.</p>

<p>React Native is an implementation of React where instead of having it abstract a web page's DOM, it creates a native view hierarchy. In the case of iOS that is a UIView hierarchy. Note that it does not handle View Controllers. The MVC model from Apple's Cocoa framework does not directly map into React Natives. I've wrote about how we <a href="http://artsy.github.io/blog/2016/08/24/On-Emission/">bridge that gap earlier</a>.</p>

<p>React Native is cross platform. You write JavaScript like above, which React Native transforms into a native view hierarchy. That view hierarchy could be on a Samsung TV, a Windows phone or Android instead.</p>

<p>It's a smart move, most "Make apps in JS" try to have a native-like experience where they replicate the platform's UI in HTML. However, this technique tends to feel unnatural very easily. If I showed you our app, you could not distinguish between a view controller in React Native, Swift or Objective-C.</p>

<a name="App.State"></a>
<h3>App State</h3>

<p>Think of every variable inside your application, that is your application's state. You could not make an app worth using without state. In MVC, MVVM, VIPER and other native patterns, there is no consistent way to handle changes in those variables. React uses a common state pattern though the use of specific terminology: "<a href="#props">props</a>", "<a href="#context">context</a>" and "<a href="#state-again">state</a>".</p>

<p>Yes, the "state" and "state" thing is a little confusing, we'll get to it.</p>

<a name="Props"></a>
<h3>Props</h3>

<p>Props are chunks of app state that are passed into your component from a parent component. In <a href="#jsx">JSX</a> this is represented as an XML attribute.</p>

<p>Let's check out <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/artist/header.js">an example</a>:</p>

<pre><code class="js">export default class Header extends React.Component {
  [...]
  render() {
    return (
        &lt;View style={styles.followButton}&gt;
            &lt;InvertedButton text={this.state.following ? 'Following' : 'Follow'}
                            selected={this.state.following}
                            onPress={this.handleFollowChange} /&gt;
        &lt;/View&gt;
    )
  }
}
</code></pre>

<p>See the <code>InvertedButton</code> component, it has three <code>props</code> being passed in: <code>text</code>, <code>selected</code> and <code>onPress</code>. If any of those props were to change the entire <code>InvertedButton</code> component would be re-rendered to the native view hierarchy. These <code>props</code> are the key to passing data downwards through your hierarchy. Note: you cannot access the parent component (without passing it in as a prop.)</p>

<p>You should therefore consider <code>props</code> as immutable bits of app state relevant to the component it's being passed into.</p>

<a name="State-again"></a>
<h3>State-again</h3>

<p>A component also has a <code>state</code> attribute. The key to understanding the difference between <code>props</code> and <code>state</code> is: <code>state</code> is something controlled within that component that can change - <code>props</code> do not.</p>

<p>The above example is a pretty good example of this, when this component is first added to the hierarchy, we send a networking request to get whether you are following something or not. The parent component (<code>Header</code>) does not need to update when we know whether you are following or not, but the <code>InvertedButton</code> does. So, it is <code>state</code> for the parent, but a <code>prop</code> for the <code>InvertedButton</code>. This means changing the state for <code>following</code> will only cause a re-render in the button.</p>

<p>So state is something which changes within a component, which <em>could</em> be used as <code>props</code> for it's children. Examples of this are around handling animation progress, whether you're following something, selection indices and any kind of networking which we do outside of <a href="#relay">Relay</a>.</p>

<p>If you'd like to read more, there is a much deeper explanation in <a href="https://github.com/uberVU/react-guide/blob/master/props-vs-state.md#props-vs-state">uberVU/react-guide</a></p>

<a name="Context"></a>
<h3>Context</h3>

<p><a href="https://facebook.github.io/react/docs/context.html">The docs</a> are pretty specific about context:</p>

<blockquote><p>If you aren't an experienced React developer, don't use context. There is usually a better way to implement functionality just using props and state.</p></blockquote>

<p>Seems to be something that you should only be using in really, really specific places. If you need it, you don't need this glossary.</p>

<a name="JSX"></a>
<h3>JSX</h3>

<p>As we'll find out later, modern JavaScript is a collection of different ideas, and using <a href="#babel">Babel</a> - you can add them at will into your projects. JSX is one such feature, it is a way of describing nested data using XML-like syntax. These are used inside React's render function to express a component's children and their <a href="#props">props</a>.</p>

<p>Under the hood, JSX is quite simple, with code looking like this:</p>

<pre><code class="js">const element = (
  &lt;h1 className="greeting"&gt;
    Hello, world!
  &lt;/h1&gt;
);
</code></pre>

<p>Turning into</p>

<pre><code class="js">const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
</code></pre>

<p>Where <code>createElement</code> comes from the React <a href="#module">module</a>. You can find out more in <a href="https://facebook.github.io/react/docs/introducing-jsx.html">the React docs</a></p>

<a name="Libraries"></a>
<h1>Libraries</h1>

<a name="GraphQL"></a>
<h3>GraphQL</h3>

<p>TLDR: An API format for requesting only the data you want, and getting back just that.</p>

<p>If you want the longer explanation, I wrote a <a href="/blog/2016/06/19/graphql-for-mobile/">blog post on it</a>.</p>

<a name="Relay"></a>
<h3>Relay</h3>

<p>Relay is what makes working in our React Native app shine. It is a library that allows a component to describe small chunks of a networking request it would need to render. Relay would then look through your component hierarchy, take all the networking fragments, make a single GraphQL request for all the data. Once it has the data, Relay passes in the response as <a href="#props">props</a> to all of the components in the tree.</p>

<p>This means you can throw away a significant amount of glue code.</p>

<a name="Redux"></a>
<h3>Redux</h3>

<p>Redux is a state management pattern, it builds on top of React's "state is only passed down" concept, and creates a single way to handle triggering changes to your state. I'm afraid I don't have any experience with it, so I can't provide much context. I feel like <a href="http://www.youhavetolearncomputers.com/blog/2015/9/15/a-conceptual-overview-of-redux-or-how-i-fell-in-love-with-a-javascript-state-container">this post</a> covers it well though.</p>

<a name="Tooling"></a>
<h1>Tooling</h1>

<a name="Node"></a>
<h3>Node</h3>

<p>Node is the JavaScript implementation from Google's Chrome (called v8) with an expanded API for doing useful systems tooling. It is a pretty recent creation, so it started off with an entirely asynchronous API for any potentially blocking code.</p>

<p>For web developers this was a big boon, you could share code between the browser and the server. The non-blocking API meant it was much easier to write faster servers, and there are lots of big companies putting a lot of time and money into improving the speed of JavaScript every day.</p>

<p>Node has an interesting history of ownership, I won't cover it here, but <a href="http://anandmanisankar.com/posts/nodejs-iojs-why-the-fork/">this link</a> provides some context.</p>

<a name="NPM"></a>
<h3>NPM</h3>

<p>NPM is the Node Package Manager. It is shipped with node, but it is a completely different project and team. NPM the project is ran by a private company.</p>

<p>NPM is one of the first dependency managers to offer the ability to install multiple versions of the same library inside your app. This contributes considerably to the issue of the number of dependencies inside any app's ecosystem.</p>

<p>JavaScript people will always complain about NPM, but people will always complain about their build tools. Dependency Manager's especially. From an outsider's view, it nearly always does what you expect, has a great team behind it and has more available dependencies than any other.</p>

<p>NPM works with a <code>Package.json</code> file as the key file to represent all the different dependencies, version, authors and misc project metadata.</p>

<a name="Yarn"></a>
<h3>Yarn</h3>

<p>Yarn is a NPM replacement (ish) by Facebook. It's very new. It solves three problems, which were particularly annoying to me personally.</p>

<ul>
<li>It flattens dependencies - this means that you're less likely to have multiple versions of the same library in your app.</li>
<li>It uses a lockfile by default - this means that everyone on your team gets the same build, instead of maybe getting it.</li>
<li>It is significantly faster.</li>
</ul>


<p>It uses the NPM infrastructure for downloading <a href="#modules">modules</a>, and works with the exact same <code>Package.json</code>. I moved most of our projects to it.</p>

<a name="Babel"></a>
<h3>Babel</h3>

<p>I mentioned JSX a few times above. JSX is not a part of JavaScript, it is transpiled from your source code (as XML-like code) into real JavaScript. The tool that does this is Babel.</p>

<p>Babel is a generic JavaScript transpilation engine. It does not provide any translation by default, but instead offers a plugin system for others to hook in their own transpilation steps. This becomes important because a lot of JavaScript features have staggered releases between browsers and you can't always guarantee each JavaScript runtime will have the features you want to use.</p>

<p>Babel's plugins can be configured inside your <code>Package.json</code>. To ship your code to the world, you then create a script of some sort to convert your source code into "olde world" JavaScript via Babel.</p>

<p>In the case of a react-native project, Babel is happening behind the scenes.</p>

<a name="Webpack"></a>
<h3>Webpack</h3>

<p>A JavaScript source code &amp; resource package manager. It can be easy to confuse Babel + Webpack, so in simple:</p>

<ul>
<li>Babel will directly transform your source code file by file</li>
<li>Webpack will take source code and merge it all into one file</li>
</ul>


<p>They work at different scopes. Webpack is mainly a web front-end tool, and isn't used in React Native. However, you'll come across it, and it's better to know the scope of it's domain.</p>

<a name="ESLint"></a>
<h3>ESLint</h3>

<p>How can you be sure your syntax is correct? JavaScript has a really powerful and extensible linter called ESLint. It parses your JavaScript and offers warnings and errors around your syntax. You can use this to provide a consistent codebase, or in my case, to be lazy with your formatting. Fixing a lot of issues is one command away. I have <a href="https://artsy.github.io/blog/2016/08/15/vscode/">my editor</a> auto indent using ESLint every time I press save.</p>

<a name="Development"></a>
<h1>Development</h1>

<a name="Live.Reload"></a>
<h3>Live Reload</h3>

<p>This is a common feature in JavaScript tooling. If you press save in a source file then some action is taken. Live Reloading tends to be a more blunt action, for example reloading the current view from scratch, or running all of the tests related to the file.</p>

<a name="Hot-Reloading"></a>
<h3>Hot-Reloading</h3>

<p>Hot Reloading is more rare, because it's significantly harder. Hot Reloading for React projects is injecting new functions into the running application, and keeping it in the same state.</p>

<p>For example if you had a filled-in form on your screen, you could make styling changes inside your source file and the text inside the form would not change. Hot reloading is amazing.</p>

<a name="Haste.Map"></a>
<h3>Haste Map</h3>

<p>Part of what makes React Native support Hot Reloading, and allows <a href="#jest">Jest</a> to understand changes for testing is by using a Haste Map. A Haste Map is a dependency resolver for JavaScript, looking through every function to know how it connects to every other function within the JavaScript project.</p>

<p>With the dependencies mapped, it becomes possible to know what functions would need replacing or testing when you press save after writing some changes. This is why it takes a bit of time to start up a React Native project.</p>

<p>The public API is deprecated, you shouldn't use it in your projects, but the <a href="https://github.com/facebookarchive/node-haste/tree/master#node-haste-">old README is still around</a>.</p>

<a name="Testing"></a>
<h1>Testing</h1>

<a name="Jest"></a>
<h3>Jest</h3>

<p>Facebook have their own test runner called Jest. It builds on <a href="https://jasmine.github.io">Jasmine</a>, and offers a few features that kick ass for me:</p>

<ul>
<li>Re-runs failing tests first</li>
<li>Assumes all tests unrelated to changes are green and doesn't run them</li>
<li>Watch mode that works reliably</li>
</ul>


<p>I miss these features when I'm not in a Jest project.</p>

<a name="Jest.Snapshots"></a>
<h3>Jest Snapshots</h3>

<p>Jest has a feature called Jest Snapshots, that allows you to take "snapshots" of JavaScript objects, and then verify they are they are the same as they were last time. In iOS we <a href="https://www.objc.io/issues/15-testing/snapshot-testing/">used visual snapshot</a> testing a lot.</p>

<a name="VSCode-Jest"></a>
<h3>VSCode-Jest</h3>

<p>I created a project to auto-run Jest inside projects that use it as a test runner when using Visual Studio Code: <a href="https://github.com/orta/vscode-jest">vscode-jest</a>. I've wrote about our usage of VS Code <a href="https://artsy.github.io/blog/2016/08/15/vscode/">on this blog series</a> also.</p>

<a name="JavaScript.the.Language"></a>
<h1>JavaScript the Language</h1>

<p>I'm always told that JavaScript was created in 10 days, which is a cute anecdote, but JavaScript has evolved for the next 21 years. The JavaScript you wrote 10 years ago would still run, however modern JavaScript is an amazing and expressive programming language once you start using modern features.</p>

<p>Sometimes these features aren't available in <a href="#node">node</a>, or your browser's JavaScript engine, you can work around this by using a transpiler, which takes your source code and backports the features you are using to an older version of JavaScript.</p>

<a name="ES6"></a>
<h3>ES6</h3>

<p>JavaScript is run by a committee. Around the time that people were starting to talk about HTML5 and CSS3, work was started on a new specification for JavaScript called ECMAScript 6.</p>

<p>ES6 represents the first point at which JavaScript really started to take a lot of the best features from transpile to JavaScript languages like CoffeeScript. Making it feasible for larger systems programming to be possible in vanilla JavaScript.</p>

<a name="ES2016"></a>
<h3>ES2016</h3>

<p>It took forever for <a href="#es6">ES6</a> to come out, and every time they created / amended a specification there were multiple implementations of the specification available for transpiling via <a href="#babel">babel</a>. This I can imagine was frustrating for developers wanting to use new features, and specification authors trying to put out documentation for discussion as a work in progress. This happened a lot <a href="#promises">with the Promises</a> API.</p>

<p>To fix this they opted to discuss specification features on a year basis. So that specifications could be smaller and more focused, instead of major multi-year projects. Quite a SemVer jump from 6 to 2016.</p>

<a name="Stages"></a>
<h3>Stages</h3>

<p>Turns out that didn't work out too well, so the terminology changed again. The change is mainly to set expectations between the Specification authors and developers transpiling those specifications into their apps.</p>

<p>Now an ECMAScript language improvement specification moves through a series of stages, depending on their maturity. I <a href="https://twitter.com/logicoder/status/799919558429736960">believe starting</a> at 0, and working up to 4. 0 Idea, 1 Proposal, 2 Draft, 3 Accepted and 4 Done.</p>

<p>So a ECMAScript Stage 0 feature is going to be really new, if you're using it via a transpiler then you should expect a lot of potential API changes and code churn. The higher the number, the longer the spec has been discussed, and the more likely for the code you're transpiling to be the vanilla JavaScript code in time.</p>

<p>The committee who discussed these improvements are the <a href="http://ecma-international.org/memento/TC39.htm">TC39</a> committee, the cool bit is that you can see <a href="https://github.com/tc39">all the proposals</a> as individual GitHub repos so it's convenient to browse.</p>

<a name="Modules...Imports"></a>
<h3>Modules / Imports</h3>

<p>A modules is the terminology for a group of JavaScript code. Terminology can get confusing, as the import structure for a library is very similar to importing a local file.</p>

<p>You can import a module using syntax like <code>import { thin, other } from "thingy"</code>. Here's some examples <a href="https://github.com/artsy/emission/blob/master/lib/components/artist/shows/show.js#L4-L9">from our project</a>:</p>

<pre><code class="js">// Import modules
import Relay from 'react-relay'
import React from 'react'
// Import two items from the react-native module 
import { View, TouchableWithoutFeedback } from 'react-native'

// Import the default class from a local file
import ImageView from '../../opaque_image_view'
import SwitchBoard from '../../../native_modules/switch_board'
</code></pre>

<p>An import can either have <a href="https://github.com/danger/danger-js/blob/61557ac7b6de37ef9a7e4a1aa0c0cbe0bd00977d/source/ci_source/Fake.js#L6">a default export</a>, or a set of <a href="https://github.com/artsy/Mitosis/blob/0c1d73055122bd61559df3b1a2913cf4e272b4ed/source/bot/artsy-api.js#L31-L94">exportable function/objects</a>.</p>

<p>You might see an import like <code>const _ = require("underscore")</code> around the internet, this is an older format for packaging JavaScript called <a href="https://www.wikiwand.com/en/CommonJS">CommonJS</a>. It was replaced by the <code>import</code> statements above because you can make guarantees about the individual items exported between module boundaries. This is interesting because of <a href="#tree-shaking">tree-shaking</a>, which we'll get to later.</p>

<a name="Classes"></a>
<h3>Classes</h3>

<p>Modern JavaScript has classes introduced in <a href="#es6">es6</a>, this means that instead of writing something like:</p>

<pre><code class="js">const danger = {
  name: "Danger",
  hello: function () {
    console.log("Hi!")
  }
}

danger.hello();
</code></pre>

<p>Instead you could write:</p>

<pre><code class="js">class Person {
  constructor(name) {
    this.name = name
  }
  hello() {
    console.log("Hi!")
  }
}

const danger = new Person("danger")
danger.hello()
</code></pre>

<p>Classes provide the option of doing object-oriented programming, which is still a solid way to write code. Classes provide a simple tool for making interfaces, which is really useful when you're working to the <a href="http://www.amazon.com/gp/product/0201633612?ie=UTF8&amp;camp=213733&amp;creative=393185&amp;creativeASIN=0201633612&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=5S2XB3C32NLP7IVQ">Gang of Four</a> principals:</p>

<blockquote><p>“Program to an interface, not an implementation,” and “favor object composition over class inheritance.”</p></blockquote>

<a name="Prototypical"></a>
<h3>Prototypical</h3>

<p>So, classes - it took 20ish years before they happened? Before that JavaScript was basically only a prototype-based language. This meant you created "objects" but that they were just effectively just key-value stores, and you used functions to do everything else.</p>

<p>The language is a great fit for functional programming, I ended up building <a href="https://github.com/artsy/Mitosis/">an Artsy chat bot</a> using only functions by accident. Really, a few days into it when I started looking for an example class to show in this post I realised I didn't have one. Whereas in Danger I do almost exclusive OOP in JavaScript, sometimes the project fits the paradigm too.</p>

<p>A really good, and highly opinionated post on the values of prototypical/functional programming in JavaScript is <a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3#.knm7xb7zr">The Two Pillars of JavaScript</a> - I agree with a lot of it.</p>

<a name="Mutablilty"></a>
<h3>Mutablilty</h3>

<p>JavaScript has had a keyword <code>var</code> to indicate a variable forever. You should basically never use this. I've never written one this year, except by accident. It's a keyword that has a really confusing scope, leading to odd bugs. <a href="#es6">ES6</a> brought two replacements, both of which will give you a little bit of cognitive dissonance if you have a lot of Swift experience.</p>

<p><code>let</code> - the replacement for <code>var</code>, this is a <em>mutable</em> variable, you can replace the value of a <code>let</code>. The scope of a <code>let</code> is exactly what you think from every other programming language.
<code>const</code> - this is a <code>let</code> that won't allow you to change the <em>value</em>. So it creates a mutable object (all JS objects are mutable) but you cannot replace the object from the initial assignment.</p>

<a name="This"></a>
<h3>This</h3>

<p>The keyword <code>this</code> is a tricky one. It is confusing because <code>this</code> gets assigned to the object that invokes the function where you use <code>this</code>.</p>

<p>It's confusing because you may have a function inside a class, and would expect <code>this</code> to be the instance to which the function is attached to, but it very easily could not be. For <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/artist/articles/article.js#L11-L22">example</a>:</p>

<pre><code class="js">class Article extends React.Component {
  handleTap() {
    SwitchBoard.presentNavigationViewController(this, this.props.article.href)
  }

  render() {
    [...]
    return (
      &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback onPress={this.handleTap}&gt;
</code></pre>

<p>In the above example <code>this</code> inside <code>handleTap</code> does not refer to the instance of Article. Tricky right?</p>

<p>There are two "easy" fixes, <a href="http://exploringjs.com/es6/ch_arrow-functions.html">using arrow functions</a> instead if normal functions:</p>

<pre><code class="js">class Article extends React.Component {
  handleTap = () =&gt; {
    SwitchBoard.presentNavigationViewController(this, this.props.article.href)
  }
  [...]
</code></pre>

<p>Or you can use the <code>bind</code> function to ensure that <code>this</code> inside the function is what you want it to be.</p>

<pre><code class="js">class Article extends React.Component {
  [...]

  render() {
    [...]
    return (
      &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback onPress={this.handleTap.bind(this)}&gt;
</code></pre>

<p>This is a great in-depth explanation of the way it works: <a href="https://toddmotto.com/understanding-the-this-keyword-in-javascript/">Understanding the “this” keyword in JavaScript</a>.</p>

<a name="Strict.Mode"></a>
<h3>Strict Mode</h3>

<p>Introduced in ECMAScript 5.1, it provides a way to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">opt-in to more errors</a> inside the JavaScript runtime. As you're likely to be using both a linter and a transpiler to keep your source clean, I'm less worried about including it on every page.</p>

<a name="Destructuring"></a>
<h3>Destructuring</h3>

<p>Object destructuring is one of those things that saves a little bit of code all the time. It's especially useful given the amount of time you spend passing around plain old JavaScript objects. This is something that CoffeeScript took from Ruby:</p>

<pre><code class="js">&gt; const [orta, danger] = [33, 23]
undefined
&gt; danger
23
&gt; orta
33
</code></pre>

<p>or for an Object</p>

<pre><code>&gt; const user = { name: "Danger", age: 27 }
undefined
&gt; const { name,  age }  = user
undefined
&gt; name
'Danger'
&gt; age
27
</code></pre>

<p>This makes it really easy to pull out subsets of existing objects and set them as variables.</p>

<a name="Arrow.Functions"></a>
<h3>Arrow Functions</h3>

<p>In JavaScript a function has always looked like:</p>

<pre><code class="js">function(arg1, arg2) {
  [...]
}
</code></pre>

<p>This gets frustrating when you're doing functional-style programming, where you use closures for mapping, filtering and others. So instead <a href="#es6">ES6</a> introduced terser ways of doing this. So I'm going to write the same function multiple times:</p>

<pre><code class="js">// The way it's always been
function (lhs, rhs) {
    return lhs.order &gt; rhs.order
}

// An arrow function version
(lhs, rhs) =&gt; {
    return lhs.order &gt; rhs.order
}

// An implicit return, and no braced one-liner arrow function
(lhs, rhs) =&gt; lhs.order &gt; rhs.order 
</code></pre>

<a name="Promises"></a>
<h3>Promises</h3>

<p><a href="#node">Node</a> is renowned for having a non-blocking API from day one. The way they worked around this is by using callbacks everywhere. This can work out pretty well, but eventually maintaining and controlling your callbacks turns into it's own problem. This can be extra tricky around handing errors.</p>

<p>One way to fix this is to have a Promise API, Promises offer consistent ways to handle errors wand callback chaining.</p>

<p>JavaScript now has a built-in a Promise API, this means every library can work to one API when handling any kind of asynchronous task. I'm not sure what ECMA Specification brought it in. This makes it really easy to make consistent code between libraries. However, more importantly, it makes it possible to have async/await.</p>

<a name="Async.Await"></a>
<h3>Async/Await</h3>

<p>Once Promises were in, then a language construct could be created for using them elegantly. They work by declaring the entire function to be an <code>async</code> function. An async function is a function which pretends to be synchronous, but behind the scenes is waiting for specific promises to resolve asynchronously.</p>

<p>There are a few rules for an <code>async</code> function:</p>

<ul>
<li>You cannot use <code>await</code> inside a function that has not been declared <code>async</code>.</li>
<li>Anything you do return will be implicitly wrapped in a Promise</li>
<li>Non-async functions can just handle the promise an <code>async</code> function returns</li>
</ul>


<p>So, a typical <code>async</code> function</p>

<pre><code class="js">  async getReviewInfo() : Promise&lt;any&gt; {              // this function will do async
    const details = await this.getPullRequestInfo()   // wait for the promise in getPullRequestInfo to resolve 
    return await details.json()                       // wait for the promise in json to resolve
  }                                                   // return the json
</code></pre>

<p>You aren't always given a promise to work with as not all APIs support promises and callbacks, wrapping a callback function is pretty simple:</p>

<pre><code class="js">  readFile(path: String): Promise&lt;string&gt; {                       // returns a promise with a string
    return new Promise((resolve: any, reject: any) =&gt; {           // create a new promise, with 2 callbacks
      fs.readFile(path, "utf8", (err: Error, data: string) =&gt; {   // do the work
        if (err) { return reject(err) }                           // did it fail? reject the promise
        resolve(data)                                             // did it pass? resolve the promise
      })
    })
  }
</code></pre>

<p>The <code>await</code> part of an <code>async</code> function using <code>await readFile</code> will now wait on the synchronous execution until the promise has resolved. This makes complicated code look very simple.</p>

<a name="Tree.Shaking"></a>
<h3>Tree Shaking</h3>

<p>All development ecosystems have trade-offs which shape their culture. For web developers reducing the amount of JavaScript they send to a client is an easy, and vital part of their day job. This started with minifying their source code, e.g. reducing the number of characters but having the same behavior.</p>

<p>The current state of the art is tree-shaking, wherein you can know what functions are unused and remove those from the source code before shipping the code to a client. A <a href="#haste-map">haste-map</a> is one way to handle these dependencies, but it's not the only one. <a href="http://rollupjs.org/">Rollup</a> is considered the de-facto ruler of the space, but it is in <a href="#babel">babel</a> and <a href="#babel">webpack</a> also.</p>

<p>Does this affect you if you're using React Native? Not really, but it's an interesting part of the ecosystem you should be aware of.</p>

<a name="Types"></a>
<h1>Types</h1>

<p>Types can provide an amazing developer experience, as an editor can understand the shape of all the object's inside your project. This can make it possible to build rich refactoring, static analysis or auto-complete experiences without relying on a runtime.</p>

<p>For JavaScript there are two main ways to use types. <a href="#flow">Flow</a> and <a href="#typescript">TypeScript</a>. Both are amazing choices for building non-trivial applications. IMO, these two projects are what makes JavaScript a real systems language.</p>

<p>Both take the approach of providing an optional typing system. This means you can choose to add types to existing applications bit by bit. By doing that you can easily add either to an existing project and progressively add types to unstructured data.</p>

<a name="Interfaces"></a>
<h3>Interfaces</h3>

<p>As both <a href="#flow">Flow</a> and <a href="#typescript">TypeScript</a> interact with JavaScript, the mindset for applying types is through Interfaces. This is very similar to programming with protocols, where you only care about the responsibilities  of an object - not the specific type. Here is a Flow interface from DangerJS:</p>

<pre><code class="js">/** An API representation for a Code Review site */
export interface Platform {
  /** Mainly for logging and error reporting */
  name: string;
  /** Used internally for getting PR/Repo metadata */
  ciSource: CISource;
  /** Pulls in the Code Review Metadata for inspection */
  getReviewInfo: () =&gt; Promise&lt;any&gt;;
  /** Pulls in the Code Review Diff, and offers a succinct user-API for it */
  getReviewDiff: () =&gt; Promise&lt;GitDSL&gt;;
  /** Creates a comment on the PR */
  createComment: (body: string) =&gt; Promise&lt;?Comment&gt;;
  [...]
}
</code></pre>

<p>This interface defines the shape of an object, e.g. what functions/properties it will it have. Using interfaces means that you can expose the least amount of about an object, but you can be certain that if someone refactors the object and changes any interface properties - it provide errors.</p>

<a name="Flow"></a>
<h3>Flow</h3>

<p><a href="https://flowtype.org">Flow</a> is a fascinating tool that infers types through-out your codebase. Our React Native uses a lot of Flow, we have a lot of <a href="#eslint">linter rules</a> for it too, so instead of writing a function like:</p>

<pre><code class="js">function getPlatformForEnv(env, source) {
return [...]
}
</code></pre>

<p>We would write it like this:</p>

<pre><code class="js">function getPlatformForEnv(env: Env, source: CISource): ?Platform {
return [...]
}
</code></pre>

<p>Wherein we now have interfaces for our arguments and the return value of the function. This means better error message from Flow, and better auto-complete in your editor.</p>

<a name="TypeScript"></a>
<h3>TypeScript</h3>

<p>TypeScript is a typed language that compiles JavaScript by Microsoft. It's awesome, it has all of the advantages that I talked about with Flow and a lot more. With TypeScript you can get a much more consistent build environment (you are not picking and choosing different features of ES6) as Microsoft implement all of it into TypeScript.</p>

<p>We opted to go for JS + Flow for Artsy's React Native mainly because we could incrementally add types, and you can find a lot more examples of JavaScript on the internet. It also is the way in which React Native is built, so you get the ecosystem advantage.</p>

<p>That said, if we start a new React Native from scratch project, I would pitch that we should use TypeScript after my experiences with <a href="https://github.com/Microsoft/vscode/pull/12628">making PRs</a> to VS Code. TypeScript feels more comprehensive, I got better error messages and VS Code is very well optimised for working in TypeScript projects.</p>

<a name="Typings.Flow-Typed"></a>
<h3>Typings/Flow-Typed</h3>

<p>Shockingly, not all JavaScript <a href="#modules">modules</a> ship with a typed interface for others. This makes it a pain to work with any code outside your perfectly crafted/typed codebase. This isn't optimal, especially in JavaScript where you rely on so many external libraries.</p>

<p>Meaning that you can either look up the function definitions in their individual docs, or you can read through the source. This breaks your programming flow.</p>

<p>Both TypeScript and Flow offer a tool to provide external definitions for their libraries. For typescript that is <a href="https://github.com/typings/typings">typings</a> and for Flow, <a href="https://github.com/flowtype/flow-typed/">flow-typed</a>. These tools pull into your project definition files that tell TypeScript/Flow what each module's input/outputs are shaped like, and provides inline documentation for them.</p>

<p>Flow-Typed is new, so it's not really got many definitions at all. Typings on the other hand has quite a lot, so in our React Native we use typings to get auto-complete for our libraries.</p>

<a name="JavaScript.Fatigue"></a>
<h3>JavaScript Fatigue</h3>

<p>So that's my glossary, there's a lot of interesting projects out in the JS world.</p>

<p>They have a term "<a href="http://www.confluentforms.com/2016/01/javascript-churn-technology-investment-effect.html">JavaScript fatigue</a>" which represents the concept of the churn in choosing and learning from so many projects. This is very real, which is something we're taking into account. Given the amount of flexibility in the ecosystem, it's really easy to create anything you want. If I wanted to implement a simplified version of Swift's guard function for our JavaScript, I could probably do it in about 2 days using a Babel plugin, then we can opt-in on any project we want.</p>

<p>This can make it easy to freeze and flip the table, but it also makes JavaScript a weird, kind of ideal, primordial soup where some <em>extremely</em> interesting ideas come out. It's your job to use your smarts to decide which are the ideas which will evolve further, then help them stablize and mature.</p>

<script>
// Ain't optimal, but it does it for now, need to figure a better way in the future.
$("a[name]").each(function(i, el){
  var $el = $(el)
  $el.attr("name", $el.attr("name").toLowerCase().replace(".", "-"))
})
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using VS Code for JavaScript]]></title>
    <link href="http://artsy.github.io/blog/2016/08/15/vscode/"/>
    <updated>2016-08-15T22:17:00-04:00</updated>
    <id>http://artsy.github.io/blog/2016/08/15/vscode</id>
    <content type="html"><![CDATA[<center>
 <img src="/images/vscode/vscode_logo_artsy.svg" style="width:300px;">
</center>


<p>I'm an old school TextMate user, who has also been using Xcode for the last decade. These two sit at a very opposite ends of an "editor" spectrum.</p>

<p>TextMate is extremely bare bones at the core, but introduced the idea of bundles as plugins. Making it really easy for others to build their own plugins for their own contexts. Xcode on the other-hand includes a 3D scene editor, the best interface builder I've seen, super rich debugging tools and close to zero support for improving it yourself.</p>

<p>As we agreed on moving to React Native, we needed to decide what the team should use for <a href="https://github.com/artsy/emission/blob/master/docs/vscode.md">working in that environment</a>. After experimentation with many editors, we decided on Microsoft's <a href="https://code.visualstudio.com/">Visual Studio Code</a>.</p>

<p>We wanted to keep a lot of the best features from Xcode, while working in a completely JavaScript environment. For example: debuggers, inline errors, auto-complete, symbol mapping and to ideally have them all inside a single editor.</p>

<p>Let's dig into the principals of how Visual Studio Code works, what makes it a better option for us, and what parts of it really shine.</p>

<!-- more -->


<hr />

<a name="What.is.Visual.Studio.Code."></a>
<h3>What is Visual Studio Code?</h3>

<p>Visual Studio Code (VS Code) is <em>yet another</em>, JavaScript-based text editor. It's built atop of GitHub's <a href="http://electron.atom.io">Electron</a>. Electron is a framework for writing native apps as easy as building websites. It started as a web component for some Microsoft web-service, and eventually evolved into a fully-fledged text editor.</p>

<a name="IDE.-.Editor.hybrid"></a>
<h4>IDE - Editor hybrid</h4>

<p>Visual Studio Code (VS Code) believes that the sweet-spot between and IDE and a plain Text Editor, is somewhere a little bit closer to the IDE side.</p>

<p></div></div><a href='/images/vscode/editors.png'><img src="/images/vscode/editors.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>This means instead of the Text-Editor style folder based approach, VS Code expects to set up a project structure per-project to start supporting from of the more useful IDE-like features.</p>

<p>It supports TextMate style plugins (called Extensions) through a controlled, but expanding <a href="https://code.visualstudio.com/docs/extensions/overview">extension API</a>. The extension API work takes an <a href="https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html">Apple-like</a> approach to ensuring stability by having all extensions run outside of the host process. <a href="https://code.visualstudio.com/docs/extensions/our-approach">This approach</a> ensures any extension crash does not take down the editor.</p>

<p>It's also smart about deciding when to load an extension, for example, my <a href="https://marketplace.visualstudio.com/items?itemName=Orta.vscode-danger">Danger</a> extension will <a href="https://github.com/orta/vscode-danger/blob/a21ccc101b2b1c1be595b10565bca9c88242fb6f/package.json#L18-L20">only load</a> if there is a <code>Dangerfile</code> in the root of the workspace.</p>

<p>These two approaches to extensions are specifically aimed at <a href="https://discuss.atom.io/t/why-is-atom-so-slow/11376">addressing issues</a> seen inside Atom, where any user actions can be / are blocked by extensions, and extensions have full-reign to make any change they want. Even on my Mac Pro, there is a noticable lag. I initially assumed this was the "JavaScript tax" for all Electron apps, but VS Code is fast.</p>

<a name="Making.Intellisense"></a>
<h3>Making Intellisense</h3>

<p>By default a JavaScript project does not have a way to provide auto-completion, or in VS Code's terminology: Intellisense. Trying to make auto-complete based on a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> can only get you so far, because it has to be wary against functions with side-effects. Other alternatives are to build an <a href="http://jointjs.com/demos/javascript-ast">AST</a> from the code, and then introspect that.</p>

<p>In Xcode the auto-complete tools are powered by the type systems of Objective-C and Swift. This means that you can know the structure of an object, without having to dig inside it, potentially breaking it in the process. Vanilla JavaScript does not have a type system. There are a few root classes though: String, Object, Number etc.</p>

<p>To work around this problem, VS Code uses <a href="http://www.typescriptlang.org">TypeScript</a> behind the scenes. TypeScript is a language that compiles down to JavaScript which provides a typing structure on top of JavaScript. This is a similar approach to how <a href="https://flowtype.org">Flow works</a> too, which is the language <a href="https://github.com/artsy/emission/pull/220">we write React Native</a> in.</p>

<p>This can work out really well for your own classes if you are declaring your types, but the npm ecosystem is <em>full</em> of untyped JavaScript, and a lot of your work is about sitting atop those abstractions. The fix for this is offered via <a href="http://definitelytyped.org">DefinitelyTyped</a> which provides type definitions for popular npm modules. For example here is <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/redux/redux.d.ts">one for Redux</a> - these act like <a href="https://github.com/artsy/eigen/blob/master/Artsy/App/ARSwitchBoard.h">header files in Objective-C</a> - offering inline documentation, and the shape of the object.</p>

<p>I use an extension to keep these up to date and to have them installed in every project I work in: <a href="https://marketplace.visualstudio.com/items?itemName=jvitor83.types-autoinstaller">Types auto installer</a>. Here's an example of auto-complete for <a href="http://redux.js.org/docs/api/Store.html">a Redux store</a>.</p>

<p></div></div><a href='/images/vscode/redux.png'><img src="/images/vscode/redux.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>It'll also provide information about the parameters, which is a life-saver for me. Having grown up with <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html">named</a> <a href="https://robots.thoughtbot.com/ruby-2-keyword-arguments">parameters</a>.</p>

<p></div></div><a href='/images/vscode/redux-params.png'><img src="/images/vscode/redux-params.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<a name="Runtime"></a>
<h3>Runtime</h3>

<p>Using console logs to debug isn't an acceptable answer when debugging for me anymore. <a href="http://blog.cleancoder.com/uncle-bob/2016/07/27/TheChurn.html">That's churn</a> that I'm not willing to lose time to. Luckily for me, VS Code supports debugging across many languages.</p>

<p>It does this by having a generic VS Code <a href="https://code.visualstudio.com/docs/extensions/example-debuggers">Debug Protocol</a> which lets extensions use their own processes to run the debugger. So the ruby debugger runs on the <a href="https://github.com/rubyide/vscode-ruby#debugger"><code>ruby-debug-ide</code></a> gem, and for node-based projects it uses the debugger built into node.</p>

<p>So, here is a common case. I want to start up my web-server, so I need to run <code>npm dev</code>. I can run this from VS Code:</p>

<p></div></div><a href='/images/vscode/start.png'><img src="/images/vscode/start.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Once that's running - I can attach a debugger. This is listing all of the available node processes on my computer:</p>

<p></div></div><a href='/images/vscode/attatch.png'><img src="/images/vscode/attatch.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Then I can add a breakpoint, and when it is triggered, I have a full stack trace and REPL. The REPL is very barebones, for example - there's no auto-complete. However, it's good for quick exploration. I keep <a href="https://www.objc.io/issues/19-debugging/lldb-debugging/#printing-objects">accidentally prefixing</a> my REPL code with <code>po</code>.</p>

<p></div></div><a href='/images/vscode/debug.png'><img src="/images/vscode/debug.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>The breakpoint works through a <a href="http://blog.teamtreehouse.com/introduction-source-maps">source map</a>, and so the line you expect is the one that you're working in. That stuff is all pretty magic to me. Good on Microsoft, and the node community for pulling that off.</p>

<a name="Wrapup"></a>
<h3>Wrapup</h3>

<p>I still feel a little bit uncomfortable in JavaScript projects, as a long-time native developer. However feel like VS Code is a nice mix of the freeform "just do something" style of Text Editors, which work across a lot of systems and the tight-knit IDEs that are bound to a specific domain. It can be a bridge between worlds.</p>

<p>VS Code has become my main editor in Ruby and JavaScript, due to having great support for the projects and being an OSS project which I feel like I can contribute to. No more being <a href="https://github.com/alcatraz/Alcatraz/issues/475">locked out</a> of improving my editor. Awesome!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Handling Large OSS Projects Defensively]]></title>
    <link href="http://artsy.github.io/blog/2016/07/03/handling-big-projects/"/>
    <updated>2016-07-03T12:00:00-04:00</updated>
    <id>http://artsy.github.io/blog/2016/07/03/handling-big-projects</id>
    <content type="html"><![CDATA[<p>I help maintain big OSS projects: from a third-party <a href="https://cocoapods.org">dependency manager</a> used in most iOS apps (<a href="https://github.com/CocoaPods/cocoapods.org">CocoaPods</a>), to the most popular Objective-C <a href="http://cocoapods.org/pods/Specta">testing framework</a> and the most popular Swift <a href="http://cocoapods.org/pods/Moya">networking API client</a>. I've been doing this for years.</p>

<p>Projects with this much impact are big time-sinks. This time comes from ensuring infrastructure continues to work, support tickets need replies, new code needs reviewing and releases need coordinating.</p>

<p><img src="/images/2016-07-03-big-oss/danger_logo_black@2x.png" alt="" /></p>

<p>Last September, almost a year ago, I started work on a new project, <a href="https://github.com/danger/danger/">Danger</a>. Danger fixes a problem we were seeing in the Artsy mobile team around adding "<a href="https://github.com/artsy/mobile/issues/31">process</a>" to our team.</p>

<p>As a part of discussing Danger internally, I've referenced that building CocoaPods has greatly influenced Danger. This blog post is about the way I've built Danger, knowing fully well that I cannot afford the level of time to maintain it at the scale it may get to.</p>

<!-- more -->


<hr />

<p>Danger is a project that could end up with a lot more users than CocoaPods. So I want to be cautious about how I create the community around Danger. If you're interested in some of the baseline setup required to run a popular project, the post "<a href="https://ashfurrow.com/blog/building-popular-projects/">Building Popular Projects</a>" by <a href="/author/ash">Ash</a> is a great place to start, this builds on that.</p>

<p>My maintenance time on CocoaPods resolves around:</p>

<ul>
<li>Handling new issues</li>
<li>Keeping infrastructure running</li>
<li>Requests around user data</li>
<li>Keeping disparate communities together</li>
</ul>


<a name="Issues"></a>
<h2>Issues</h2>

<p>From the ground up, Danger could not end up as complex as CocoaPods, the domain they cover is different and CocoaPods sits atop of an annually moving (and <em>somewhat</em> hostile) <a href="https://developer.apple.com/news/">platform</a>.</p>

<p>However, get enough people using a product and you end up with three types of issues: Bug Reports, How Do I X? and Feature Requests.</p>

<p>I wanted to keep bug-reports down, as much as possible, and so I built a system wherein the default error reporting system would also search GitHub issues <a href="https://github.com/orta/gh_inspector">for similar problems</a>. Knowing this was a generic problem, I built it with <a href="https://github.com/fastlane/fastlane/releases/tag/1.96.0">other</a> <a href="https://github.com/CocoaPods/CocoaPods/pull/5421">large</a> ruby projects in mind too.</p>

<p><code>How do I X?</code> are issues that haven't appeared much on Danger. For CocoaPods we request people use the CocoaPods tag on StackOverflow. That saves us from 5 to 6 issues a day, and provides others a great place to get internet points by responding instead.</p>

<p>Feature Requests issues are always fascinating, it gives you a chance to really see the difference between what you imagined a project's scope is, and how others perceive it. One thing that helps here is that Danger has a <a href="https://github.com/danger/danger/blob/master/VISION.md">VISION.md</a> file. This helped vocalise a lot of internal discussion, and let contributors understand the roadmap:</p>

<blockquote><p>The core concept is that the Danger project itself creates a system that is extremely easy to build upon. The codebase for Danger should resolve specifically around systems for CI, communication with Peer Review tools and providing APIs to Source Control changes. For example: Travis CI - GitHub - git.</p></blockquote>

<p>As well as providing a heuristic for determining whether something should be added to Danger:</p>

<blockquote><p>This means that decisions on new code integrated into Danger should ask "is this valid for every CI provider, every review system and source control type?" by making this domain so big, we can keep the core of Danger small.</p></blockquote>

<a name="Infrastructure"></a>
<h3>Infrastructure</h3>

<p>CocoaPods has about 6 web properties, 3 of which are critical. The others can go down, or be behind the Xcode update schedules and people's projects will work fine. The 3 the critical projects are all simple, focused projects: <a href="https://github.com/CocoaPods/trunk.cocoapods.org">trunk</a> (provide auth, and submitting new libraries) <a href="https://github.com/CocoaPods/cocoapods.org">cocoapods.org</a>, and <a href="https://github.com/CocoaPods/search.cocoapods.org">search</a>. We control everything there.</p>

<p>Meanwhile the less critical ones like <a href="https://github.com/CocoaPods/cocoadocs.org">cocoadocs.org</a> have dependencies all over the show: AppleDoc, CLOC, Xcode, Carthage, Jazzy - every one of these can, and has, been a source of unreliability for infrastructure that I maintain.</p>

<p>With Danger, I wanted to avoid building any infrastructure that does not sit on top of solid, mature projects. The website is statically created in <a href="https://middlemanapp.com">Middleman</a>, using <a href="https://rubygems.org/gems/slim">boring</a> <a href="https://rubygems.org/gems/sass">old</a> technology, this means no server to host.</p>

<p>To support dynamic content on the website, I have a rake command to use <a href="https://rubygems.org/gems/yard/versions">a decade old</a> documentation formatter to pull content from a <a href="https://en.wikipedia.org/wiki/RubyGems">13 year old</a> dependency manager - that lets others describer their project's. In order to let them keep it up to date, I have a tiny 35 line web-server that allows specific projects to trigger a new CI build.</p>

<a name="Plugins"></a>
<h3>Plugins</h3>

<center>
<blockquote class="twitter-tweet" data-lang="en-gb"><p lang="en" dir="ltr">Summary of every big OSS project. Monolith -&gt; Plugin support.<a href="https://t.co/7x4vuW4bRd">https://t.co/7x4vuW4bRd</a></p>&mdash; Orta Therox (@orta) <a href="https://twitter.com/orta/status/748561323164864512">30 June 2016</a></blockquote> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>


<p><br/></p>

<p>It's almost inevitable that once a project becomes big, maintainers have to become a lot more conservative about how they introduce new code. You become good at saying 'no', but a lot of people have legitimate needs. So, instead you end up converting your tool into a platform.</p>

<p>Some of the most interesting ideas in the CocoaPods ecosystem come from plugins.</p>

<p>I wanted plugins to be a first class citizen within Danger from day one. It's in the <a href="https://github.com/danger/danger/blob/master/VISION.md">VISION</a> file, and it's applied into how I've designed a lot of the user-facing site. I was <a href="https://github.com/danger/danger/issues/74">torn</a> after a few months of development <a href="https://github.com/danger/danger/pull/156#issuecomment-205907128">where things</a> should go. Now the core of Danger is <a href="https://github.com/danger/danger/pull/227">built as plugins</a>.</p>

<a name="Documentation"></a>
<h3>Documentation</h3>

<p>My second big project on CocoaPods was collating documentation and scoping different types of documentation. In CocoaPods I ended with:</p>

<ul>
<li><strong>Highlight pages</strong> (intro pages, app pages, team pages)</li>
<li><strong>Guides</strong> (tutorials, overviews, FAQs)</li>
<li><strong>Reference</strong> (Command-line interface, APIs for developers)</li>
</ul>


<p>These 3 buckets for documentation makes it pretty easy to separate where people should look depending on what they're looking for. This pattern I'm stealing outright for Danger. Just not quite yet, it's a blocker on 1.0 though.</p>

<p>One trick I took from CocoaPods is to have as much documentation as possible generated from the source code. With Danger, all of the work that's gone into documenting the code is turned into public API documentation for end-users. This makes it really easy to ensure it's consistent and up-to-date. The same tools used to generate documentation for Danger are used for plugins. Any improvements there helps everyone.</p>

<a name="User.Data"></a>
<h2>User Data</h2>

<p>Not storing any, phew! Though if <a href="https://github.com/danger/danger/issues/42">Danger as a Service</a> happens, then it will.</p>

<a name="People"></a>
<h2>People</h2>

<p>People are hard, Ash said in <a href="https://ashfurrow.com/blog/building-popular-projects/">Building Popular Projects</a>:</p>

<blockquote><p>The biggest existential threat to your library is this: you get burned out and stop working on it – and no one else contributes to it –</p></blockquote>

<p>Understanding motivations, encouraging ownership and accommodating multiple viewpoints are vital parts of anyone who wants to make a project bigger than themselves. There <a href="https://github.com/danger/danger/graphs/contributors">are lots of times</a> when I'm not the lead developer on Danger.</p>

<p>I owe a lot of this to the policy Ash and I created with Moya, the wordy "<a href="https://github.com/Moya/contributors">Moya Community Continuity Guidelines</a>" which define the expectations of the maintainers of a project towards contributors.</p>

<p>It's helped let a lot of other contributors make an impact. In the future, I hope those are the people that I get to hand Danger off to. Danger is bigger than me.</p>

<hr />

<p>Maintaining big projects is a learned activity, for most people it's a spectator sport, but it's not too hard to jump from writing issues to helping out. It's how I ended up contributing to CocoaPods.</p>
]]></content>
  </entry>
  
</feed>
