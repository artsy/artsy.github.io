<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: danger | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/danger/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2018-06-02T20:57:59+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[In the 'Whelp!' of the Great Wave]]></title>
    <link href="http://artsy.github.io/blog/2018/01/24/kubernetes-and-hokusai/"/>
    <updated>2018-01-24T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/01/24/kubernetes-and-hokusai</id>
    <content type="html"><![CDATA[<p>This past week has found me working on a brand new Rails project. Now, if I was building this project for my personal needs, I would without a doubt deploy it to <a href="https://www.heroku.com">Heroku</a> â€“ for both the ease of use and the high level of abstraction that <a href="https://www.heroku.com/dynos">Dynos</a> afford. But I'm not building this for myself, I'm building it for my team.</p>

<!-- more -->


<p>While Heroku is easy to get started with, costs scale up quickly. And, as described in our <a href="http://artsy.github.io/blog/2017/04/14/artsy-technology-stack-2017/">2017 tech stack post</a>, our team is moving more and more towards <a href="https://kubernetes.io">Kubernetes</a>. I had almost no experience with Kubernetes before last week, and I was intimidated by the Kubernetes web UI. With some help from my colleague Isac, who wrote the <a href="https://github.com/artsy/hokusai">Hokusai</a> tool, I was able to get a staging environment up and running in under a day.</p>

<p>But let's step back first.</p>

<p>My background is in iOS software development, so spinning up new servers isn't something I do often. When I <em>do</em>, I usually use Heroku. After deploying to it, it feels like Kubernetes is a kind of hosted Heroku: it handles scaling up instances, managing worker/db/other instances, load-balancers, environment variables, promoting from staging to production â€“ all that stuff. But Kubernetes' sophistication comes with a sophisticated user interface.</p>

<p>So basically, Hokusai is to Kubernetes what the Heroku command-line tool is to the Heroku platform.</p>

<p>Hokusai provides <a href="https://github.com/artsy/hokusai/blob/master/docs/Command_Reference.md">a bunch of commands</a> for interacting with the Kubernetes cluster. Deploying my new Rails app to Kubernetes involved a few steps, but most of the work was handled automatically by Hokusai.</p>

<p>First, I installed and setup Hokusai locally (with required environment variables for AWS access). I then ran the following command to scaffold out everything.</p>

<pre><code class="sh">hokusai setup --aws-account-id ARTSY_ACCOUNT_ID --project-type ruby-rails
</code></pre>

<p>In addition to staging- and production-specific config files, this command creates a <code>Dockerfile</code>. See, where Heroku uses Dynos as a high level of abstraction, Kubernetes uses <a href="https://www.docker.com">Docker</a> images (as a slightly less high a level of abstraction). Docker is a technology I'm familiar with, and I managed to configure the generated <code>Dockerfile</code> and <code>hokusai/*.yml</code> config files pretty quickly. At this point, I could run <code>hokusai dev start</code> to start a development Docker container, or <code>hokusai test</code> to run RSpec tests. Nothing fancy yet, but that verifies that everything is working so far.</p>

<p>Next up was to use Hokusai in our CI environment. <a href="https://circleci.com/docs/2.0/">Circle CI 2.0</a> is very Docker-oriented, so we set up everything using their <a href="https://circleci.com/docs/2.0/workflows/">Workflows</a>. This is a much higher level of abstraction for CI configuration than I'm used to, but I got the hang of it quickly. I created a job to run RSpec tests through Hokusai, a job to run <a href="http://danger.systems">Danger</a>, a job to build and push a Docker image to our S3 bucket, and a job to deploy that image to the Kubernetes cluster. Finally, I added the workflows to build and deploy automatically after successful builds on the <code>master</code> branch.</p>

<p>Here's a slightly redacted copy of our Circle config:</p>

<pre><code class="yaml">version: 2
jobs:
  test:
    docker:
      - image: artsy/hokusai:0.4.0
    working_directory: ~/REPO_NAME
    steps:
      - add_ssh_keys
      - checkout
      - setup_remote_docker
      - run:
          name: Test
          command: hokusai test
  danger:
    docker:
      - image: circleci/ruby:2.5.0
    working_directory: ~/apogee
    steps:
      - checkout
      - restore_cache:
          keys:
          - v1-dependencies-
          - v1-dependencies-
      - run:
          name: Install Dependencies
          command: bundle install --with=ci --without development test --path vendor/bundle
      - save_cache:
          paths:
            - ./vendor/bundle
          key: v1-dependencies-
      - run:
          name: Danger
          command: bundle exec danger
  push:
    docker:
      - image: artsy/hokusai:0.4.0
    steps:
      - add_ssh_keys
      - checkout
      - setup_remote_docker
      - run:
          name: Push
          command: hokusai registry push --tag $CIRCLE_SHA1 --force --overwrite
  deploy:
    docker:
      - image: artsy/hokusai:0.4.0
    steps:
      - add_ssh_keys
      - checkout
      - run:
          name: Configure
          command: hokusai configure --kubectl-version 1.6.3 --s3-bucket BUCKET_NAME --s3-key k8s/config --platform linux
      - run:
          name: Deploy
          command: hokusai staging deploy $CIRCLE_SHA1
workflows:
  version: 2
  default:
    jobs:
      - test
      - danger:
          filters:
            branches:
              ignore: master
      - push:
          filters:
            branches:
              only: master
          requires:
            - test
      - deploy:
          filters:
            branches:
              only: master
          requires:
            - push
</code></pre>

<p>The initial build on <code>master</code> built and pushed the server image, but the deploy failed. This is an <a href="https://github.com/artsy/hokusai/issues/50">issue</a> that's being tracked in Hokusai â€“ I'm sure it'll get addressed on the road to a 1.0. To explain, it's a Catch-22: we can't deploy until we have an image, but we only want to build images on CI, so the first deploy on CI is expected to fail.</p>

<p>Once the initial image was pushed, I ran <code>hokusai staging env create</code> locally to create the staging environment. I was able to set staging environment variables using <code>hokusai staging env set NAME=VALUE</code>, but unlike Heroku, I had to manually restart the server using <code>hokusai staging refresh</code> after adding the environment variables.</p>

<p>At this point, my server was working behind a load balancer, but I still had to add a CNAME record for the <code>really-long-url.elb.amazonaws.com</code> domain name. After some DNS propagation, everything worked fine!</p>

<p>So that's it! I was apprehensive about moving to a totally new (to me) deploy infrastructure. But, it's a direction our engineering team has decided to go in, and there's no better time to migrate to a new deploy infrastructure than before your first deploy. With some encouragement and help from my team, I was able to get the entire thing working in under a day (next time will be a lot faster).</p>

<p>I'm very encouraged by Kubernetes. It offers really slick, enterprise-level scaling features in an open source tool. And I've heard really great things about its community practices. Kubernetes is, however, a very specialized tool and its web interface doesn't make any sense to me. With Hokusai, I got a very programmer-friendly interface for a very DevOps-focused tool.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Peril to the Artsy Org]]></title>
    <link href="http://artsy.github.io/blog/2017/09/04/Introducing-Peril/"/>
    <updated>2017-09-04T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/09/04/Introducing-Peril</id>
    <content type="html"><![CDATA[<p>Once Danger Ruby was stable enough for everyday use in 2015, it became obvious that running Danger on CI was both a
positive and a negative. On the positive side, Danger has access to all artifacts created during testing - and on the negative
side it takes a long time to get feedback. It was obvious that Danger could <a href="https://github.com/danger/danger/issues/42">run on a server</a>, but it was a big unknown what that could look like.</p>

<p>Eventually, <a href="/blog/2017/06/30/danger-one-oh-again/">I came to the conclusion</a> that we would need a JavaScript replacement of Danger - and so I applied
constraints to Danger JS that made a server-side version of Danger a possibility. It was a stroke of luck that around the
time Danger JS became usable for day to day usage, that GitHub introduced <a href="https://developer.github.com/changes/2016-09-14-Integrations-Early-Access/">GitHub Apps</a> - so I started work on Peril. Peril is server-side Danger. The rest of this post talks about how we use it Artsy today, how you can use it yourself and where it's heading.</p>

<!-- more -->


<p>In December 2016, I built out Peril in a sandbox org: <a href="https://github.com/PerilTest">PerilTest</a>, this gave me the chance to get a lot of things wrong safely. My biggest worry around Peril was leaking data though someone abusing the ability to evaluate a Dangerfile.</p>

<p>In May 2017, I introduced Peril into Artsy's org, GitHub apps have the ability to pick and choose which repos to work with.
I scoped the repos to existing open source projects which I was familiar with (<a href="https://github.com/artsy/emission">Emission</a>, <a href="https://github.com/artsy/reaction">Reaction</a> and <a href="https://github.com/artsy/positron">Positron</a>)
which gave a space to ensure stability and handle production edge-cases.</p>

<p>In August 2017, I created a new Peril instance for CocoaPods. I then finally flipped the switch to turn Peril on for all
repos on the Artsy org and formalized the RFC process for changes. This is where we are now.</p>

<a name="Getting.Set.Up"></a>
<h2>Getting Set Up</h2>

<p>For our Artsy org, I followed and improved the guide: <a href="https://github.com/danger/peril/blob/master/docs/setup_for_org.md">Setup for Org</a>. There are three key components:</p>

<ul>
<li>Creating a GitHub app for your Org</li>
<li>Hosting a Peril server</li>
<li>Making up a Peril settings repo</li>
</ul>


<p>The guide covers the initial setup, but I'd like to cover the third part of our setup.</p>

<a name="How.Artsy.s.Peril.works"></a>
<h2>How Artsy's Peril works</h2>

<p>The Artsy Peril settings are all on <a href="https://github.com/artsy/artsy-danger">artsy/artsy-danger</a>. The Artsy Peril heroku instance has the ENV var
<code>"DATABASE_JSON_FILE"</code> set to <code>"artsy/artsy-danger@peril.settings.json"</code>, so Peril will use <a href="https://github.com/artsy/artsy-danger/blob/master/peril.settings.json">that file</a> as the source of truth for all config. Here's what it is today:</p>

<p></article>
<article class='split-desktop-only'></p>

<div style='flex:1; display: block;'>

```json
{
  "settings": {
    "modules": [
      "danger-plugin-spellcheck", 
      "danger-plugin-yarn", 
      "@slack/client"
    ],
    "env_vars": ["SLACK_RFC_WEBHOOK_URL"]
  },
  "rules": {
    "pull_request": "artsy/artsy-danger@org/all-prs.ts"
  },
  "repos" : {
    "artsy/reaction": {
      "pull_request": "danger/pr.ts"
    },
    "artsy/positron": {
      "pull_request": "dangerfile.ts"
    },
    "artsy/artsy-danger": {
      "issues.opened": "artsy/artsy-danger@danger/new_rfc.ts"
    }
  }
}
```

</div>


<div style='flex:1; display: block; padding:0 20px;'>

<p><code>"settings":</code> These settings which conform to today's <a href='https://github.com/danger/peril/blob/752afeb37e3c1fdec512eb91687747d9a8a29337/source/db/index.ts#L26-L31'>GitHubInstallationSettings</a>, here's the <a href='https://github.com/danger/peril/blob/master/source/db/index.ts'>current version</a>. These are org-wide settings
that require a new deploy of the server to re-create.</p>

<p><code>"rules":</code> These are rules which are applied to every repo that Peril has access to. So in this case, every Pull Request in the org will make Peril run the Dangerfile at <code>"artsy/artsy-danger@org/all-prs.ts"</code>.</p>

<p><code>"repos":</code> These are repo-specific overrides, so a Pull Request to artsy/reaction would trigger both the org-wide Dangerfile, and one on the reaction repo.</p>

</div>


<p></article>
<article class='post'></p>

<a name="Events"></a>
<h2>Events</h2>

<p>A Dangerfile evaluation occurs once a GitHub webhook is sent. In the above examples there are two events that Danger supports:
<code>"pull_request"</code> and <code>"issues.opened"</code>. These are qualifiers that GitHub provide as a <a href="https://developer.github.com/v3/activity/events/types/events">Webhook EventTypes</a>.</p>

<p>There's a lot of them: <code>commit_comment</code>, <code>create</code>, <code>delete</code>, <code>deployment</code>, <code>deployment_status</code>, <code>fork</code>, <code>gollum</code>, <code>installation</code>, <code>installation_repositories</code>, <code>issue_comment</code>, <code>issues</code>, <code>label</code>, <code>marketplace_purchase</code>, <code>member</code>, <code>membership</code>, <code>milestone</code>, <code>organization</code>, <code>org_block</code>, <code>page_build</code>, <code>project_card</code>, <code>project_column</code>, <code>project</code>, <code>public</code>, <code>pull_request</code>, <code>pull_request_review</code>, <code>pull_request_review_comment</code>, <code>push</code>, <code>release</code>, <code>repository</code>, <code>status</code>, <code>team</code>, <code>team_add</code>, <code>watch</code>.</p>

<p>Some of these events also have unique sub-actions too:</p>

<ul>
<li><p>For an <code>issue</code> event there is: <code>assigned</code>, <code>unassigned</code>, <code>labeled</code>, <code>unlabeled</code>, <code>opened</code>, <code>edited</code>,  <code>milestoned</code>, <code>demilestoned</code>, <code>closed</code>, or <code>reopened</code></p></li>
<li><p>For a <code>pull_request</code> event there is: <code>assigned</code>, <code>unassigned</code>, <code>review_requested</code>, <code>review_request_removed</code>, <code>labeled</code>, <code>unlabeled</code>, <code>opened</code>, <code>edited</code>, <code>closed</code>, or <code>reopened</code></p></li>
</ul>


<p>The way that you define rules in Peril gives you the ability to either focus on one action for an event type: <code>"issues.opened"</code> or all actions
on an event: <code>"pull_request"</code>. Once you get your head around this, you start to get a sense of the scope of Peril. At Artsy, we've barely scratched the surface.</p>

<a name="Growth"></a>
<h3>Growth</h3>

<p>I've always advocated that Danger, and Peril should be <a href="http://danger.systems/js/usage/culture.html">applied incrementally</a>. This applies even more when you're
making org changes that affect every developer - at least with Danger you can see the Pull Request that changes
the Dangerfile. With Peril you get none of that.</p>

<p>So, we introduced <a href="https://github.com/artsy/artsy-danger/#rfcs">an RFC process for Peril changes</a>. There's not much to it, if you want to add a rule that
affects everyone then you need to make an issue following a template and then wait a week. If you make a new issue that
includes the title <code>RFC:</code> then Peril sends a slack message to our developer Channel</p>

<p><img src="/images/peril/peril-rfc.png" alt="/images/peril/peril-rfc.png" /></p>

<p>This was simple to build via Peril, I first added the npm module: <code>"@slack/client"</code> to the <code>"modules"</code> array, making it available to a Dangerfile. Then I added an environment variable to Peril for a newly minted Slack Incoming Webhook URL, and exposed it to Dangerfiles via: <code>"env_vars": ["SLACK_RFC_WEBHOOK_URL"]</code>.</p>

<p>Then I added a per-repo rule:</p>

<pre><code class="json">    "artsy/artsy-danger": {
      "issues.opened": "artsy/artsy-danger@danger/new_rfc.ts"
    }
</code></pre>

<p>This means the Dangerfile is only ran on <code>"issues"</code> with an <code>"opened"</code> action. I didn't want the discussion around a rule spamming our slack with webhooks from the other actions. The file <code>danger/new_rfc.ts</code> looks like this:</p>

<pre><code class="ts">import { schedule, danger } from "danger"
import { IncomingWebhook } from "@slack/client"
import { Issues } from "github-webhook-event-types"

declare const peril: any // danger/danger#351

const gh = danger.github as any as Issues
const issue = gh.issue

if (issue.title.includes("RFC:")) {
  var url = peril.env.SLACK_RFC_WEBHOOK_URL || "";
  var webhook = new IncomingWebhook(url)
  schedule( async () =&gt; {
   await webhook.send({
      unfurl_links: false,
      attachments: [{
        pretext: "ðŸŽ‰ A new Peril RFC has been published.",
        color: "good",
        title: issue.title,
        title_link: issue.html_url,
        author_name: issue.user.login,
        author_icon: issue.user.avatar_url
      }]
    })
  })
}
</code></pre>

<p>For events that are not a <code>"pull_request"</code> the <code>danger.github</code> object is the JSON for the event.  You can get TypeScript types available for every GitHub event via the NPM module <a href="https://www.npmjs.com/package/github-webhook-event-types">github-webhook-event-types</a> which makes it much easier to work with.</p>

<a name="Where.to.go.from.here."></a>
<h2>Where to go from here?</h2>

<p>Right now we have <a href="https://github.com/artsy/artsy-danger/issues?utf8=%E2%9C%93&amp;q=is%3Aissue%20RFC">a few RFCs</a>, and I don't spend all day making Peril rules, I've gotta <a href="https://github.com/artsy/emission/pulls?utf8=%E2%9C%93&amp;q=consignments%20">do work y'know</a>. We're going to slowly build out our Peril infrastructure.</p>

<p>I'm interested in exploring two ideas big for peril at the moment:</p>

<ul>
<li><p>What a Peril plugin system looks like: You can include modules which can listen to events and react themselves. An org-wide spellcheck on markdown files could be as easy as including <code>"modules": ["peril-plugin-spellcheck"]</code>.</p></li>
<li><p>What <a href="https://github.com/danger/peril/issues/138">scheduled jobs</a> could look like for Peril: We have a bunch of checks I'd like to make on a a regular occasion, and then passing back feedback via slack or making an issue on the repo.</p></li>
</ul>


<p> For example if a repo has an owner who isn't in Artsy anymore, we should highlight that it needs a new owner.</p>

<p>If you're interested in using Peril in large OSS projects, take a look at how Peril is used in CocoaPods via <a href="https://github.com/CocoaPods/peril-settings">CocoaPods/peril-settings</a>.</p>

<p>If you're interested in using Peril in your org, run through the <a href="https://github.com/danger/peril/blob/master/docs/setup_for_org.md">Setup for Org</a> guide and help improve it when you inevitably have some weird issues.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Danger]]></title>
    <link href="http://artsy.github.io/blog/2017/06/30/danger-one-oh-again/"/>
    <updated>2017-06-30T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/06/30/danger-one-oh-again</id>
    <content type="html"><![CDATA[<p>Danger came out of two needs. One from the needs of a growing dev team working together full-time, and the other from the needs of a completely asymmetric large Open Source project.</p>

<p>A work environment dev team is a complex place. You naturally grow, and to grow safely you add process. Process is a mixed bag, it's a net benefit at the trade-off of individual's time vs team cohesion. You want to grow your team guided by smart applications of process.</p>

<p>On the other hand, working on a large open source project, it's easy to feel overwhelmed at the amount of work that needs to get done on a daily basis. The growth of your OSS team probably doesn't tie to the amount of work that needs to be done. Especially if you're like me, and you don't want to be maintaining OSS as a 2nd full-time job.</p>

<p>So what do you do? Well in a work environment you don't really have a choice, as a team you hold each other to the rules that you set. In OSS, you sacrifice your spare time or you can find time at work, you could stop or you could burn out.</p>

<p>And this is the environment in which the idea of Danger was incubated.</p>

<p>Today mark version 1.0 of the second version of Danger. I'm going to cover what they are, how they continue to grow and what I see their trajectory as.</p>

<!-- more -->


<a name="Why."></a>
<h1>Why?</h1>

<p>Danger came from a need to customise the GitHub workflow for pull requests. In a work context, we wanted to add process like CHANGELOGs and be more thorough about testing. In Open Source, we needed to stop asking the same things to drive-by contributors. Their patches are valuable for sure, but asking for the same changes each time gets tiring. We want to work at a higher level of abstraction.</p>

<p>In both cases you want a way to give instant feedback for things that are "Unit Tests have failed" or "Code could not compile". However, it's hard to give feedback that says "You have not added a CHANGELOG entry in the right format."</p>

<p>Typically CI would only provide a binary: true or false response to the changes for review. We want a more shades of grey.</p>

<a name="What.does.Danger.do."></a>
<h2>What does Danger do?</h2>

<p>Danger acts as a way of creating unit tests at code review level. It gives you the ability to write tests that say: "has this file changed?", "does the contents of new files include this string?", "does the build log include a warning we know is bad news?" then the results of those tests are moved back into the place you're talking about the code.</p>

<p>To do this, you need to be able to create your own rules. Every team has different dynamics, and while it makes sense to offer a set of a set of standard rules that can work across a lot of projects - I'm pretty sure that the needs of the Artsy engineering team is different from the needs of your team.</p>

<p>Danger runs your code, and provides a set of easy to use APIs for you to build these useful culture rules. You write your rules in code, we call these files Dangerfiles. Similar to how a testing framework would give a set of expectations. The general gist is Danger provides access to:</p>

<ul>
<li>Changes from Git</li>
<li>Changes from GitHub/GitLab/BitBucket</li>
<li>Interacting with Danger</li>
</ul>


<p>By making per-project rules with these APIs, you can cover most rote tasks involved in code review. To make it easy for anyone to run Danger on every pull request, Danger was made to run during continuous integration.</p>

<a name="OK..so..2.versions.of.Danger.."></a>
<h1>OK, so "2 versions of Danger"?</h1>

<p>I first implemented Danger in Ruby. Ruby is a great language for building terminal apps, in the iOS community it's the language in which the largest OSS projects are built in. So, as someone used to building apps in that space, it wasn't really a debate what language to work with.</p>

<p>The Ruby build of Danger is now at 5.x with almost 100 releases, it's a solid exploration into code review automation. Ultimately though, I started to feel three main pain-points:</p>

<ul>
<li><p>At Artsy, we moved our mobile team to React Native, and other teams were also consolidating on JavaScript everywhere. It felt weird using a Ruby inside a strictly JS only context.</p></li>
<li><p>Trying to re-create the environment of a PR was tricky from inside the CI. For example most providers are good at about saving on space and bandwidth during a run, and Danger often has to ruin that in order to replicate the PR locally.</p></li>
<li><p>I wanted to explore server-side Dangerfiles. I wouldn't feel comfortable hosting a server that allows anyone to run their own Ruby code. Ruby isn't built with sandboxing in mind.</p></li>
</ul>


<a name="JavaScript"></a>
<h2>JavaScript</h2>

<p>First I explored the idea of having JavaScript based Dangerfiles inside the Ruby version of Danger. I did this by <a href="https://github.com/danger/danger/pull/422">bridging Danger's Ruby objects into a JavaScript context</a> and allowing bi-directional communication between the two. This handled some of the immediate needs, but proved inadequate when working with JavaScript's simple system library and it ignored all other JavaScript tooling.</p>

<p>After enough time, I came to the conclusion that realistically, to use JavaScript properly, you need node modules and npm.</p>

<p>So 10 months ago I decided it was worth starting from scratch and re-created Danger in JavaScript. I had time to consider what I would do differently, and this time I added one key additional restraints on the system: Data can only come from an API.</p>

<p>This constraint negates one of the key problems with running running a Dangerfile on a server - having to have a copy of the code and the PR's environment.</p>

<p>In addition, JavaScript has a much simpler model for evaluating, importing and exporting code and so whitelisting modules and functions can be feasible for a hosted version of Danger.</p>

<center><img src ="/images/danger/danger.png" style="width:50%"></center>


<a name="L1.0.is.my.middle.name"></a>
<h1>1.0 is my middle name</h1>

<p>Any software project used in production should probably be 1.0, but in addition to production use a library needs documentation to be 1.0.</p>

<p>Calling Danger production ready means doing the entire <a href="http://artsy.github.io/blog/2016/07/03/handling-big-projects/">Defensive OSS</a> process: Documentation, Guides, API Reference, Website and Branding.</p>

<p>Once each version of Danger had started to mature to a point that the user-facing aspect stopped changing I started focusing on the documentation engine and website. In both cases, a considerable amount of documentation is generated from the source code of Danger. I'm a big fan of keeping that inside the source code and building documentation sites which import it directly.</p>

<a name="So.what.can.I.do.with.Danger."></a>
<h1>So what can I do with Danger?</h1>

<p>In one way this is a bit like asking, so what can I test with unit tests? Anything, within the scope of: the PR, build artifacts and introspecting the codebase.</p>

<p>I'll cover a quick API overview, then talk about how you can work with these:</p>

<a name="Git"></a>
<h3>Git</h3>

<ul>
<li>What files have been added, removed or changed.</li>
<li>Changes specific to a file.</li>
<li>Looking into Commits.</li>
<li>Exploring the Diff.</li>
</ul>


<a name="GitHub...GitLab...BitBucket"></a>
<h3>GitHub / GitLab / BitBucket</h3>

<ul>
<li>Access to the PR's JSON representation.</li>
<li>Consistent access for PR body, title, author across all platforms.</li>
<li>Util functions for linking to files.</li>
</ul>


<a name="Danger"></a>
<h3>Danger</h3>

<ul>
<li>Handle running other Dangerfiles.</li>
<li>Handles plugin management.</li>
<li>Provides a set of utility functions that would often get used.</li>
</ul>


<a name="Messaging"></a>
<h3>Messaging</h3>

<ul>
<li>Leave warnings, messages and markdown comments.</li>
<li>Leave errors, marking the build as failed.</li>
<li>Post any of the above of the above inside a file.</li>
<li>Create a GitHub review, and use the above messaging.</li>
</ul>


<a name="Plugins"></a>
<h3>Plugins</h3>

<ul>
<li>Infrastructure for shared rules.</li>
<li>Opens up the ability to validate tricky things with an easy API.</li>
</ul>


<p>The API differs between the JS and Ruby version, not drastically - but there are no plugins for Danger JS yet. That's still a bit away.</p>

<a name="OK..got.it."></a>
<h2>OK, got it.</h2>

<p>Let's cover a few examples of the kind of tests can you write.</p>

<a name="Checking.for.changes.to.a.specific.file"></a>
<h4>Checking for changes to a specific file</h4>

<p>Checking for a CHANGELOG. This was the first rule imagined for Danger, I add it to every project.</p>

<p>The first implementation of this rule can just be a check if the file <code>CHANGELOG.md</code> is modified in any PR, that can then be
revised to also check whether there are git changes related to your app. Then documentation, README, tooling updates
don't require an entry. We also check if the PR title says "trivial" and skip the CHANGELOG check.</p>

<p>If you're interested in standardizing on the <a href="http://keepachangelog.com/en/0.3.0/">keepachangelog.com</a> format there is <a href="https://github.com/dblock/danger-changelog">danger-changelog</a>.</p>

<p>Some other examples around this is pinging specific people when a file has changed, or failing if a file that's never meant
to be modified is changed, warning about potential semantic version updates for changes to specific files.</p>

<a name="Checking.the.results.of.command-line.tools"></a>
<h4>Checking the results of command-line tools</h4>

<p>The Artsy developer blog runs both a spell checker, and a prose linter. These report back on files added or
modified during the PR. As someone known for writing loose and quick, having a machine provide some automatic feedback
makes it easy to not waste my reviewers time.</p>

<p>This is done by the <a href="https://github.com/dbgrandi/danger-prose">danger-prose</a> plugin, which wraps both an <a href="https://github.com/lukeapage/node-markdown-spellcheck">npm module</a> and a <a href="https://github.com/amperser/proselint/">python egg</a>.
The plugin handles installing and running the CLI, then converts the output into markdown for github.</p>

<a name="Handling.build.artifacts"></a>
<h4>Handling build artifacts</h4>

<p>If Danger runs after the build process, you can read build logs to provide better feedback. This can range from taking
the results of a test run and posting what has failed (e.g. <a href="https://github.com/orta/danger-junit">danger-junit</a>), to finding specific strings inside
build logs and highlighting them.</p>

<p>In our native iOS app, when a developer accidentally adds code which accesses the network in a test. That is logged out
during the build. Then later, danger will read the logs to find any mentions of this and post it in the comment.</p>

<a name="PR.Metadata"></a>
<h4>PR Metadata</h4>

<p>Every team's workflow is different, but it's pretty common to use a tool other than code review for keeping track of a project's momentum. You can use Danger to warn people that they haven't included a Trello, or JIRA ticket reference on
every PR.</p>

<p>A similar approach could be to warn if someone is sending a PR to a branch other than the preferred branch. This works
well if you use the git-flow model for branches.</p>

<p>We nearly always add a check to see if someone is assigned to a PR, and warn it it's unassigned in front-end projects.</p>

<a name="Using.the.platform.API"></a>
<h4>Using the platform API</h4>

<p>There's no limits here, by using the API from your platform you can perform any sorts of checks. In the Danger repo
we use the GitHub API to note whether someone is in the Danger org, to remind the core team to invite them to the org
after submitting a PR.</p>

<a name="Introducing.Danger"></a>
<h2>Introducing Danger</h2>

<p>OK, maybe that's got you thinking <em>"ah, I know a process I can automate"</em>.</p>

<p>It can be easy to try and jump straight from no Dangerfile to a many-hundred lined complex set of cultural rules. I'd advise against introducing a long list of rules for Danger all at once. In my experience, gradual integration works better. The entire team may have agreed on the changes upfront, but slower adoption has worked better for teams new to working with Danger.</p>

<p>At Artsy we've found that first just integrating Danger with a single simple rule (like checking for a CHANGELOG entry) then starting to introduce them piece-meal from different contributors has made it easier to go from "Ah, we shouldn't do that again" to "Oh, we could make a Danger rule for that" to "Here's the PR".</p>

<a name="Which.Danger.should.I.use."></a>
<h2>Which Danger should I use?</h2>

<p>This definitely depends on the project, there's a longer discussion <a href="http://danger.systems/js/js-vs-ruby.html">on the site</a> too, but here's the main gist:</p>

<ul>
<li><p><strong>Danger Ruby</strong> is more mature, has more features, a solid plugin eco-system and covers more platforms. It's in a great place and is unlikely to have breaking changes from this point onwards.</p></li>
<li><p><strong>Danger JS</strong> has a bigger potential for growth, is "stable enough", you can create plugins and will be able to do things that the Ruby version could not - eventually. Right now it only works with GitHub.</p></li>
</ul>


<a name="Onwards.and.Upwards"></a>
<h2>Onwards and Upwards</h2>

<p>With the JavaScript version of Danger in a great place ready for production, I can start more serious work on <a href="https://github.com/danger/peril#peril">Peril</a>. Peril is a hosted web-service that runs Dangerfiles against GitHub events, see <a href="https://github.com/danger/peril/blob/master/VISION.md">the VISION.md</a>. Those events span from a new user being created, to a new issue on a repo. Peril lets you run your own complex rules across an entire org. This can be a really powerful way to audit and improve entire-company culture.</p>

<p>We started using Peril in Artsy <a href="https://github.com/artsy/reaction-force/pull/184">last week</a>. So it's starting to become a thing internally. It'll be awesome to explore the idea of org-wide rules. I think we're starting with making sure we assign someone on a PR.</p>

<p>So give Danger a shot, and if you're bold. give <a href="https://github.com/danger/peril#peril">Peril</a> a shot.</p>

<hr />

<p>This post uses the CC license image from <a href="https://twitter.com/CloudyConway/status/880426417024114688">this tweet</a> with some changes to make it fit with the design of the blog. Thanks <a href="https://www.patreon.com/vexorian">Vexorian</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript Glossary for 2017]]></title>
    <link href="http://artsy.github.io/blog/2016/11/14/JS-Glossary/"/>
    <updated>2016-11-14T12:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/11/14/JS-Glossary</id>
    <content type="html"><![CDATA[<p>Getting to grips with the entire JavaScript ecosystem is a tough job when you're getting started. Coming from the native mobile space, there's a lot to learn. I've spent a few months immersed in the environment now, and can try summerize a lot of topics. This should make it easier to find more information when you need it. This post is semi-opinionated, with links for further reading so you can get a different perspective too.</p>

<p>This post focus specifically on the JavaScript tooling around React Native projects, but is applicable to all JavaScript projects.</p>

<!-- more -->


<p>Lets start with the entire reason we are using JavaScript for mobile in the first place: React and React Native,</p>

<a name="React"></a>
<h1>React</h1>

<a name="React"></a>
<h3>React</h3>

<p>React is a Facebook project which offers a uni-direction Component model that <em>can</em> replace MVC in a front-end application. React was built out of a desire to abstract away a web page's true view hierarchy (called the DOM) so that they could make changes to all of their views and then React would handle finding the differences between view states.</p>

<p>Its model is that you would create a set of Components to encapsulate each part for the state of the page. React makes it easy to make components that are functional in the <a href="https://en.wikipedia.org/wiki/functional_reactive_programming">Functional Reactive Programming</a> sense. They act like a function which takes some specially declared state and it is rendered into HTML.</p>

<p>A component optionally uses a language called <a href="#jsx">JSX</a> to visualise how each component's child components are set up,here's an example of a React component using JSX <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/home/search_bar.js">from Emission, our React Native library</a>:</p>

<pre><code class="js">export default class SearchBar extends React.Component {
  render() {
    return (
      &lt;TouchableWithoutFeedback onPress={this.handleTap.bind(this)}&gt;
        &lt;View style={styles.container}&gt;
          &lt;Image style={styles.searchIcon} source={require('../../../images/SearchButton.png')}/&gt;
          &lt;Text style={styles.text}&gt;Search for artists and artworks...&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/TouchableWithoutFeedback&gt;
    )
  }

  handleTap() {
    Switchboard.presentModalViewController(this, '/search')
  }
}
</code></pre>

<p>By providing a well encapsulated Component model, you can aggressively reduce the amount of redundant code you need to build an application. By not initially writing to the DOM, React can decide what has changed between user actions and that means you have to juggle significantly less <a href="#state">state</a>.</p>

<a name="React.Native"></a>
<h3>React Native</h3>

<p>I came to this conclusion early this year that writing native apps using compiled code is a pain, and it's been amazing to be able to work in React Native in contrast.</p>

<p>React Native is an implementation of React where instead of having it abstract a web page's DOM, it creates a native view hierarchy. In the case of iOS that is a UIView hierarchy. Note that it does not handle View Controllers. The MVC model from Apple's Cocoa framework does not directly map into React Natives. I've wrote about how we <a href="http://artsy.github.io/blog/2016/08/24/On-Emission/">bridge that gap earlier</a>.</p>

<p>React Native is cross platform. You write JavaScript like above, which React Native transforms into a native view hierarchy. That view hierarchy could be on a Samsung TV, a Windows phone or Android instead.</p>

<p>It's a smart move, most "Make apps in JS" try to have a native-like experience where they replicate the platform's UI in HTML. However, this technique tends to feel unnatural very easily. If I showed you our app, you could not distinguish between a view controller in React Native, Swift or Objective-C.</p>

<a name="App.State"></a>
<h3>App State</h3>

<p>Think of every variable inside your application, that is your application's state. You could not make an app worth using without state. In MVC, MVVM, VIPER and other native patterns, there is no consistent way to handle changes in those variables. React uses a common state pattern though the use of specific terminology: "<a href="#props">props</a>", "<a href="#context">context</a>" and "<a href="#state-again">state</a>".</p>

<p>Yes, the "state" and "state" thing is a little confusing, we'll get to it.</p>

<a name="Props"></a>
<h3>Props</h3>

<p>Props are chunks of app state that are passed into your component from a parent component. In <a href="#jsx">JSX</a> this is represented as an XML attribute.</p>

<p>Let's check out <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/artist/header.js">an example</a>:</p>

<pre><code class="js">export default class Header extends React.Component {
  [...]
  render() {
    return (
        &lt;View style={styles.followButton}&gt;
            &lt;InvertedButton text={this.state.following ? 'Following' : 'Follow'}
                            selected={this.state.following}
                            onPress={this.handleFollowChange} /&gt;
        &lt;/View&gt;
    )
  }
}
</code></pre>

<p>See the <code>InvertedButton</code> component, it has three <code>props</code> being passed in: <code>text</code>, <code>selected</code> and <code>onPress</code>. If any of those props were to change the entire <code>InvertedButton</code> component would be re-rendered to the native view hierarchy. These <code>props</code> are the key to passing data downwards through your hierarchy. Note: you cannot access the parent component (without passing it in as a prop.)</p>

<p>You should therefore consider <code>props</code> as immutable bits of app state relevant to the component it's being passed into.</p>

<a name="State-again"></a>
<h3>State-again</h3>

<p>A component also has a <code>state</code> attribute. The key to understanding the difference between <code>props</code> and <code>state</code> is: <code>state</code> is something controlled within that component that can change - <code>props</code> do not.</p>

<p>The above example is a pretty good example of this, when this component is first added to the hierarchy, we send a networking request to get whether you are following something or not. The parent component (<code>Header</code>) does not need to update when we know whether you are following or not, but the <code>InvertedButton</code> does. So, it is <code>state</code> for the parent, but a <code>prop</code> for the <code>InvertedButton</code>. This means changing the state for <code>following</code> will only cause a re-render in the button.</p>

<p>So state is something which changes within a component, which <em>could</em> be used as <code>props</code> for it's children. Examples of this are around handling animation progress, whether you're following something, selection indices and any kind of networking which we do outside of <a href="#relay">Relay</a>.</p>

<p>If you'd like to read more, there is a much deeper explanation in <a href="https://github.com/uberVU/react-guide/blob/master/props-vs-state.md#props-vs-state">uberVU/react-guide</a></p>

<a name="Context"></a>
<h3>Context</h3>

<p><a href="https://facebook.github.io/react/docs/context.html">The docs</a> are pretty specific about context:</p>

<blockquote><p>If you aren't an experienced React developer, don't use context. There is usually a better way to implement functionality just using props and state.</p></blockquote>

<p>Seems to be something that you should only be using in really, really specific places. If you need it, you don't need this glossary.</p>

<a name="JSX"></a>
<h3>JSX</h3>

<p>As we'll find out later, modern JavaScript is a collection of different ideas, and using <a href="#babel">Babel</a> - you can add them at will into your projects. JSX is one such feature, it is a way of describing nested data using XML-like syntax. These are used inside React's render function to express a component's children and their <a href="#props">props</a>.</p>

<p>Under the hood, JSX is quite simple, with code looking like this:</p>

<pre><code class="js">const element = (
  &lt;h1 className="greeting"&gt;
    Hello, world!
  &lt;/h1&gt;
);
</code></pre>

<p>Turning into</p>

<pre><code class="js">const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
</code></pre>

<p>Where <code>createElement</code> comes from the React <a href="#module">module</a>. You can find out more in <a href="https://facebook.github.io/react/docs/introducing-jsx.html">the React docs</a></p>

<a name="Libraries"></a>
<h1>Libraries</h1>

<a name="GraphQL"></a>
<h3>GraphQL</h3>

<p>TLDR: An API format for requesting only the data you want, and getting back just that.</p>

<p>If you want the longer explanation, I wrote a <a href="/blog/2016/06/19/graphql-for-mobile/">blog post on it</a>.</p>

<a name="Relay"></a>
<h3>Relay</h3>

<p>Relay is what makes working in our React Native app shine. It is a library that allows a component to describe small chunks of a networking request it would need to render. Relay would then look through your component hierarchy, take all the networking fragments, make a single GraphQL request for all the data. Once it has the data, Relay passes in the response as <a href="#props">props</a> to all of the components in the tree.</p>

<p>This means you can throw away a significant amount of glue code.</p>

<a name="Redux"></a>
<h3>Redux</h3>

<p>Redux is a state management pattern, it builds on top of React's "state is only passed down" concept, and creates a single way to handle triggering changes to your state. I'm afraid I don't have any experience with it, so I can't provide much context. I feel like <a href="http://www.youhavetolearncomputers.com/blog/2015/9/15/a-conceptual-overview-of-redux-or-how-i-fell-in-love-with-a-javascript-state-container">this post</a> covers it well though.</p>

<a name="Tooling"></a>
<h1>Tooling</h1>

<a name="Node"></a>
<h3>Node</h3>

<p>Node is the JavaScript implementation from Google's Chrome (called v8) with an expanded API for doing useful systems tooling. It is a pretty recent creation, so it started off with an entirely asynchronous API for any potentially blocking code.</p>

<p>For web developers this was a big boon, you could share code between the browser and the server. The non-blocking API meant it was much easier to write faster servers, and there are lots of big companies putting a lot of time and money into improving the speed of JavaScript every day.</p>

<p>Node has an interesting history of ownership, I won't cover it here, but <a href="http://anandmanisankar.com/posts/nodejs-iojs-why-the-fork/">this link</a> provides some context.</p>

<a name="NPM"></a>
<h3>NPM</h3>

<p>NPM is the Node Package Manager. It is shipped with node, but it is a completely different project and team. NPM the project is ran by a private company.</p>

<p>NPM is one of the first dependency managers to offer the ability to install multiple versions of the same library inside your app. This contributes considerably to the issue of the number of dependencies inside any app's ecosystem.</p>

<p>JavaScript people will always complain about NPM, but people will always complain about their build tools. Dependency Manager's especially. From an outsider's view, it nearly always does what you expect, has a great team behind it and has more available dependencies than any other.</p>

<p>NPM works with a <code>Package.json</code> file as the key file to represent all the different dependencies, version, authors and misc project metadata.</p>

<a name="Yarn"></a>
<h3>Yarn</h3>

<p>Yarn is a NPM replacement (ish) by Facebook. It's very new. It solves three problems, which were particularly annoying to me personally.</p>

<ul>
<li>It flattens dependencies - this means that you're less likely to have multiple versions of the same library in your app.</li>
<li>It uses a lockfile by default - this means that everyone on your team gets the same build, instead of maybe getting it.</li>
<li>It is significantly faster.</li>
</ul>


<p>It uses the NPM infrastructure for downloading <a href="#modules">modules</a>, and works with the exact same <code>Package.json</code>. I moved most of our projects to it.</p>

<a name="Babel"></a>
<h3>Babel</h3>

<p>I mentioned JSX a few times above. JSX is not a part of JavaScript, it is transpiled from your source code (as XML-like code) into real JavaScript. The tool that does this is Babel.</p>

<p>Babel is a generic JavaScript transpilation engine. It does not provide any translation by default, but instead offers a plugin system for others to hook in their own transpilation steps. This becomes important because a lot of JavaScript features have staggered releases between browsers and you can't always guarantee each JavaScript runtime will have the features you want to use.</p>

<p>Babel's plugins can be configured inside your <code>Package.json</code>. To ship your code to the world, you then create a script of some sort to convert your source code into "olde world" JavaScript via Babel.</p>

<p>In the case of a react-native project, Babel is happening behind the scenes.</p>

<a name="Webpack"></a>
<h3>Webpack</h3>

<p>A JavaScript source code &amp; resource package manager. It can be easy to confuse Babel + Webpack, so in simple:</p>

<ul>
<li>Babel will directly transform your source code file by file</li>
<li>Webpack will take source code and merge it all into one file</li>
</ul>


<p>They work at different scopes. Webpack is mainly a web front-end tool, and isn't used in React Native. However, you'll come across it, and it's better to know the scope of it's domain.</p>

<a name="ESLint"></a>
<h3>ESLint</h3>

<p>How can you be sure your syntax is correct? JavaScript has a really powerful and extensible linter called ESLint. It parses your JavaScript and offers warnings and errors around your syntax. You can use this to provide a consistent codebase, or in my case, to be lazy with your formatting. Fixing a lot of issues is one command away. I have <a href="https://artsy.github.io/blog/2016/08/15/vscode/">my editor</a> auto indent using ESLint every time I press save.</p>

<a name="Development"></a>
<h1>Development</h1>

<a name="Live.Reload"></a>
<h3>Live Reload</h3>

<p>This is a common feature in JavaScript tooling. If you press save in a source file then some action is taken. Live Reloading tends to be a more blunt action, for example reloading the current view from scratch, or running all of the tests related to the file.</p>

<a name="Hot-Reloading"></a>
<h3>Hot-Reloading</h3>

<p>Hot Reloading is more rare, because it's significantly harder. Hot Reloading for React projects is injecting new functions into the running application, and keeping it in the same state.</p>

<p>For example if you had a filled-in form on your screen, you could make styling changes inside your source file and the text inside the form would not change. Hot reloading is amazing.</p>

<a name="Haste.Map"></a>
<h3>Haste Map</h3>

<p>Part of what makes React Native support Hot Reloading, and allows <a href="#jest">Jest</a> to understand changes for testing is by using a Haste Map. A Haste Map is a dependency resolver for JavaScript, looking through every function to know how it connects to every other function within the JavaScript project.</p>

<p>With the dependencies mapped, it becomes possible to know what functions would need replacing or testing when you press save after writing some changes. This is why it takes a bit of time to start up a React Native project.</p>

<p>The public API is deprecated, you shouldn't use it in your projects, but the <a href="https://github.com/facebookarchive/node-haste/tree/master#node-haste-">old README is still around</a>.</p>

<a name="Testing"></a>
<h1>Testing</h1>

<a name="Jest"></a>
<h3>Jest</h3>

<p>Facebook have their own test runner called Jest. It builds on <a href="https://jasmine.github.io">Jasmine</a>, and offers a few features that kick ass for me:</p>

<ul>
<li>Re-runs failing tests first</li>
<li>Assumes all tests unrelated to changes are green and doesn't run them</li>
<li>Watch mode that works reliably</li>
</ul>


<p>I miss these features when I'm not in a Jest project.</p>

<a name="Jest.Snapshots"></a>
<h3>Jest Snapshots</h3>

<p>Jest has a feature called Jest Snapshots, that allows you to take "snapshots" of JavaScript objects, and then verify they are they are the same as they were last time. In iOS we <a href="https://www.objc.io/issues/15-testing/snapshot-testing/">used visual snapshot</a> testing a lot.</p>

<a name="VSCode-Jest"></a>
<h3>VSCode-Jest</h3>

<p>I created a project to auto-run Jest inside projects that use it as a test runner when using Visual Studio Code: <a href="https://github.com/orta/vscode-jest">vscode-jest</a>. I've wrote about our usage of VS Code <a href="https://artsy.github.io/blog/2016/08/15/vscode/">on this blog series</a> also.</p>

<a name="JavaScript.the.Language"></a>
<h1>JavaScript the Language</h1>

<p>I'm always told that JavaScript was created in 10 days, which is a cute anecdote, but JavaScript has evolved for the next 21 years. The JavaScript you wrote 10 years ago would still run, however modern JavaScript is an amazing and expressive programming language once you start using modern features.</p>

<p>Sometimes these features aren't available in <a href="#node">node</a>, or your browser's JavaScript engine, you can work around this by using a transpiler, which takes your source code and backports the features you are using to an older version of JavaScript.</p>

<a name="ES6"></a>
<h3>ES6</h3>

<p>JavaScript is run by a committee. Around the time that people were starting to talk about HTML5 and CSS3, work was started on a new specification for JavaScript called ECMAScript 6.</p>

<p>ES6 represents the first point at which JavaScript really started to take a lot of the best features from transpile to JavaScript languages like CoffeeScript. Making it feasible for larger systems programming to be possible in vanilla JavaScript.</p>

<a name="ES2016"></a>
<h3>ES2016</h3>

<p>It took forever for <a href="#es6">ES6</a> to come out, and every time they created / amended a specification there were multiple implementations of the specification available for transpiling via <a href="#babel">babel</a>. This I can imagine was frustrating for developers wanting to use new features, and specification authors trying to put out documentation for discussion as a work in progress. This happened a lot <a href="#promises">with the Promises</a> API.</p>

<p>To fix this they opted to discuss specification features on a year basis. So that specifications could be smaller and more focused, instead of major multi-year projects. Quite a SemVer jump from 6 to 2016.</p>

<a name="Stages"></a>
<h3>Stages</h3>

<p>Turns out that didn't work out too well, so the terminology changed again. The change is mainly to set expectations between the Specification authors and developers transpiling those specifications into their apps.</p>

<p>Now an ECMAScript language improvement specification moves through a series of stages, depending on their maturity. I <a href="https://twitter.com/logicoder/status/799919558429736960">believe starting</a> at 0, and working up to 4. 0 Idea, 1 Proposal, 2 Draft, 3 Accepted and 4 Done.</p>

<p>So a ECMAScript Stage 0 feature is going to be really new, if you're using it via a transpiler then you should expect a lot of potential API changes and code churn. The higher the number, the longer the spec has been discussed, and the more likely for the code you're transpiling to be the vanilla JavaScript code in time.</p>

<p>The committee who discussed these improvements are the <a href="http://ecma-international.org/memento/TC39.htm">TC39</a> committee, the cool bit is that you can see <a href="https://github.com/tc39">all the proposals</a> as individual GitHub repos so it's convenient to browse.</p>

<a name="Modules...Imports"></a>
<h3>Modules / Imports</h3>

<p>A modules is the terminology for a group of JavaScript code. Terminology can get confusing, as the import structure for a library is very similar to importing a local file.</p>

<p>You can import a module using syntax like <code>import { thin, other } from "thingy"</code>. Here's some examples <a href="https://github.com/artsy/emission/blob/master/lib/components/artist/shows/show.js#L4-L9">from our project</a>:</p>

<pre><code class="js">// Import modules
import Relay from 'react-relay'
import React from 'react'
// Import two items from the react-native module 
import { View, TouchableWithoutFeedback } from 'react-native'

// Import the default class from a local file
import ImageView from '../../opaque_image_view'
import SwitchBoard from '../../../native_modules/switch_board'
</code></pre>

<p>An import can either have <a href="https://github.com/danger/danger-js/blob/61557ac7b6de37ef9a7e4a1aa0c0cbe0bd00977d/source/ci_source/Fake.js#L6">a default export</a>, or a set of <a href="https://github.com/artsy/Mitosis/blob/0c1d73055122bd61559df3b1a2913cf4e272b4ed/source/bot/artsy-api.js#L31-L94">exportable function/objects</a>.</p>

<p>You might see an import like <code>const _ = require("underscore")</code> around the internet, this is an older format for packaging JavaScript called <a href="https://www.wikiwand.com/en/CommonJS">CommonJS</a>. It was replaced by the <code>import</code> statements above because you can make guarantees about the individual items exported between module boundaries. This is interesting because of <a href="#tree-shaking">tree-shaking</a>, which we'll get to later.</p>

<a name="Classes"></a>
<h3>Classes</h3>

<p>Modern JavaScript has classes introduced in <a href="#es6">es6</a>, this means that instead of writing something like:</p>

<pre><code class="js">const danger = {
  name: "Danger",
  hello: function () {
    console.log("Hi!")
  }
}

danger.hello();
</code></pre>

<p>Instead you could write:</p>

<pre><code class="js">class Person {
  constructor(name) {
    this.name = name
  }
  hello() {
    console.log("Hi!")
  }
}

const danger = new Person("danger")
danger.hello()
</code></pre>

<p>Classes provide the option of doing object-oriented programming, which is still a solid way to write code. Classes provide a simple tool for making interfaces, which is really useful when you're working to the <a href="http://www.amazon.com/gp/product/0201633612?ie=UTF8&amp;camp=213733&amp;creative=393185&amp;creativeASIN=0201633612&amp;linkCode=shr&amp;tag=eejs-20&amp;linkId=5S2XB3C32NLP7IVQ">Gang of Four</a> principals:</p>

<blockquote><p>â€œProgram to an interface, not an implementation,â€ and â€œfavor object composition over class inheritance.â€</p></blockquote>

<a name="Prototypical"></a>
<h3>Prototypical</h3>

<p>So, classes - it took 20ish years before they happened? Before that JavaScript was basically only a prototype-based language. This meant you created "objects" but that they were just effectively just key-value stores, and you used functions to do everything else.</p>

<p>The language is a great fit for functional programming, I ended up building <a href="https://github.com/artsy/Mitosis/">an Artsy chat bot</a> using only functions by accident. Really, a few days into it when I started looking for an example class to show in this post I realised I didn't have one. Whereas in Danger I do almost exclusive OOP in JavaScript, sometimes the project fits the paradigm too.</p>

<p>A really good, and highly opinionated post on the values of prototypical/functional programming in JavaScript is <a href="https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3#.knm7xb7zr">The Two Pillars of JavaScript</a> - I agree with a lot of it.</p>

<a name="Mutablilty"></a>
<h3>Mutablilty</h3>

<p>JavaScript has had a keyword <code>var</code> to indicate a variable forever. You should basically never use this. I've never written one this year, except by accident. It's a keyword that has a really confusing scope, leading to odd bugs. <a href="#es6">ES6</a> brought two replacements, both of which will give you a little bit of cognitive dissonance if you have a lot of Swift experience.</p>

<p><code>let</code> - the replacement for <code>var</code>, this is a <em>mutable</em> variable, you can replace the value of a <code>let</code>. The scope of a <code>let</code> is exactly what you think from every other programming language.
<code>const</code> - this is a <code>let</code> that won't allow you to change the <em>value</em>. So it creates a mutable object (all JS objects are mutable) but you cannot replace the object from the initial assignment.</p>

<a name="This"></a>
<h3>This</h3>

<p>The keyword <code>this</code> is a tricky one. It is confusing because <code>this</code> gets assigned to the object that invokes the function where you use <code>this</code>.</p>

<p>It's confusing because you may have a function inside a class, and would expect <code>this</code> to be the instance to which the function is attached to, but it very easily could not be. For <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/artist/articles/article.js#L11-L22">example</a>:</p>

<pre><code class="js">class Article extends React.Component {
  handleTap() {
    SwitchBoard.presentNavigationViewController(this, this.props.article.href)
  }

  render() {
    [...]
    return (
      &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback onPress={this.handleTap}&gt;
</code></pre>

<p>In the above example <code>this</code> inside <code>handleTap</code> does not refer to the instance of Article. Tricky right?</p>

<p>There are two "easy" fixes, <a href="http://exploringjs.com/es6/ch_arrow-functions.html">using arrow functions</a> instead if normal functions:</p>

<pre><code class="js">class Article extends React.Component {
  handleTap = () =&gt; {
    SwitchBoard.presentNavigationViewController(this, this.props.article.href)
  }
  [...]
</code></pre>

<p>Or you can use the <code>bind</code> function to ensure that <code>this</code> inside the function is what you want it to be.</p>

<pre><code class="js">class Article extends React.Component {
  [...]

  render() {
    [...]
    return (
      &lt;View style={styles.container}&gt;
        &lt;TouchableWithoutFeedback onPress={this.handleTap.bind(this)}&gt;
</code></pre>

<p>This is a great in-depth explanation of the way it works: <a href="https://toddmotto.com/understanding-the-this-keyword-in-javascript/">Understanding the â€œthisâ€ keyword in JavaScript</a>.</p>

<a name="Strict.Mode"></a>
<h3>Strict Mode</h3>

<p>Introduced in ECMAScript 5.1, it provides a way to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">opt-in to more errors</a> inside the JavaScript runtime. As you're likely to be using both a linter and a transpiler to keep your source clean, I'm less worried about including it on every page.</p>

<a name="Destructuring"></a>
<h3>Destructuring</h3>

<p>Object destructuring is one of those things that saves a little bit of code all the time. It's especially useful given the amount of time you spend passing around plain old JavaScript objects. This is something that CoffeeScript took from Ruby:</p>

<pre><code class="js">&gt; const [orta, danger] = [33, 23]
undefined
&gt; danger
23
&gt; orta
33
</code></pre>

<p>or for an Object</p>

<pre><code>&gt; const user = { name: "Danger", age: 27 }
undefined
&gt; const { name,  age }  = user
undefined
&gt; name
'Danger'
&gt; age
27
</code></pre>

<p>This makes it really easy to pull out subsets of existing objects and set them as variables.</p>

<a name="Arrow.Functions"></a>
<h3>Arrow Functions</h3>

<p>In JavaScript a function has always looked like:</p>

<pre><code class="js">function(arg1, arg2) {
  [...]
}
</code></pre>

<p>This gets frustrating when you're doing functional-style programming, where you use closures for mapping, filtering and others. So instead <a href="#es6">ES6</a> introduced terser ways of doing this. So I'm going to write the same function multiple times:</p>

<pre><code class="js">// The way it's always been
function (lhs, rhs) {
    return lhs.order &gt; rhs.order
}

// An arrow function version
(lhs, rhs) =&gt; {
    return lhs.order &gt; rhs.order
}

// An implicit return, and no braced one-liner arrow function
(lhs, rhs) =&gt; lhs.order &gt; rhs.order 
</code></pre>

<a name="Promises"></a>
<h3>Promises</h3>

<p><a href="#node">Node</a> is renowned for having a non-blocking API from day one. The way they worked around this is by using callbacks everywhere. This can work out pretty well, but eventually maintaining and controlling your callbacks turns into it's own problem. This can be extra tricky around handing errors.</p>

<p>One way to fix this is to have a Promise API, Promises offer consistent ways to handle errors wand callback chaining.</p>

<p>JavaScript now has a built-in a Promise API, this means every library can work to one API when handling any kind of asynchronous task. I'm not sure what ECMA Specification brought it in. This makes it really easy to make consistent code between libraries. However, more importantly, it makes it possible to have async/await.</p>

<a name="Async.Await"></a>
<h3>Async/Await</h3>

<p>Once Promises were in, then a language construct could be created for using them elegantly. They work by declaring the entire function to be an <code>async</code> function. An async function is a function which pretends to be synchronous, but behind the scenes is waiting for specific promises to resolve asynchronously.</p>

<p>There are a few rules for an <code>async</code> function:</p>

<ul>
<li>You cannot use <code>await</code> inside a function that has not been declared <code>async</code>.</li>
<li>Anything you do return will be implicitly wrapped in a Promise</li>
<li>Non-async functions can just handle the promise an <code>async</code> function returns</li>
</ul>


<p>So, a typical <code>async</code> function</p>

<pre><code class="js">  async getReviewInfo() : Promise&lt;any&gt; {              // this function will do async
    const details = await this.getPullRequestInfo()   // wait for the promise in getPullRequestInfo to resolve 
    return await details.json()                       // wait for the promise in json to resolve
  }                                                   // return the json
</code></pre>

<p>You aren't always given a promise to work with as not all APIs support promises and callbacks, wrapping a callback function is pretty simple:</p>

<pre><code class="js">  readFile(path: String): Promise&lt;string&gt; {                       // returns a promise with a string
    return new Promise((resolve: any, reject: any) =&gt; {           // create a new promise, with 2 callbacks
      fs.readFile(path, "utf8", (err: Error, data: string) =&gt; {   // do the work
        if (err) { return reject(err) }                           // did it fail? reject the promise
        resolve(data)                                             // did it pass? resolve the promise
      })
    })
  }
</code></pre>

<p>The <code>await</code> part of an <code>async</code> function using <code>await readFile</code> will now wait on the synchronous execution until the promise has resolved. This makes complicated code look very simple.</p>

<a name="Tree.Shaking"></a>
<h3>Tree Shaking</h3>

<p>All development ecosystems have trade-offs which shape their culture. For web developers reducing the amount of JavaScript they send to a client is an easy, and vital part of their day job. This started with minifying their source code, e.g. reducing the number of characters but having the same behavior.</p>

<p>The current state of the art is tree-shaking, wherein you can know what functions are unused and remove those from the source code before shipping the code to a client. A <a href="#haste-map">haste-map</a> is one way to handle these dependencies, but it's not the only one. <a href="http://rollupjs.org/">Rollup</a> is considered the de-facto ruler of the space, but it is in <a href="#babel">babel</a> and <a href="#babel">webpack</a> also.</p>

<p>Does this affect you if you're using React Native? Not really, but it's an interesting part of the ecosystem you should be aware of.</p>

<a name="Types"></a>
<h1>Types</h1>

<p>Types can provide an amazing developer experience, as an editor can understand the shape of all the object's inside your project. This can make it possible to build rich refactoring, static analysis or auto-complete experiences without relying on a runtime.</p>

<p>For JavaScript there are two main ways to use types. <a href="#flow">Flow</a> and <a href="#typescript">TypeScript</a>. Both are amazing choices for building non-trivial applications. IMO, these two projects are what makes JavaScript a real systems language.</p>

<p>Both take the approach of providing an optional typing system. This means you can choose to add types to existing applications bit by bit. By doing that you can easily add either to an existing project and progressively add types to unstructured data.</p>

<a name="Interfaces"></a>
<h3>Interfaces</h3>

<p>As both <a href="#flow">Flow</a> and <a href="#typescript">TypeScript</a> interact with JavaScript, the mindset for applying types is through Interfaces. This is very similar to programming with protocols, where you only care about the responsibilities  of an object - not the specific type. Here is a Flow interface from DangerJS:</p>

<pre><code class="js">/** An API representation for a Code Review site */
export interface Platform {
  /** Mainly for logging and error reporting */
  name: string;
  /** Used internally for getting PR/Repo metadata */
  ciSource: CISource;
  /** Pulls in the Code Review Metadata for inspection */
  getReviewInfo: () =&gt; Promise&lt;any&gt;;
  /** Pulls in the Code Review Diff, and offers a succinct user-API for it */
  getReviewDiff: () =&gt; Promise&lt;GitDSL&gt;;
  /** Creates a comment on the PR */
  createComment: (body: string) =&gt; Promise&lt;?Comment&gt;;
  [...]
}
</code></pre>

<p>This interface defines the shape of an object, e.g. what functions/properties it will it have. Using interfaces means that you can expose the least amount of about an object, but you can be certain that if someone refactors the object and changes any interface properties - it provide errors.</p>

<a name="Flow"></a>
<h3>Flow</h3>

<p><a href="https://flowtype.org">Flow</a> is a fascinating tool that infers types through-out your codebase. Our React Native uses a lot of Flow, we have a lot of <a href="#eslint">linter rules</a> for it too, so instead of writing a function like:</p>

<pre><code class="js">function getPlatformForEnv(env, source) {
return [...]
}
</code></pre>

<p>We would write it like this:</p>

<pre><code class="js">function getPlatformForEnv(env: Env, source: CISource): ?Platform {
return [...]
}
</code></pre>

<p>Wherein we now have interfaces for our arguments and the return value of the function. This means better error message from Flow, and better auto-complete in your editor.</p>

<a name="TypeScript"></a>
<h3>TypeScript</h3>

<p>TypeScript is a typed language that compiles JavaScript by Microsoft. It's awesome, it has all of the advantages that I talked about with Flow and a lot more. With TypeScript you can get a much more consistent build environment (you are not picking and choosing different features of ES6) as Microsoft implement all of it into TypeScript.</p>

<p>We opted to go for JS + Flow for Artsy's React Native mainly because we could incrementally add types, and you can find a lot more examples of JavaScript on the internet. It also is the way in which React Native is built, so you get the ecosystem advantage.</p>

<p>That said, if we start a new React Native from scratch project, I would pitch that we should use TypeScript after my experiences with <a href="https://github.com/Microsoft/vscode/pull/12628">making PRs</a> to VS Code. TypeScript feels more comprehensive, I got better error messages and VS Code is very well optimised for working in TypeScript projects.</p>

<a name="Typings.Flow-Typed"></a>
<h3>Typings/Flow-Typed</h3>

<p>Shockingly, not all JavaScript <a href="#modules">modules</a> ship with a typed interface for others. This makes it a pain to work with any code outside your perfectly crafted/typed codebase. This isn't optimal, especially in JavaScript where you rely on so many external libraries.</p>

<p>Meaning that you can either look up the function definitions in their individual docs, or you can read through the source. This breaks your programming flow.</p>

<p>Both TypeScript and Flow offer a tool to provide external definitions for their libraries. For typescript that is <a href="https://github.com/typings/typings">typings</a> and for Flow, <a href="https://github.com/flowtype/flow-typed/">flow-typed</a>. These tools pull into your project definition files that tell TypeScript/Flow what each module's input/outputs are shaped like, and provides inline documentation for them.</p>

<p>Flow-Typed is new, so it's not really got many definitions at all. Typings on the other hand has quite a lot, so in our React Native we use typings to get auto-complete for our libraries.</p>

<a name="JavaScript.Fatigue"></a>
<h3>JavaScript Fatigue</h3>

<p>So that's my glossary, there's a lot of interesting projects out in the JS world.</p>

<p>They have a term "<a href="http://www.confluentforms.com/2016/01/javascript-churn-technology-investment-effect.html">JavaScript fatigue</a>" which represents the concept of the churn in choosing and learning from so many projects. This is very real, which is something we're taking into account. Given the amount of flexibility in the ecosystem, it's really easy to create anything you want. If I wanted to implement a simplified version of Swift's guard function for our JavaScript, I could probably do it in about 2 days using a Babel plugin, then we can opt-in on any project we want.</p>

<p>This can make it easy to freeze and flip the table, but it also makes JavaScript a weird, kind of ideal, primordial soup where some <em>extremely</em> interesting ideas come out. It's your job to use your smarts to decide which are the ideas which will evolve further, then help them stablize and mature.</p>

<script>
// Ain't optimal, but it does it for now, need to figure a better way in the future.
$("a[name]").each(function(i, el){
  var $el = $(el)
  $el.attr("name", $el.attr("name").toLowerCase().replace(".", "-"))
})
</script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using VS Code for JavaScript]]></title>
    <link href="http://artsy.github.io/blog/2016/08/15/vscode/"/>
    <updated>2016-08-15T22:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/08/15/vscode</id>
    <content type="html"><![CDATA[<center>
 <img src="/images/vscode/vscode_logo_artsy.svg" style="width:300px;">
</center>


<p>I'm an old school TextMate user, who has also been using Xcode for the last decade. These two sit at a very opposite ends of an "editor" spectrum.</p>

<p>TextMate is extremely bare bones at the core, but introduced the idea of bundles as plugins. Making it really easy for others to build their own plugins for their own contexts. Xcode on the other-hand includes a 3D scene editor, the best interface builder I've seen, super rich debugging tools and close to zero support for improving it yourself.</p>

<p>As we agreed on moving to React Native, we needed to decide what the team should use for <a href="https://github.com/artsy/emission/blob/master/docs/vscode.md">working in that environment</a>. After experimentation with many editors, we decided on Microsoft's <a href="https://code.visualstudio.com/">Visual Studio Code</a>.</p>

<p>We wanted to keep a lot of the best features from Xcode, while working in a completely JavaScript environment. For example: debuggers, inline errors, auto-complete, symbol mapping and to ideally have them all inside a single editor.</p>

<p>Let's dig into the principals of how Visual Studio Code works, what makes it a better option for us, and what parts of it really shine.</p>

<!-- more -->


<hr />

<a name="What.is.Visual.Studio.Code."></a>
<h3>What is Visual Studio Code?</h3>

<p>Visual Studio Code (VS Code) is <em>yet another</em>, JavaScript-based text editor. It's built atop of GitHub's <a href="http://electron.atom.io">Electron</a>. Electron is a framework for writing native apps as easy as building websites. It started as a web component for some Microsoft web-service, and eventually evolved into a fully-fledged text editor.</p>

<a name="IDE.-.Editor.hybrid"></a>
<h4>IDE - Editor hybrid</h4>

<p>Visual Studio Code (VS Code) believes that the sweet-spot between and IDE and a plain Text Editor, is somewhere a little bit closer to the IDE side.</p>

<p></article>
<a href='/images/vscode/editors.png' style="">
  <img src="/images/vscode/editors.png" alt="Editors" style="width:100%;">
</a>
<article class="post">
</p>

<p>This means instead of the Text-Editor style folder based approach, VS Code expects to set up a project structure per-project to start supporting from of the more useful IDE-like features.</p>

<p>It supports TextMate style plugins (called Extensions) through a controlled, but expanding <a href="https://code.visualstudio.com/docs/extensions/overview">extension API</a>. The extension API work takes an <a href="https://developer.apple.com/library/mac/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html">Apple-like</a> approach to ensuring stability by having all extensions run outside of the host process. <a href="https://code.visualstudio.com/docs/extensions/our-approach">This approach</a> ensures any extension crash does not take down the editor.</p>

<p>It's also smart about deciding when to load an extension, for example, my <a href="https://marketplace.visualstudio.com/items?itemName=Orta.vscode-danger">Danger</a> extension will <a href="https://github.com/orta/vscode-danger/blob/a21ccc101b2b1c1be595b10565bca9c88242fb6f/package.json#L18-L20">only load</a> if there is a <code>Dangerfile</code> in the root of the workspace.</p>

<p>These two approaches to extensions are specifically aimed at <a href="https://discuss.atom.io/t/why-is-atom-so-slow/11376">addressing issues</a> seen inside Atom, where any user actions can be / are blocked by extensions, and extensions have full-reign to make any change they want. Even on my Mac Pro, there is a noticable lag. I initially assumed this was the "JavaScript tax" for all Electron apps, but VS Code is fast.</p>

<a name="Making.Intellisense"></a>
<h3>Making Intellisense</h3>

<p>By default a JavaScript project does not have a way to provide auto-completion, or in VS Code's terminology: Intellisense. Trying to make auto-complete based on a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> can only get you so far, because it has to be wary against functions with side-effects. Other alternatives are to build an <a href="http://jointjs.com/demos/javascript-ast">AST</a> from the code, and then introspect that.</p>

<p>In Xcode the auto-complete tools are powered by the type systems of Objective-C and Swift. This means that you can know the structure of an object, without having to dig inside it, potentially breaking it in the process. Vanilla JavaScript does not have a type system. There are a few root classes though: String, Object, Number etc.</p>

<p>To work around this problem, VS Code uses <a href="http://www.typescriptlang.org">TypeScript</a> behind the scenes. TypeScript is a language that compiles down to JavaScript which provides a typing structure on top of JavaScript. This is a similar approach to how <a href="https://flowtype.org">Flow works</a> too, which is the language <a href="https://github.com/artsy/emission/pull/220">we write React Native</a> in.</p>

<p>This can work out really well for your own classes if you are declaring your types, but the npm ecosystem is <em>full</em> of untyped JavaScript, and a lot of your work is about sitting atop those abstractions. The fix for this is offered via <a href="http://definitelytyped.org">DefinitelyTyped</a> which provides type definitions for popular npm modules. For example here is <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/redux/redux.d.ts">one for Redux</a> - these act like <a href="https://github.com/artsy/eigen/blob/master/Artsy/App/ARSwitchBoard.h">header files in Objective-C</a> - offering inline documentation, and the shape of the object.</p>

<p>I use an extension to keep these up to date and to have them installed in every project I work in: <a href="https://marketplace.visualstudio.com/items?itemName=jvitor83.types-autoinstaller">Types auto installer</a>. Here's an example of auto-complete for <a href="http://redux.js.org/docs/api/Store.html">a Redux store</a>.</p>

<p></article>
<a href='/images/vscode/redux.png' style="">
  <img src="/images/vscode/redux.png" alt="Redux" style="width:100%;">
</a>
<article class="post">
</p>

<p>It'll also provide information about the parameters, which is a life-saver for me. Having grown up with <a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html">named</a> <a href="https://robots.thoughtbot.com/ruby-2-keyword-arguments">parameters</a>.</p>

<p></article>
<a href='/images/vscode/redux-params.png' style="">
  <img src="/images/vscode/redux-params.png" alt="Redux Params" style="width:100%;">
</a>
<article class="post">
</p>

<a name="Runtime"></a>
<h3>Runtime</h3>

<p>Using console logs to debug isn't an acceptable answer when debugging for me anymore. <a href="http://blog.cleancoder.com/uncle-bob/2016/07/27/TheChurn.html">That's churn</a> that I'm not willing to lose time to. Luckily for me, VS Code supports debugging across many languages.</p>

<p>It does this by having a generic VS Code <a href="https://code.visualstudio.com/docs/extensions/example-debuggers">Debug Protocol</a> which lets extensions use their own processes to run the debugger. So the ruby debugger runs on the <a href="https://github.com/rubyide/vscode-ruby#debugger"><code>ruby-debug-ide</code></a> gem, and for node-based projects it uses the debugger built into node.</p>

<p>So, here is a common case. I want to start up my web-server, so I need to run <code>npm dev</code>. I can run this from VS Code:</p>

<p></article>
<a href='/images/vscode/start.png' style="">
  <img src="/images/vscode/start.png" alt="Editors" style="width:100%;">
</a>
<article class="post">
</p>

<p>Once that's running - I can attach a debugger. This is listing all of the available node processes on my computer:</p>

<p></article>
<a href='/images/vscode/attatch.png' style="">
  <img src="/images/vscode/attatch.png" alt="Editors" style="width:100%;">
</a>
<article class="post">
</p>

<p>Then I can add a breakpoint, and when it is triggered, I have a full stack trace and REPL. The REPL is very barebones, for example - there's no auto-complete. However, it's good for quick exploration. I keep <a href="https://www.objc.io/issues/19-debugging/lldb-debugging/#printing-objects">accidentally prefixing</a> my REPL code with <code>po</code>.</p>

<p></article>
<a href='/images/vscode/debug.png' style="">
  <img src="/images/vscode/debug.png" alt="Editors" style="width:100%;">
</a>
<article class="post">
</p>

<p>The breakpoint works through a <a href="http://blog.teamtreehouse.com/introduction-source-maps">source map</a>, and so the line you expect is the one that you're working in. That stuff is all pretty magic to me. Good on Microsoft, and the node community for pulling that off.</p>

<a name="Wrapup"></a>
<h3>Wrapup</h3>

<p>I still feel a little bit uncomfortable in JavaScript projects, as a long-time native developer. However feel like VS Code is a nice mix of the freeform "just do something" style of Text Editors, which work across a lot of systems and the tight-knit IDEs that are bound to a specific domain. It can be a bridge between worlds.</p>

<p>VS Code has become my main editor in Ruby and JavaScript, due to having great support for the projects and being an OSS project which I feel like I can contribute to. No more being <a href="https://github.com/alcatraz/Alcatraz/issues/475">locked out</a> of improving my editor. Awesome!</p>
]]></content>
  </entry>
  
</feed>
