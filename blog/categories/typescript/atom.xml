<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: typescript | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/typescript/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2017-09-05T17:43:26+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Modernizing Force]]></title>
    <link href="http://artsy.github.io/blog/2017/09/05/Modernizing-Force/"/>
    <updated>2017-09-05T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/09/05/Modernizing-Force</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/artsy/force">Force</a> is Artsy's main website, <a href="https://www.artsy.net">artsy.net</a>. In the three years since it was <a href="http://artsy.github.io/blog/2014/09/05/we-open-sourced-our-isomorphic-javascript-website/">open-sourced</a>, it has provided a solid foundation to build features on top of without a lot of the costs associated with growth. It is an early example of Isomorphic ("universal") JavaScript, built on top of Express, Backbone, CoffeeScript, Stylus and Jade. It is also highly modular, adopting patterns laid down by its parent project,  <a href="https://github.com/artsy/ezel">Ezel</a>.</p>

<p>When first developed these technologies made a lot of sense; CoffeeScript fixed many of the problems with JavaScript pre-ES6, and Jade / Stylus made working with HTML / CSS much more elegant. As time progressed and new technologies became a thing these solutions starting feeling more burdensome to continue building features with and many of our developers longed to start using next-generation tools like React.</p>

<!-- more -->


<p>Looking at output from <code>cloc</code>, the question is "But how?"</p>

<pre><code class="js">[artsy/force] $ cloc desktop mobile

--------------------------------------------------------
Language                     files                  code
--------------------------------------------------------
CoffeeScript                  1828                 81569
CSS                              9                 76632
Stylus                         577                 32324
JavaScript                     274                 18310
JSON                            30                  6145
Markdown                        41                  1097
HTML                             3                    25
XML                              3                    24
--------------------------------------------------------
SUM:                          2765                216126
--------------------------------------------------------
</code></pre>

<p>216k+ LOC, spread across multiple languages and formats. Given finite resources and a small team rebuilds can be difficult to execute, and so we had to figure out a way to marry the old with the new while also maintaining backwards compatibility / interoperability. Out of this exercise came a few patterns, libraries and projects that I would like to describe in an effort to help those caught in similar situations.</p>

<a name="Step.1:.Get.Your.House..aka.Compiler..in.Order"></a>
<h2>Step 1: Get Your House (aka Compiler) in Order</h2>

<p><a href="https://babeljs.io/">Babel</a> has been around for a while, but lately their team has been putting effort into making it as easy as possible to use. By dropping a <a href="https://github.com/artsy/force/blob/master/.babelrc">.babelrc</a> file into the root of your project, server and client-side JavaScript can share the same configuration, including <a href="https://github.com/tleunen/babel-plugin-module-resolver">module resolution</a> (aka, no more <code>../../../</code>).</p>

<p>A simplified example:</p>

<pre><code class="json">// .babelrc

{
  "presets": ["es2015", "react", "stage-3"],
  "plugins": [
    ["module-resolver", {
      "root": ["./"]
    }]
  ]
}
</code></pre>

<pre><code class="js">// index.js

require('coffee-script/register')
require('babel-core/register')

// Start the app
require('./boot')
</code></pre>

<p>On the client, we use <a href="http://browserify.org/">Browserify</a> with <a href="https://github.com/substack/coffeeify">Coffeeify</a> and <a href="https://github.com/babel/babelify">Babelify</a>:</p>

<pre><code class="json">// package.json

{
  "scripts": {
    "assets": "browserify -t babelify -t coffeeify -o bundle.js",
    "start": "yarn assets &amp;&amp; node index.js"
  }
}
</code></pre>

<p>And then boot it up:
<code>sh
$ yarn start
</code></p>

<p>By adding just a few lines, our existing CoffeeScript pipeline was augmented to support modern JavaScript on both the server and the client, with code that can be shared between.</p>

<a name="Step.2:.Tune-up.Iteration.Time"></a>
<h2>Step 2: Tune-up Iteration Time</h2>

<p>A question that every developer should ask of their stack is:</p>

<blockquote><p>"How long does it take for me to make a change and see that change reflected in a running process?"</p></blockquote>

<p>Does your code take one second to compile, or ten? When writing a back-end service, does your server <a href="https://github.com/remy/nodemon">automatically restart</a> after you make a change, or do you need to <code>ctrl+c</code> (stop it) and then restart manually?</p>

<p>For those of us working in Force, the bottleneck typically involved making changes to back-end code. Due to how we organize our sub-apps, client-side code compilation -- after the server heats up -- is pretty much instant, but that heat-up time can often take a while depending on which app we're working on. So even with a "restart on code change" setup that listens for updates it still felt terribly slow, and this iteration time would often discourage developers from touching certain areas of the codebase. We needed something better!</p>

<p>Enter Webpack and React, which helped popularize the concept of HMR, or "Hot Module Replacement".</p>

<p>From the Webpack docs:</p>

<blockquote><p>"Hot Module Replacement (HMR) exchanges, adds, or removes modules while an application is running, without a full reload."</p></blockquote>

<p>That's more like it! But is there anything similar for the server given we don't use Webpack? This was the question <a href="https://github.com/alloy">@alloy</a>, one of our Engineering Leads, asked himself while researching various setups that ultimately led to <a href="https://github.com/artsy/reaction">Reaction</a>, and for which he found an answer to in Glen Mailer's excellent <a href="https://github.com/glenjamin/ultimate-hot-reloading-example">ultimate-hot-reloading-example</a>. Digging into the code, <a href="https://github.com/glenjamin/ultimate-hot-reloading-example/blob/master/server.js#L38-L45">this little snippet</a> jumped out:</p>

<pre><code class="js">watcher.on('ready', function() {
  watcher.on('all', function() {
    console.log("Clearing /server/ module cache from server");
    Object.keys(require.cache).forEach(function(id) {
      if (/[\/\\]server[\/\\]/.test(id)) delete require.cache[id];
    });
  });
});
</code></pre>

<p>The code seemed simple enough -- on change, iterate through Node.js's internal require cache, look for the changed module, and clear it out. When the module is <code>require</code>'d at a later point it will be like it was required for the first time, effectively hot-swapping out the code.</p>

<p>With this knowledge we wrapped a modified version of this snippet into <a href="https://github.com/artsy/express-reloadable">@artsy/express-reloadable</a>, a small utility package meant to be used with Express.</p>

<p>Here's a full example:</p>

<pre><code class="js">import express from 'express'
import { createReloadable, isDevelopment } from '@artsy/express-reloadable'

const app = express()

if (isDevelopment) {

  // Pass in app and current `require` context
  const reloadAndMount = createReloadable(app, require)

  // Note that if you need to mount an app at a particular root (`/api`), pass
  // in `mountPoint` as an option.
  app.use('/api', reloadAndMount(path.resolve(__dirname, 'api'), {
    mountPoint: '/api'
  }))

  // Otherwise, just pass in the path to the express app and everything is taken care of
  reloadAndMount(path.resolve(__dirname, 'client'))
} else {
  app.use('/api', require('./api')
  app.use(require('./client')
}

app.listen(3000, () =&gt; {
  console.log(`Listening on port 3000`)
})
</code></pre>

<p>In Force, we mounted this library <a href="https://github.com/artsy/force/blob/master/lib/setup.js#L205">at the root</a>, allowing us to make changes anywhere within our numerous sub-apps and with a fresh page reload instantly see those changes reflected without a restart. This approach also works great with API servers, as this implementation from Artsy's <a href="https://github.com/artsy/positron/blob/master/boot.js#L34">editorial app Positron</a> shows. Like magic, it "just works". Why isn't this trick more widely used and known?</p>

<a name="Step.3:.The.View.Layer..or:.How.I.Stopped.Worrying.and.Learned.to.Love.Legacy.UI"></a>
<h2>Step 3: The View Layer, or: How I Stopped Worrying and Learned to Love Legacy UI</h2>

<p>This one was a bit tricky to solve, but ultimately ended up being fairly straightforward and conceptually simple. In Force, we've got dozens of apps built on top of hundreds of components supported by thousands of tests stretched across desktop and mobile. From the perspective of sheer code volume these things aren't going anywhere any time soon. On top of that, our view templates are built using Jade (now known as <a href="https://pugjs.org">Pug</a>), which supports an interesting form of inheritance known as <a href="https://pugjs.org/language/inheritance.html">blocks</a>. What this means in practice is our UI has been extended in a variety of complex ways making alternative view engines difficult on the surface to interpolate.</p>

<p>What to do? It's 2017 and the era of handlebars templates bound to Backbone MVC views is over. We want <a href="https://facebook.github.io/react/">React</a>! We want <a href="https://www.styled-components.com/">Styled Components</a>! And when those tools are surpassed by the Next Big Thing we want that too! But we also want our existing CoffeeScript and Jade and old-school <code>Backbone.View</code>s as well.</p>

<p>Thinking through this problem, <a href="https://github.com/artsy/stitch">@artsy/stitch</a> was born.</p>

<p>Stitch helps your Template and Component dependencies peacefully co-exist. You feed it a layout and some data and out pops a string of compiled html that can be passed down to the client. "Blocks" can be added that represent portions of UI, injected by key. It aims for maximum flexibility: templating engines supported by <a href="https://github.com/tj/consolidate.js">consolidate</a> can be installed and custom rendering engines <a href="https://github.com/artsy/stitch#custom-renderers">can be swapped out or extended</a>. With very little setup it unlocks UI configurations that have been lost to time.</p>

<p>A basic example:</p>

<p>
```html</p>

<div>
  {{title}}
</div>


<pre><code>
</code></pre>

<p>const html = await renderLayout({
  layout: 'templates/layout.handlebars',
  data: {
    title: 'Hello!'
  }
})</p>

<p>console.log(html)</p>

<p>// => Outputs:
/*</p>

<div>
  Hello!
</div>


<p>*/
```</p>

<p>By adding "blocks" you can begin assembling (or adapting to) more complex layouts. Blocks represent either a path to a template or a component (with "component" meaning a React or <a href="https://preactjs.com">React-like</a> function / class component):</p>

<p>
```html
// templates/layout.handlebars</p>

<p><html>
  <head>
    <title>
      {{title}}
    </title>
  </head>
  <body
    {{{body}}}
  </body>
</html>
```
</p>

<pre><code class="js">// index.js

const html = await renderLayout({
  layout: 'templates/layout.handlebars',
  data: {
    title: 'Hello World!',
  },
  blocks: {
    body: (props) =&gt; {
      return (
        &lt;h1&gt;
          {props.title}
        &lt;/h1&gt;
      )
    }
  }
})

console.log(html)

// =&gt; Outputs:
/*
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;
      Hello World!
    &lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
*/
</code></pre>

<p>In Force, we're using this to pattern to incrementally migrate portions of our app over to React, by taking existing block-based Jade layouts and injecting <code>ReactDOM.renderToString</code> output into them, and then rendering the layout into an HTML string that is passed down from the server and rehydrated on the client, isomorphically.</p>

<p>Our existing Backbone views take advantage of the <code>templates</code> key:</p>

<pre><code class="js">// server.js

import LoginApp from 'apps/login/LoginApp'
import { Provider } from 'react-redux'
import { StaticRouter } from 'react-router'

const html = await renderLayout({
  layout: 'templates/layout.handlebars',
  data: {
    title: 'Login / Sign-up',
  },
  templates: {
    login: 'templates/login.jade'
  },
  blocks: {
    app: (props) =&gt; (
      &lt;Provider store={store}&gt;
        &lt;StaticRouter&gt;
          &lt;LoginApp {...props} /&gt;
        &lt;/StaticRouter&gt;
      &lt;/Provider&gt;
    )
  }
})

res.send(html)
</code></pre>

<p>Similar to blocks, templates located in this object are pre-compiled and available to your components as <code>props.templates</code>.</p>

<p>Once the html has been sent over the wire, we mount it like so:</p>

<pre><code class="js">// client.js

import LoginApp from 'apps/login/LoginApp'

React.render(
  &lt;LoginApp {...window.__BOOTSTRAP__} /&gt; // Data passed down from `data` key
)
</code></pre>

<pre><code class="js">// apps/login/LoginApp.js

import React from 'react'
import Login from 'apps/login/Login'

export default function LoginApp (props) {
  const {
    templates: {
      login
    }
  } = props

  return (
    &lt;Login
      template={login}
    /&gt;
  )
}
</code></pre>

<p>During the server-side render phase existing template code will be rendered with the component, and once the component is mounted on the client <code>componentDidMount</code> will fire and the Backbone view instantiated:</p>

<p>
```js
// apps/login/Login.js</p>

<p>import React, { Component } from 'react'
import LoginBackboneView from 'apps/login/views/LoginView'</p>

<p>export default class Login extends Component {
  componentDidMount () {
    this.loginView = new LoginBackboneView()
    this.loginView.render()
  }</p>

<p>  componentWillUnmount () {
    this.loginView.remove()
  }</p>

<p>  render () {
    return (
      <div>
        <div dangerouslySetInnerHtml={{
          __html: this.props.template
        }}>
      </div>
    )
  }
}
```
</p>

<p>All of the possibilities that Stitch provides are too numerous to go over here, but check out the <a href="https://github.com/artsy/stitch#usage">documentation</a> and <a href="https://github.com/artsy/stitch/tree/master/examples">example apps</a> for more complete usage. While new, this pattern has worked quite well for us and has allowed Force to evolve alongside existing code with very little friction.</p>

<a name="Moving.Forward"></a>
<h2>Moving Forward</h2>

<p>A common thread that connects <a href="https://github.com/artsy/force">Force</a> to <a href="https://github.com/artsy/eigen">Eigen</a> (Artsy's mobile app) is an understanding that while grand re-writes will gladly remove technical debt, technical debt is not our issue. A lot of the patterns we've laid down within our apps still work for us, and many of our implementations remain sufficient to the task. What we needed was an environment where <em>incremental revolution</em> was possible, where old ideas could merge with new and evolve. In terms of Eigen, we felt the best way forward was the adoption of <a href="https://facebook.github.io/react-native/">React Native</a> -- and <a href="https://github.com/artsy/emission">Emission</a> was born. Likewise, for our web and web-based mobile apps, <a href="https://github.com/artsy/reaction">Reaction</a> is serving a similar role. Both of these projects are built with <a href="https://www.typescriptlang.org/">TypeScript</a>, and both rely heavily on functionality that our <a href="http://graphql.org/">GraphQL</a> interface <a href="https://github.com/artsy/metaphysics">Metaphysics</a> provides. But crucially, these projects <em>augment</em> our existing infrastructure; they don't replace it. They fit in with existing ideas, tools and processes that have facilitated Artsy's growth, including highly-specific domain knowledge that our engineers have built up over time.</p>

<p>In conclusion, I hope this post has provided a bit of a window into some of our processes here at Artsy for those facing similar challenges. For those wanting to take a deeper dive, check out the links below:</p>

<ul>
<li>https://github.com/artsy/express-reloadable</li>
<li>https://github.com/artsy/stitch</li>
<li>https://github.com/artsy/reaction</li>
<li>https://github.com/artsy/emission</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Peril to the Artsy Org]]></title>
    <link href="http://artsy.github.io/blog/2017/09/04/Introducing-Peril/"/>
    <updated>2017-09-04T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/09/04/Introducing-Peril</id>
    <content type="html"><![CDATA[<p>Once Danger Ruby was stable enough for everyday use in 2015, it became obvious that running Danger on CI was both a
positive and a negative. On the positive side, Danger has access to all artifacts created during testing - and on the negative
side it takes a long time to get feedback. It was obvious that Danger could <a href="https://github.com/danger/danger/issues/42">run on a server</a>, but it was a big unknown what that could look like.</p>

<p>Eventually, <a href="/blog/2017/06/30/danger-one-oh-again/">I came to the conclusion</a> that we would need a JavaScript replacement of Danger - and so I applied
constraints to Danger JS that made a server-side version of Danger a possibility. It was a stroke of luck that around the
time Danger JS became usable for day to day usage, that GitHub introduced <a href="https://developer.github.com/changes/2016-09-14-Integrations-Early-Access/">GitHub Apps</a> - so I started work on Peril. Peril is server-side Danger. The rest of this post talks about how we use it Artsy today, how you can use it yourself and where it's heading.</p>

<!-- more -->


<p>In December 2016, I built out Peril in a sandbox org: <a href="https://github.com/PerilTest">PerilTest</a>, this gave me the chance to get a lot of things wrong safely. My biggest worry around Peril was leaking data though someone abusing the ability to evaluate a Dangerfile.</p>

<p>In May 2017, I introduced Peril into Artsy's org, GitHub apps have the ability to pick and choose which repos to work with.
I scoped the repos to existing open source projects which I was familiar with (<a href="https://github.com/artsy/emission">Emission</a>, <a href="https://github.com/artsy/reaction">Reaction</a> and <a href="https://github.com/artsy/positron">Positron</a>)
which gave a space to ensure stability and handle production edge-cases.</p>

<p>In August 2017, I created a new Peril instance for CocoaPods. I then finally flipped the switch to turn Peril on for all
repos on the Artsy org and formalized the RFC process for changes. This is where we are now.</p>

<a name="Getting.Set.Up"></a>
<h2>Getting Set Up</h2>

<p>For our Artsy org, I followed and improved the guide: <a href="https://github.com/danger/peril/blob/master/docs/setup_for_org.md">Setup for Org</a>. There are three key components:</p>

<ul>
<li>Creating a GitHub app for your Org</li>
<li>Hosting a Peril server</li>
<li>Making up a Peril settings repo</li>
</ul>


<p>The guide covers the initial setup, but I'd like to cover the third part of our setup.</p>

<a name="How.Artsy.s.Peril.works"></a>
<h2>How Artsy's Peril works</h2>

<p>The Artsy Peril settings are all on <a href="https://github.com/artsy/artsy-danger">artsy/artsy-danger</a>. The Artsy Peril heroku instance has the ENV var
<code>"DATABASE_JSON_FILE"</code> set to <code>"artsy/artsy-danger@peril.settings.json"</code>, so Peril will use <a href="https://github.com/artsy/artsy-danger/blob/master/peril.settings.json">that file</a> as the source of truth for all config. Here's what it is today:</p>

<p></article>
<article class='split-desktop-only'></p>

<div style='flex:1; display: block;'>

```json
{
  "settings": {
    "modules": [
      "danger-plugin-spellcheck", 
      "danger-plugin-yarn", 
      "@slack/client"
    ],
    "env_vars": ["SLACK_RFC_WEBHOOK_URL"]
  },
  "rules": {
    "pull_request": "artsy/artsy-danger@org/all-prs.ts"
  },
  "repos" : {
    "artsy/reaction": {
      "pull_request": "danger/pr.ts"
    },
    "artsy/positron": {
      "pull_request": "dangerfile.ts"
    },
    "artsy/artsy-danger": {
      "issues.opened": "artsy/artsy-danger@danger/new_rfc.ts"
    }
  }
}
```

</div>


<div style='flex:1; display: block; padding:0 20px;'>

<p><code>"settings":</code> These settings which conform to today's <a href='https://github.com/danger/peril/blob/752afeb37e3c1fdec512eb91687747d9a8a29337/source/db/index.ts#L26-L31'>GitHubInstallationSettings</a>, here's the <a href='https://github.com/danger/peril/blob/master/source/db/index.ts'>current version</a>. These are org-wide settings
that require a new deploy of the server to re-create.</p>

<p><code>"rules":</code> These are rules which are applied to every repo that Peril has access to. So in this case, every Pull Request in the org will make Peril run the Dangerfile at <code>"artsy/artsy-danger@org/all-prs.ts"</code>.</p>

<p><code>"repos":</code> These are repo-specific overrides, so a Pull Request to artsy/reaction would trigger both the org-wide Dangerfile, and one on the reaction repo.</p>

</div>


<p></article>
<article class='post'></p>

<a name="Events"></a>
<h2>Events</h2>

<p>A Dangerfile evaluation occurs once a GitHub webhook is sent. In the above examples there are two events that Danger supports:
<code>"pull_request"</code> and <code>"issues.opened"</code>. These are qualifiers that GitHub provide as a <a href="https://developer.github.com/v3/activity/events/types/events">Webhook EventTypes</a>.</p>

<p>There's a lot of them: <code>commit_comment</code>, <code>create</code>, <code>delete</code>, <code>deployment</code>, <code>deployment_status</code>, <code>fork</code>, <code>gollum</code>, <code>installation</code>, <code>installation_repositories</code>, <code>issue_comment</code>, <code>issues</code>, <code>label</code>, <code>marketplace_purchase</code>, <code>member</code>, <code>membership</code>, <code>milestone</code>, <code>organization</code>, <code>org_block</code>, <code>page_build</code>, <code>project_card</code>, <code>project_column</code>, <code>project</code>, <code>public</code>, <code>pull_request</code>, <code>pull_request_review</code>, <code>pull_request_review_comment</code>, <code>push</code>, <code>release</code>, <code>repository</code>, <code>status</code>, <code>team</code>, <code>team_add</code>, <code>watch</code>.</p>

<p>Some of these events also have unique sub-actions too:</p>

<ul>
<li><p>For an <code>issue</code> event there is: <code>assigned</code>, <code>unassigned</code>, <code>labeled</code>, <code>unlabeled</code>, <code>opened</code>, <code>edited</code>,  <code>milestoned</code>, <code>demilestoned</code>, <code>closed</code>, or <code>reopened</code></p></li>
<li><p>For a <code>pull_request</code> event there is: <code>assigned</code>, <code>unassigned</code>, <code>review_requested</code>, <code>review_request_removed</code>, <code>labeled</code>, <code>unlabeled</code>, <code>opened</code>, <code>edited</code>, <code>closed</code>, or <code>reopened</code></p></li>
</ul>


<p>The way that you define rules in Peril gives you the ability to either focus on one action for an event type: <code>"issues.opened"</code> or all actions
on an event: <code>"pull_request"</code>. Once you get your head around this, you start to get a sense of the scope of Peril. At Artsy, we've barely scratched the surface.</p>

<a name="Growth"></a>
<h3>Growth</h3>

<p>I've always advocated that Danger, and Peril should be <a href="http://danger.systems/js/usage/culture.html">applied incrementally</a>. This applies even more when you're
making org changes that affect every developer - at least with Danger you can see the Pull Request that changes
the Dangerfile. With Peril you get none of that.</p>

<p>So, we introduced <a href="https://github.com/artsy/artsy-danger/#rfcs">an RFC process for Peril changes</a>. There's not much to it, if you want to add a rule that
affects everyone then you need to make an issue following a template and then wait a week. If you make a new issue that
includes the title <code>RFC:</code> then Peril sends a slack message to our developer Channel</p>

<p><img src="/images/peril/peril-rfc.png" alt="/images/peril/peril-rfc.png" /></p>

<p>This was simple to build via Peril, I first added the npm module: <code>"@slack/client"</code> to the <code>"modules"</code> array, making it available to a Dangerfile. Then I added an environment variable to Peril for a newly minted Slack Incoming Webhook URL, and exposed it to Dangerfiles via: <code>"env_vars": ["SLACK_RFC_WEBHOOK_URL"]</code>.</p>

<p>Then I added a per-repo rule:</p>

<pre><code class="json">    "artsy/artsy-danger": {
      "issues.opened": "artsy/artsy-danger@danger/new_rfc.ts"
    }
</code></pre>

<p>This means the Dangerfile is only ran on <code>"issues"</code> with an <code>"opened"</code> action. I didn't want the discussion around a rule spamming our slack with webhooks from the other actions. The file <code>danger/new_rfc.ts</code> looks like this:</p>

<pre><code class="ts">import { schedule, danger } from "danger"
import { IncomingWebhook } from "@slack/client"
import { Issues } from "github-webhook-event-types"

declare const peril: any // danger/danger#351

const gh = danger.github as any as Issues
const issue = gh.issue

if (issue.title.includes("RFC:")) {
  var url = peril.env.SLACK_RFC_WEBHOOK_URL || "";
  var webhook = new IncomingWebhook(url)
  schedule( async () =&gt; {
   await webhook.send({
      unfurl_links: false,
      attachments: [{
        pretext: "ðŸŽ‰ A new Peril RFC has been published.",
        color: "good",
        title: issue.title,
        title_link: issue.html_url,
        author_name: issue.user.login,
        author_icon: issue.user.avatar_url
      }]
    })
  })
}
</code></pre>

<p>For events that are not a <code>"pull_request"</code> the <code>danger.github</code> object is the JSON for the event.  You can get TypeScript types available for every GitHub event via the NPM module <a href="https://www.npmjs.com/package/github-webhook-event-types">github-webhook-event-types</a> which makes it much easier to work with.</p>

<a name="Where.to.go.from.here."></a>
<h2>Where to go from here?</h2>

<p>Right now we have <a href="https://github.com/artsy/artsy-danger/issues?utf8=%E2%9C%93&amp;q=is%3Aissue%20RFC">a few RFCs</a>, and I don't spend all day making Peril rules, I've gotta <a href="https://github.com/artsy/emission/pulls?utf8=%E2%9C%93&amp;q=consignments%20">do work y'know</a>. We're going to slowly build out our Peril infrastructure.</p>

<p>I'm interested in exploring two ideas big for peril at the moment:</p>

<ul>
<li><p>What a Peril plugin system looks like: You can include modules which can listen to events and react themselves. An org-wide spellcheck on markdown files could be as easy as including <code>"modules": ["peril-plugin-spellcheck"]</code>.</p></li>
<li><p>What <a href="https://github.com/danger/peril/issues/138">scheduled jobs</a> could look like for Peril: We have a bunch of checks I'd like to make on a a regular occasion, and then passing back feedback via slack or making an issue on the repo.</p></li>
</ul>


<p> For example if a repo has an owner who isn't in Artsy anymore, we should highlight that it needs a new owner.</p>

<p>If you're interested in using Peril in large OSS projects, take a look at how Peril is used in CocoaPods via <a href="https://github.com/CocoaPods/peril-settings">CocoaPods/peril-settings</a>.</p>

<p>If you're interested in using Peril in your org, run through the <a href="https://github.com/danger/peril/blob/master/docs/setup_for_org.md">Setup for Org</a> guide and help improve it when you inevitably have some weird issues.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploration: Front-end JavaScript at Artsy in 2017]]></title>
    <link href="http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/"/>
    <updated>2017-02-05T12:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017</id>
    <content type="html"><![CDATA[<center>
 <img src="/images/js2017/js.svg" style="width:300px;">
</center>


<p>The Artsy web team have been early adopters of node, and for the last 4 years the stable stack for the Artsy website has been predominantly been Node + CoffeeScript + Express + Backbone. In 2016 the mobile team <a href="/blog/2016/08/15/React-Native-at-Artsy/">announced</a> that it had moved to React Native, matching the web team as using JavaScript as the tools of their trade.</p>

<p>Historically we have always had two separate dev teams for building Artsy.net and the corresponding iOS app, we call them (Art) Collector Web, and Collector Mobile. By the end of 2016 we decided to merge the teams. The merger has given way to a whole plethora of ideas about what contemporary JavaScript looks like and we've been experimenting with finding common, natural patterns between web and native.</p>

<p>This post tries to encapsulate what we consider to be our consolidated stack for web/native Artsy in 2017.</p>

<p><strong>TLDR:</strong> <a href="#TypeScript">TypeScript</a>, <a href="#GraphQL">GraphQL</a>, <a href="#React...React.Native">React/React Native</a>, <a href="#Relay">Relay</a>, <a href="#Yarn">Yarn</a>, <a href="#Jest">Jest</a>, and <a href="#Visual.Studio.Code">Visual Studio Code</a>.</p>

<!-- more -->


<a name="Overview"></a>
<h2>Overview</h2>

<p>Our web stack has been <a href="/blog/2013/11/30/rendering-on-the-server-and-client-in-node-dot-js/">ezel.js</a> since 2013, and continues to be a mature and well thought out technology. Since then, there has been explorations on a successor to that framework using React and GraphQL with <a href="https://github.com/muraljs/mural">muraljs</a>. However, since the merger, a lot more of our focus has been on trying to find something that feels similar on both React and React Native.</p>

<center>
 <img src="/images/js2017/ts.svg" style="width:300px;">
</center>


<a name="TypeScript"></a>
<h2>TypeScript</h2>

<p><a href="http://www.typescriptlang.org">TypeScript</a> and <a href="https://flowtype.org/">Flow</a> really moved JavaScript forwards in the last few years. They both tackle the essential problems of "how can I trust my code does what I think", "how can I be sure of this change" and "how can I build better tools for JavaScript" in different ways.</p>

<p>Yes, the title of this section is TypeScript and yet I instantly include Flow. I don't think you can, or should talk about TypeScript without understanding it's relationship to Flow.</p>

<p>Both <a href="http://www.typescriptlang.org/play/#src=function%20addNumbers(first%3A%20number%2C%20second%3A%20number)%20%7B%0D%0A%09return%20first%20%2B%20second%0D%0A%7D%0D%0A%0D%0AaddNumbers(1%2C%202)%0D%0A">TypeScript</a> and <a href="https://flowtype.org/docs/five-simple-examples.html#adding-type-annotations">Flow</a> provide a structure for applying Types to JavaScript.</p>

<p>Both <a href="http://www.typescriptlang.org/play/#src=var%20one%20%3D%201%0D%0A%0D%0Aone%20%3D%20%22%22%0D%0A">TypeScript</a> and <a href="https://flowtype.org/docs/classes.html#type-annotations-vs-inference">Flow</a> will infer typing metadata from untyped data.</p>

<p>Both <a href="https://www.npmjs.com/%7Etypes">TypeScript</a> and <a href="https://github.com/flowtype/flow-typed">Flow</a> have systems for applying types to node modules.</p>

<p>We initially went with Flow, as Flow is a <a href="https://discuss.reactjs.org/t/if-typescript-is-so-great-how-come-all-notable-reactjs-projects-use-babel/4887">considerably easier sell</a> to others, as it integrates inside existing JavaScript projects with less issues. Flow acts as a separate tool to a babel-based JavaScript project, whereas TypeScript is a full on replacement for that tooling.</p>

<p><em>Why bother though?</em> JavaScript has existed for decades without type annotations, and everyone seems to have got on pretty well. One of the key features that a typing system gives you is top-notch tooling. An editor can use the type interfaces to provide auto-completion, inline documentation and inline warning/errors as you work. Type systems will help catch errors before you have even pressed save.</p>

<p></article>
<a href='/images/js2017/types.png' style="">
  <img src="/images/js2017/types.png" alt="The Artsy Tech Stack 2017" style="width:100%;">
</a>
<article class="post">
</p>

<p>What works really well for typed JavaScript is that you can easily opt out of it when you need to. Then you're back to normal "do whatever you want" JavaScript land, no problem.</p>

<p>We moved from Flow simply because TypeScript had better integration with <a href="https://code.visualstudio.com">Visual Studio Code</a> (VS Code). For a few months I devoted time to improving the Flow integration in VS Code, and tried learning OCaml to help out on the <a href="https://github.com/facebook/flow">Flow tool</a> itself. In the end though, when we compared to how solid VS Code felt with TypeScript - we decided it was worth converting our projects.</p>

<p>Both TypeScript and Flow provide nearly every Type structure found inside Objective-C and Swift, so teaching the rest of the team how they work is easy from our native experiences.</p>

<p><a name="TypeScript-Extension"></a>One particularly interesting part of TypeScript that we are keeping our eyes on is this <a href="https://github.com/Microsoft/TypeScript/issues/6508">language extensibility issue</a>, if it turns out well, we will be looking into integrating the other technologies mentioned here into TypeScript itself.</p>

<center>
 <img src="/images/js2017/graphql.svg" style="width:300px;">
</center>


<a name="GraphQL"></a>
<h2>GraphQL</h2>

<p>GraphQL is a way to handle API requests. I consider it the successor to REST when working with front-end clients. A big claim, yeah. So, what is it?</p>

<p>Officially <a href="https://github.com/facebook/graphql">GraphQL is a specification</a>. A server can conform to the GraphQL spec, and then clients can make queries against it. Think of it a bit like how SQL is a standardized way of doing database queries across multiple databases types.</p>

<p>As a client, you <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Networking/ARRouter.m#L1011">send</a> a "<a href="http://graphql.org/docs/getting-started/#queries">JSON-shaped query</a>" structure, which is hierarchical and easy to read:</p>

<pre><code class="json">{
  artwork(id: "kimber-berry-as-close-to-magic-as-you-can-get") {
    id
    additional_information

    is_price_hidden
    is_inquireable
  }
}
</code></pre>

<blockquote><p>This will search for a <a href="https://www.artsy.net/artwork/kimber-berry-as-close-to-magic-as-you-can-get">specific artwork</a>, with the response JSON as the Artwork's <code>id</code>, <code>additional_information</code>, <code>is_price_hidden</code> and <code>is_inquireable</code>.</p></blockquote>

<p>It's important to note here, the data being sent <em>back</em> is specifically  what you ask for. This is not defined on the server as a <em>short</em> or <em>embedded</em> version of a model, but the specific data the client requested. When bandwidth and speed is crucial, this is the other way in which GraphQL vastly improves an app-user's experience.</p>

<p>This is in stark contrast to other successors to REST APIs, the hypermedia APIs, like <a href="http://stateless.co/hal_specification.html">HAL</a> and <a href="http://jsonapi.org">JSON-API</a> - both of which are optimised for caching, and rely on "one model, one request" types of API access. E.g. a list of Artworks would actually contain a list of hrefs instead of the model data, and you have to fetch each model in a separate request.</p>

<p>Hypermedia APIs have a really useful space in cross-server communications, but are extremely wasteful of the most precious resource for a front-end device - bandwidth. <a href="latency">Latency matters considerably</a>, on mobile where bandwidth is spotty, and attention spans are short you need to do everything possible to show more than a loading spinner.</p>

<p>I have previously explored our usage of GraphQL from the perspective of a native developer <a href="/blog/2016/06/19/graphql-for-mobile/">in 2016</a>. So I'll leave that post to describe our implementation of a GraphQL server.</p>

<p>One exciting movement in the space of GraphQL is <a href="https://githubengineering.com/the-github-graphql-api/">GitHub moving to GraphQL</a> for their new APIs.</p>

<center>
 <img src="/images/react-native/artsy_react_logo.svg" style="width:300px;">
</center>


<a name="React...React.Native"></a>
<h2>React / React Native</h2>

<p>React is a Facebook project which offers a uni-direction Component model that <em>can</em> replace MVC in a front-end application. React was built out of a desire to abstract away a web page's true view hierarchy (called the DOM) so that they could make changes to the view in memory and then React would handle finding the differences between view states.</p>

<p>You create a set of Components to encapsulate each part of the state of the page. React makes it easy to make components that are functional in the <a href="https://en.wikipedia.org/wiki/functional_reactive_programming">Functional Reactive Programming</a> sense. They act like a function which takes some specially declared state and it is rendered into HTML.</p>

<p>A component optionally uses a language called <a href="#jsx">JSX</a> to visualise how each component's child components are set up, here's an example of a React component using JSX <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/home/search_bar.js">from Emission, our React Native library</a>:</p>

<pre><code class="js">export default class SearchBar extends React.Component {
  render() {
    return (
      &lt;TouchableWithoutFeedback onPress={this.handleTap.bind(this)}&gt;
        &lt;View style={styles.container}&gt;
          &lt;Image style={styles.searchIcon} source={require('../../../images/SearchButton.png')}/&gt;
          &lt;Text style={styles.text}&gt;Search for artists and artworks...&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/TouchableWithoutFeedback&gt;
    )
  }

  handleTap() {
    Switchboard.presentModalViewController(this, '/search')
  }
}
</code></pre>

<p>By providing a well encapsulated Component model, you can aggressively reduce the amount of redundant code you need to build an application. By not initially writing to the DOM, React can decide what has changed between user actions and that means you have to juggle significantly less state.</p>

<p>We can then build on React via React-Native to allow the same style of code to exist inside the mobile sphere, where typically you have had unique languages and tooling.</p>

<p>React Native is an implementation of React where instead of having React's virtual DOM map to a web page's DOM, it creates a native view hierarchy. In the case of iOS that is a <code>UIView</code> hierarchy, and in Android, a <code>View</code> hierarchy.</p>

<p>If you'd like to find out why the iOS team moved to React Native, check our <a href="/series/react-native-at-artsy/">series of posts on React Native</a>.</p>

<center>
 <img src="/images/js2017/relay.svg" style="width:300px;">
</center>


<a name="Relay"></a>
<h2>Relay</h2>

<p>Any front-end client has a lot of work to do on every page:</p>

<ul>
<li>Fetching all the data for a view hierarchy.</li>
<li>Managing asynchronous state transitions and coordinating concurrent requests.</li>
<li>Managing errors.</li>
<li>Retrying failed requests.</li>
<li>Updating the local cache after receiving new results/changes the server objects responses.</li>
<li>Optimistically updating the UI while waiting for the server to respond to mutations.</li>
</ul>


<p>This is typically handled in a per-page basis, for example the API details, and state management between a Gene page, and an Artist page are different. In part because they have different data-models, but also that they have different correlated data. However, they do share a lot of the common responsibilities mentioned above. In our native side, we struggled to find abstractions that would work across multiple pages. Relay fixes this, and does it in a shockingly elegant way.</p>

<p>Relay is a framework for building data-driven React apps which relies on a deep connection to GraphQL. You wrap your React components inside a Relay container, which handles the networking and setting the state for your component.</p>

<pre><code class="js">// This is a normal React component, taken directly from our app
// It will optionally show a description if one exists on a gene.

class Biography extends React.Component {
  render() {
    const gene = this.props.gene
    if (!gene.description) { return null }

    return (
      &lt;View&gt;
        &lt;SerifText style={styles.blurb} numberOfLines={0}&gt;{gene.description}&lt;/SerifText&gt;
      &lt;/View&gt;
    )
  }
}

// Take the above component `Biography`, and wrap it with a Relay Container.
// Then provide what parts of a GraphQL request the `Biography` needs

export default Relay.createContainer(Biography, {
  fragments: {
    gene: () =&gt; Relay.QL`
      fragment on Gene {
        description
      }
    `,
  }
})

// When the `Biography` component is rendered, the component is given props of 
// `gene` with a `description` by the Relay container. 
</code></pre>

<p>Relay handles this by having each component in your view hierarchy exposing the fragments of a GraphQL query. There is a pre-render stage where all of your components fragments are brought together to make a single API request. So in the case of the Gene, it may look something like:</p>

<pre><code class="json">{
  gene(id: "the-fantastic") {
    // could have come from the root component's fragment
    id
    name 

    // came from the above Header fragment
    description 

    // could have come from a RelatedArtists component's fragment
    trending_artists {
      name
      href
    }
  }
}
</code></pre>

<p>The data is first looked up inside Relay's local cache, and then any un-cached items are requested from the network. The results of the query is then moved into the component via it's props. Relay will only provide the specific data each component has requested. So the <code>Header</code> component would get nothing for <code>this.props.gene.name</code>. This data-masking is a great way of ensuring the connection between component and API.</p>

<p>I'd strongly recommend taking the dive into both the <a href="https://facebook.github.io/relay/docs/thinking-in-graphql.html">Thinking with GraphQL</a> and then <a href="https://facebook.github.io/relay/docs/thinking-in-relay.html">Thinking with Relay</a> tutorials to learn more. Finally, <a href="https://www.learnrelay.org">Learn Relay</a> and <a href="https://sgwilym.github.io/relay-visual-learners/">Relay for Visual Learners</a> are great tutorials to help you get comfortable with the concepts.</p>

<center>
 <img src="/images/js2017/yarn.svg" style="width:300px;">
</center>


<a name="Yarn"></a>
<h2>Yarn</h2>

<p>I have a lot of respect for NPM, their scale is <a href="http://blog.npmjs.org/post/143451680695/how-many-npm-users-are-there">through the roof</a>. They built out the foundations for a massive, thriving community. They did a great job. Like a lot of the JavaScript ecosystem, their tooling allows you to get away with a lot of things. You can have the same dependency inside the app with multiple versions, or apps with a dependency tree that is different each time you run <code>npm install</code>.</p>

<p>We have multiple engineers who have worked on a dependency manager for half a decade, having indeterminate builds in JavaScript was something that worried us greatly. Luckily, there is <a href="https://yarnpkg.com">Yarn</a>.</p>

<p>Yarn is a Facebook project that replaces the NPM <a href="https://en.wikipedia.org/wiki/Command-line_interface">cli</a> client. It's very new, so unlike NPM it does not have to worry about backwards compatibility. It is what I'd imagine a fresh re-write of the NPM cli would look like.</p>

<p>Yarn is significantly faster, has a determinate process for setting up projects and uses a lockfile by default to ensure everyone using the project gets the exact same dependency tree. It uses NPM as a server, and so you get the same node modules as with the NPM cli.</p>

<p>Sometimes Yarn gives you pleasant surprises too, my favourite being that <code>yarn [x]</code> will check to see if that is a local command that you could run, saving a bunch of redundant settings.</p>

<p>Converting a codebase can be as simple as going into your project and running:</p>

<pre><code class="sh">npm install -g yarn
yarn install
</code></pre>

<p>Now you have a lockfile, and are using yarn. Awesome, if you are migrating from a project with a shrink-wrap - I have a script which will generate a summary of the changes for you: <a href="https://gist.github.com/orta/cb6d0b8256852c1f01ecf1d803b664c9">script</a>, <a href="https://github.com/artsy/metaphysics/pull/479">example</a>.</p>

<center>
 <img src="/images/js2017/jest.svg" style="width:300px;">
</center>


<a name="Jest"></a>
<h2>Jest</h2>

<p>One of the things that I find particularly pleasant about the JavaScript ecosystem are their testing tools. With our React Native, we came into the ecosystem with fresh eyes, and it was pretty obvious that Jest was an exceptional testing framework. I hear historically Jest has been a bit meh, but it is without a doubt worth another look.</p>

<p><strong>The watcher</strong> - The majority of your usage of Jest is with it running in watcher mode. This mode uses your git diff as a seed for what to run tests against. Jest will use that diff to define all the files that the changed code touches, and then all of the tests that cover those files.</p>

<p>For example, I make a change in one source file and 60 tests run from 6 different test suites. Finishing in under a second.</p>

<p></article>
<a href='/images/js2017/jest-watcher.gif' style="">
  <img src="/images/js2017/jest-watcher.gif" alt="Jest's awesome watch mode" style="width:100%;">
</a>
<article class="post">
</p>

<p>Not all tests are as important to a run, so Jest also keeps track of which tests failed last time and will run those first next time. This reduces iteration time considerably.</p>

<p><strong>Fast and safe</strong> - You think the watcher is smart? Well the way Jest handle test suites is also extremely elegant. Jest keeps track of how long each test suite took to run, and then will weigh the test suites across different processes in order to speed up the overall test suite. If Jest thinks they're all going to be really quick (like my GIF above) they will all happen in one process, as that can also be faster.</p>

<p>Each test suite is an entirely sandboxed node virtual machine, so you cannot have tests influencing each other.</p>

<p><strong>Snapshots</strong> - Jest provides a concept called snapshots, which provides an easy way to compare JavaScript objects. One place where this really shines is with React components. <a href="https://github.com/artsy/emission/blob/ec565b8492540b4e33066364b415c7906ec1e028/lib/containers/__tests__/gene-tests.js#L121-L158">For example</a>:</p>

<pre><code class="js">it('looks like expected', () =&gt; {
  const props = {
      gene:{...}
    }

  const tree = renderer.create(
    &lt;Gene geneID={props.gene.name} medium="painting" price_range="*-100000" gene={props.gene}/&gt;
  ).toJSON()

  expect(tree).toMatchSnapshot()
})
</code></pre>

<p>Now we will get a test failure when any changes happen in the component tree. For example, if I changed the background color to <code>blue</code> from <code>white</code>. I get a fail like this:</p>

<p><img src="/images/js2017/jest-snapshots.png" style="width:100%"></p>

<p>While that example is trivial, we really want to have tests like this to ensure we understand how changes propagate throughout the app.</p>

<p><strong>No config</strong> - When we first integrated Jest, we had no config. Now, to make sure that TypeScript works how we'd like, we require some setup. However, having smart defaults which works in most cases say a lot about the care and attention paid to Developer Experience from the Jest team. The documentation covers default integrations for: Babel, TypeScript and webpack. Three of the biggest modern tools for getting stuff done with node.</p>

<p><strong>Comprehensive API</strong> - Snapshots, watchers, custom matchers, useful JSON output, ESLint linters, Elegant Mocking tools and natural support for async code. All in one project.</p>

<p>If you're interested, there is a lot of work around automating the migration between different testing frameworks in <a href="https://github.com/skovhus/jest-codemods">jest-codemods</a> - getting started has never been easier. I'd also recommend looking at <a href="https://wallabyjs.com">wallaby.js</a> and <a href="https://github.com/orta/vscode-jest">vscode-jest</a> for tooling.</p>

<center>
 <img src="/images/vscode/vscode_logo_artsy.svg" style="width:300px;">
</center>


<a name="Visual.Studio.Code"></a>
<h2>Visual Studio Code</h2>

<p>Had you told me two years ago that my main editor would be a JavaScript app, I'd have bought you a beer for such a great joke.</p>

<p>Visual Studio Code was the app that changed my mind.</p>

<p>I've done a longer write up on the how and why we use VS Code in <a href="/blog/2016/08/15/vscode/">JavaScript projects</a>, however here I'd like to consider the cultural aspect of the choice. It's common practice among web technologists to all have different editors on a project, and for their editors to generally do little work for them. A lot of this culture came from the TextMate and Rails days with the infamous <a href="https://twitter.com/dhh/status/492706473936314369?lang=en">blog in 15 minutes video</a>. When I was a web developer, I also did this.</p>

<p>When you spend a lot of time in a <a href="https://developer.apple.com/xcode/">powerful IDE</a>, it gets pretty hard to go back to a bare-bones editor. VS Code sits at a good (just past) half-way point between text editor and IDE. You can get a lot of the flexibility from a text editor, making it good for one off files and IDEs where you have fully spec'd out projects.</p>

<p>Being able to have project specific setups is where VS Code really starts to shine. One thing that is working well for us is to gradually add project settings for our apps, first we add the ability to run tests with an attached debugger by adding a <code>launch.json</code>:</p>

<pre><code class="json">{
    "name": "Run Tests With Debugger (slower, use yarn for normal work)",
    "type": "node2",
    "request": "launch",
    "port": 5858,
    "address": "localhost",
    "sourceMaps": true,
    "stopOnEntry": false,
    "runtimeExecutable": null,
    "runtimeArgs": [
      "--debug-brk",
      "./node_modules/.bin/jest",
      "-i"
    ],
    "cwd": "${workspaceRoot}"
}
</code></pre>

<p>With this we can showcase how easy it is to use an inline debugger with source-maps, when working with tricky test logic. No more <code>console.log</code>. That's usually a great way to start moving everyone to a consistent environment. Then we add <a href="https://code.visualstudio.com/updates/v1_6#_workspace-extension-recommendations">recommended extensions</a> to the project.</p>

<p>Trying to set a consistent  development environment might sound a bit corporate for a ~25 person dev team, but one chief advantage is that you can feel comfortable taking time at work to improve your tooling knowing it will improve the tooling of everyone else on your team.</p>

<p>I've been exploring a consolidated <a href="https://github.com/artsy/vscode-artsy">Artsy VS Code</a> extension to handle extension dependencies and small tasks, but it's still early days. It's awesome that I can even think at that level of abstraction though.</p>

<a name="End"></a>
<h3>End</h3>

<p>None of these technologies are under a year old, all of them have adoption by substantial amount of companies. Nothing feels  either controversial or novel. This is great. It feels like a lot of the interesting work for us so far has been around improving the spaces between the projects: Finding improvements for generating types <a href="https://github.com/avantcredit/gql2ts/blob/master/Changelog.md">from GraphQL</a> or <a href="https://github.com/alloy/relay2ts">Relay</a>, adding <a href="https://github.com/facebook/jest/commit/e597e5c46f8f4925d9a10c73d8eab05a2c4b8bc3">editor support to jest</a>, adding Danger to <a href="https://github.com/facebook/jest/pull/2508">our dependencies</a> and improving our <a href="https://github.com/orta/vscode-react-native-storybooks">tooling</a> <a href="https://github.com/orta/vscode-jest">for</a> <a href="https://github.com/alloy/vscode-relay">vscode</a>. The front-end is still a pretty small dev team, so we want to do high impact, small projects that can make our tools drastically better.</p>

<p>React, React-Native, Jest, Yarn are all big Facebook projects. In the iOS world, there is a sense of wariness around building an app so heavily around Facebook tech, based on <a href="http://joehewitt.com/2009/03/23/the-three20-project">three20</a> - which I think is a bit unfair. From my perspective, determining whether you should have something as a dependency <a href="/blog/2015/09/18/Cocoa-Architecture-Dependencies/">should be nuanced</a>, but at a minimum you should feel like you can contribute bug fixes and ideally you should be able to maintain the project if it needs it. With Facebook projects, they've shown to be really open to PRs and discussion, and our work in them makes us feel comfortable to maintain a fork if needed.</p>

<p>We're still exploring the space where we can share code between web and mobile. I'd like to hope within a few months we can write up how that is going on. For now, if you're interested in prototypes, we've been moving our React Native components to the web inside <a href="https://github.com/alloy/relational-theory/">Relational Theory</a> and <a href="https://github.com/orta/systems-theory/">Systems Theory</a> tries bringing new ideas from Relational Theory back to React Native.</p>

<p>I have grown to love working with typed JavaScript to ensure soundness, with React and Relay to drastically reduce the amount of code we need to write and to provide awesome root abstractions to build on. Mix that with a hackable editor with substantial language support and it feels like almost exclusively writing business domain logic.</p>
]]></content>
  </entry>
  
</feed>
