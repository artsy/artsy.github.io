<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: peril | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/peril/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2022-04-29T18:32:05+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Automation Encourages More Automation]]></title>
    <link href="https://artsy.github.io/blog/2019/01/08/automation-encourages-more-automation/"/>
    <updated>2019-01-08T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/01/08/automation-encourages-more-automation</id>
    <content type="html"><![CDATA[<p>Last year, <a href="http://artsy.github.io/blog/2018/05/07/fully-automated-standups/">I wrote about the process of fully automating our weekly engineering-wide standup</a>. One of
the benefits of automating what <em>was</em> a meeting run by a single person to a meeting run by everyone is that we
removed a <a href="https://en.wikipedia.org/wiki/Single_point_of_failure">single point of failure</a>. However, I may have fibbed just slightly when I called our standups
<em>fully</em> automated.</p>

<p>This blog post is going to cover how (and more importantly, <em>why</em>) I finally automated the last 5% of our weekly
standups. Let‚Äôs go!</p>

<!-- more -->

<hr />

<p>Our weekly standup process is a finely tuned machine. The meeting is run every Monday morning by a different pair
of engineers, based on our <a href="http://artsy.github.io/blog/2018/05/25/support-process/">on-call rotation</a>. The process is <a href="https://github.com/artsy/README/blob/eb2f23c835983223877a6031475153db93e98e8c/events/open-standup.md">documented</a> in the open, and we
improve it over time. I‚Äôm really proud of it! But there‚Äôs just one problem‚Ä¶ someone needs to make sure that the
people responsible for the meeting <em>know</em> about that responsibility.</p>

<p>So for the past 8 months, I‚Äôve begun every week by sending Slack DMs to the responsible engineers to remind them to
run the standup, including a link to the docs. This made me a single point of failure: when I was out of the
office, I always made sure to ask someone else to remind them about the meeting. What if I had forgot? Or I was
sick that day? What would happen to our finely-tuned machine?!</p>

<p>Okay, so what would probably happen is that people would remember anyway or someone would post to Slack ‚Äúhey who is
running standup today?‚Äù Automating this reminder was a pretty small priority, but it was a gap in our process, and
I wanted to patch it.</p>

<p>When I discussed all of this with my colleagues, it wasn‚Äôt long before someone brought up <a href="https://xkcd.com/1319/">the xkcd comic on
automation</a>. Oh, you know the one.</p>

<p><a href="https://xkcd.com/1319/"><center><img src="https://imgs.xkcd.com/comics/automation.png" srcset="//imgs.xkcd.com/comics/automation_2x.png 2x" alt="xkcd comic about automation" title="I wonder if people would read the hover text of an xkcd comic linked to from a different site, just out of habit? I probably would." /></center></a></p>

<p>The comic observes that, often, the work necessary to automate a task often exceeds the amount of work necessary to
just do the task manually. Pretty funny! You could be forgiven for taking the logical leap to say that automating
tasks isn‚Äôt worth it, generally, based on this observation. But that analysis would be incomplete because it
focuses entirely on saving <em>time</em>. In my experience, automating a task often yields far more value than it costs in
time.</p>

<p>Let‚Äôs take the task of sending the on-call engineers their Monday morning standup reminder. How would we even
automate that?</p>

<p>Well, first I think about how <em>I</em> do this task. First I look at the on-call schedule, shared in Google Calendar.
Then I open a DM in Slack with the engineers. I copy the pre-composed message from my recurring OmniFocus task and
send it in the DM.</p>

<p>Okay so how would I automate that? <a href="http://artsy.github.io/blog/2017/09/04/Introducing-Peril/">Artsy uses Peril already</a> to automate reminders about open RFCs, so I
piggy-backed on that existing automation. This is key: I‚Äôm not starting from scratch, I‚Äôm building upon the
existing automation infrastructure that we‚Äôve already built.</p>

<p>Next, I find out how to access the Google Calendar API using a <a href="https://cloud.google.com/iam/docs/understanding-service-accounts">Google Services Account</a>. It has an
authentication method purpose-built for server-to-server communication, which is perfect for our needs. I write
some code to pick the correct calendar events based on the current time, extract the email addresses of those
events‚Äô attendees, and handle an edge case. Then I look up the <a href="https://github.com/slackapi/node-slack-sdk#features">Slack API</a> for Peril‚Äôs platform, learn how
to authenticate with it properly from a server, and lookup Slack user IDs based on those email addresses. Finally,
compose the message and use some previously written code to post it to our #dev channel.</p>

<p>Boom. <a href="https://github.com/artsy/peril-settings/pull/87">Open a PR</a>. Add some unit tests. Done.</p>

<p><img alt="screenshot of the peril task working in Slack" src="/images/2019-01-08-automation-encourages-more-automation/success.png" /></p>

<p>I spent about four hours automating this and by my calculations, I‚Äôll recoup that time by‚Ä¶ July 2020. But like I
said, there‚Äôs more value to this than the time I saved.</p>

<p>In the process of automating this, I learned how to use <em>two</em> new APIs <em>and</em> I created infrastructure in our <a href="https://github.com/artsy/peril-settings">Peril
installation</a> to access them. Not only did I build <em>upon</em> the existing automation framework,
but I <em>contributed</em> to it so it‚Äôs easier for the next person. I even <a href="https://github.com/danger/peril/pull/407">fixed a Peril bug</a> in the process.</p>

<p>Automation encourages automation. Every time you automate a task, it gets easier to automate the next one. With
sufficient infrastructure, a sort of exponential takeoff happens: all of a sudden you‚Äôre not just automating
<em>existing</em> tasks, you‚Äôre using that infrastructure for <em>new</em> tasks. Tasks that add value to your team, like
<a href="https://github.com/artsy/peril-settings/blob/master/org/mergeOnGreen.ts">merge-on-green</a> or <a href="https://github.com/artsy/peril-settings/blob/master/tasks/compareSchemas.ts">notifying engineers of recent API changes</a>.</p>

<p>As a consequence of the nature of engineering, we often consider ideas in only terms of constraints. We define
what‚Äôs possible by what we can already accomplish. Automation is a way to hack around that habit; it encourages
engineers to think outside the box by giving us a larger box. Simple, but effective!</p>

<hr />

<p>So. Four hours of work. Was it worth it?</p>

<p>Well, let‚Äôs evaluate this in terms of <em>impact</em>. Those four hours could have kept our standups running until next
July, or they could have automated that task <em>and</em> further enhanced our automation infrastructure. And, personally,
it was very satisfying.</p>

<p>I would say that‚Äôs <em>definitely</em> worth it.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stamping the commit SHA into the ENV vars of a running Docker-based app]]></title>
    <link href="https://artsy.github.io/blog/2018/09/10/Dockerhub-Stamping-Commits/"/>
    <updated>2018-09-10T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2018/09/10/Dockerhub-Stamping-Commits</id>
    <content type="html"><![CDATA[<p>For what feels like the last 3-6 months, I‚Äôve been trying to figure out how to know what the commit is for the
Docker runtime in Peril. Roughly: every master commit on Peril triggers a Docker image on Docker Hub for the
environment in which JavaScript is running. There‚Äôs a lag between creating the commit, having the image ready on
Docker Hub, and Peril using the new image. There‚Äôs also space for these automated systems to go wrong, so I‚Äôd like
to be able to be certain in logging.</p>

<p>I‚Äôve thrown a lot of commits and time every few weeks at this, so now that I‚Äôve figured it out, I‚Äôll give you an
idea of what I needed to do to make it work in a micro-post.</p>

<!-- more -->

<p><strong>Step 1:</strong> You need a custom build step, to do this, you need to create a file <code class="language-plaintext highlighter-rouge">hooks/build</code> in your repo:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/usr/bin/env sh</span>

<span class="c"># This is so we can get the commit into the build log of a Dangerfile runner</span>
<span class="c"># These come from https://docs.docker.com/docker-cloud/builds/advanced/</span>

<span class="c"># For debugging all env vars</span>
<span class="c"># printenv</span>

<span class="c">#  Convert the location "/Dockerfile" to "Dockerfile"</span>
<span class="nv">FILE</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nt">-n</span> <span class="nv">$BUILD_PATH</span> | <span class="nb">tail</span> <span class="nt">-c</span> +2<span class="si">)</span>

<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DOCKER_TAG</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
  </span>docker build <span class="nt">--build-arg</span><span class="o">=</span><span class="nv">COMMIT</span><span class="o">=</span><span class="si">$(</span>git rev-parse <span class="nt">--short</span> HEAD<span class="si">)</span> <span class="nt">--build-arg</span><span class="o">=</span><span class="nv">BRANCH</span><span class="o">=</span><span class="nv">$SOURCE_BRANCH</span> <span class="nt">-t</span> <span class="nv">$IMAGE_NAME</span> <span class="nt">-f</span> <span class="nv">$FILE</span> <span class="nb">.</span>
<span class="k">else
  </span>docker build <span class="nt">--build-arg</span><span class="o">=</span><span class="nv">COMMIT</span><span class="o">=</span><span class="si">$(</span>git rev-parse <span class="nt">--short</span> HEAD<span class="si">)</span> <span class="nt">--build-arg</span><span class="o">=</span><span class="nv">BRANCH</span><span class="o">=</span><span class="nv">$DOCKER_TAG</span> <span class="nt">-t</span> <span class="nv">$IMAGE_NAME</span> <span class="nt">-f</span> <span class="nv">$FILE</span> <span class="nb">.</span>
<span class="k">fi</span>
</code></pre></div></div>

<p>There‚Äôs a list of examples in <a href="https://github.com/thibaultdelor/testAutobuildHooks">this repo</a> - though the build
one is too simple for our needs here. If you need something that‚Äôs not there, then remove the comment marker before
<code class="language-plaintext highlighter-rouge">printenv</code> to the script to see
<a href="https://github.com/danger/peril/commit/61f447d13476fee9fa0686225ff3ca76d416088f">what env vars</a> are available
(<a href="https://hub.docker.com/r/dangersystems/peril/builds/benoxzftncgdsmwugr9bpjn/">here‚Äôs an example build</a>).</p>

<p><strong>Step 2:</strong> Edit your <code class="language-plaintext highlighter-rouge">Dockerfile</code> to take the additional arguments <code class="language-plaintext highlighter-rouge">COMMIT</code> and <code class="language-plaintext highlighter-rouge">BRANCH</code> from <code class="language-plaintext highlighter-rouge">ARG</code>.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">MAINTAINER Orta Therox
</span><span class="gi">+ ARG BRANCH="master"
+ ARG COMMIT=""
+ LABEL branch=${BRANCH}
+ LABEL commit=${COMMIT}
</span>
ADD . /app
<span class="p">WORKDIR /app
</span>
+ # Now set it as an env var
<span class="gi">+ ENV COMMIT_SHA=${COMMIT}
+ ENV COMMIT_BRANCH=${BRANCH}
</span></code></pre></div></div>

<p>Err, that should be everything. I mean, I did call it a micro-post. Trying to implement this has broken the Peril
runner a bunch of times on staging, so I‚Äôm mainly just helping out other docker newbies.</p>

<p>Some links that helped me get there:</p>

<ul>
  <li><a href="https://github.com/docker/hub-feedback/issues/600">Add git commit hash to ENV</a></li>
  <li><a href="https://github.com/docker/hub-feedback/issues/508#issuecomment-243968310">Feature request: Build args on docker hub</a></li>
  <li><a href="https://github.com/elasticdog/tiddlywiki-docker/commit/993c7e9e8d5207d110270458f0f18839656ca126">Inject Git source commit metadata into the image</a></li>
  <li><a href="https://docs.docker.com/docker-hub/github/">Configure automated builds from GitHub</a></li>
</ul>

<p>Remember folks, Ash says you should <a href="https://ashfurrow.com/blog/contemporaneous-blogging/">write as you learn</a>, so
write up those small wins.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[On the obsessive statelessness of Peril]]></title>
    <link href="https://artsy.github.io/blog/2018/06/18/On-Obsessive-Statelessness/"/>
    <updated>2018-06-18T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2018/06/18/On-Obsessive-Statelessness</id>
    <content type="html"><![CDATA[<p>We‚Äôre at 9 months of serious usage <a href="/blog/2017/09/04/Introducing-Peril/">of Peril in Artsy</a>. However, I‚Äôve been worried.</p>

<p>To get you up to speed on Peril, Peril is a tool that takes GitHub webhooks, and makes it easy to build one-off
actions. It does this by having a per-account settings JSON, that connects JavaScript files to events from webhooks.
So, for example, you can write a rule which runs when closing an issue in GitHub that looks for associated Jira
tickets and resolves them. Peril provides no implicit actions like that, it instead offers a JavaScript runtime
environment optimised to this domain so you can make actions to fit your needs. Like a collection of single-file
<a href="https://probot.github.io">probots</a>.</p>

<p>Three months ago I started building out a ‚Äútrue‚Äù staging environment for Peril, one that allows any user or org on
GitHub to click a button and have Peril running on their account. Pulling this off has two real interesting
problems. Problem number one, security. Problem number two, my wallet.</p>

<p>Both of these issues stem from one simple problem: I need to run other people‚Äôs code on my machines and I think they
should be able to store data. Which to be quite frank, is horrifying for a side-project. So, this post explores one
of main aspects which I‚Äôve architected Peril to make this problem tractable. Avoiding storing state in the form of
data.</p>

<!-- more -->

<h2 id="evaluation-context">Evaluation Context</h2>

<p>Let‚Äôs start with grounding how Peril works. The GitHub term for when someone adds Peril to their account is that it
creates an ‚ÄúInstallation‚Äù of the
<a href="https://blog.github.com/2016-09-14-a-whole-new-github-universe-announcing-new-tools-forums-and-features/#integrate-seamlessly-with-github">GitHub App</a>.
When a webhook from GitHub is sent to Peril, Peril grabs the installation metadata (env vars, settings repo
addresses, cached config etc) out of a mongo database (yeah, I know, <a href="https://www.infoworld.com/article/2990184/database/nosql-simply-isnt-hip-anymore.html">how early-2010s</a>) and pulls out a
set of rules. These rules are a map of Webhook events and actions to files. For example:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"rules"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"issues.opened"</span><span class="p">:</span><span class="w"> </span><span class="s2">"artsy/peril-settings@danger/new-rfc.ts"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"issue_comment"</span><span class="p">:</span><span class="w"> </span><span class="s2">"artsy/peril-settings@org/markAsMergeOnGreen.ts"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"pull_request.closed"</span><span class="p">:</span><span class="w"> </span><span class="s2">"artsy/peril-settings@org/closed-prs.ts"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>This <a href="https://github.com/danger/peril/blob/93439da3a088e9a7824192e24d33295ced017239/docs/settings_repo_info.md">custom JSON DSL</a> maps opening an <code class="language-plaintext highlighter-rouge">issue</code> on GitHub to the evaluation of
<a href="https://github.com/artsy/peril-settings/blob/6ec744e552df0828b3de2c5bc72e97accc6f562f/danger/new-rfc.ts"><code class="language-plaintext highlighter-rouge">artsy/peril-settings@danger/new-rfc.ts</code></a>. Peril runs the code which is declared as the <code class="language-plaintext highlighter-rouge">default export</code> with
the JSON contents of the webhook. Then the file can execute with the DSL provided in both <a href="http://danger.systems/js/">danger-js</a> and
<a href="http://danger.systems/js/reference.html#PerilDSL">peril</a>‚Äôs extensions. Peril‚Äôs runtime is a reasonably normal nodejs environment, so it supports working with
<code class="language-plaintext highlighter-rouge">node_modules</code> to get stuff done. Here‚Äôs what <a href="https://github.com/artsy/peril-settings/blob/6ec744e552df0828b3de2c5bc72e97accc6f562f/danger/new-rfc.ts"><code class="language-plaintext highlighter-rouge">artsy/peril-settings@danger/new-rfc.ts</code></a> looks like:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">danger</span><span class="p">,</span> <span class="nx">peril</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">danger</span><span class="dl">"</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Issues</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">github-webhook-event-types</span><span class="dl">"</span>

<span class="k">export</span> <span class="k">default</span> <span class="k">async</span> <span class="p">(</span><span class="nx">issues</span><span class="p">:</span> <span class="nx">Issues</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">issue</span> <span class="o">=</span> <span class="nx">issues</span><span class="p">.</span><span class="nx">issue</span>

  <span class="kd">const</span> <span class="nx">slackify</span> <span class="o">=</span> <span class="p">(</span><span class="na">text</span><span class="p">:</span> <span class="nx">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">unfurl_links</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
    <span class="na">attachments</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span>
        <span class="na">pretext</span><span class="p">:</span> <span class="nx">text</span><span class="p">,</span>
        <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">good</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">title</span><span class="p">:</span> <span class="nx">issue</span><span class="p">.</span><span class="nx">title</span><span class="p">,</span>
        <span class="na">title_link</span><span class="p">:</span> <span class="nx">issue</span><span class="p">.</span><span class="nx">html_url</span><span class="p">,</span>
        <span class="na">author_name</span><span class="p">:</span> <span class="nx">issue</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">login</span><span class="p">,</span>
        <span class="na">author_icon</span><span class="p">:</span> <span class="nx">issue</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">avatar_url</span>
      <span class="p">}</span>
    <span class="p">]</span>
  <span class="p">})</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">issue</span><span class="p">.</span><span class="nx">title</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">"</span><span class="s2">RFC:</span><span class="dl">"</span><span class="p">)</span> <span class="o">||</span> <span class="nx">issue</span><span class="p">.</span><span class="nx">title</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">"</span><span class="s2">[RFC]</span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Triggering slack notifications</span><span class="dl">"</span><span class="p">)</span>

    <span class="k">await</span> <span class="nx">peril</span><span class="p">.</span><span class="nx">runTask</span><span class="p">(</span><span class="dl">"</span><span class="s2">slack-dev-channel</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">in 5 minutes</span><span class="dl">"</span><span class="p">,</span> <span class="nx">slackify</span><span class="p">(</span><span class="dl">"</span><span class="s2">üéâ: A new RFC has been published.</span><span class="dl">"</span><span class="p">))</span>
    <span class="k">await</span> <span class="nx">peril</span><span class="p">.</span><span class="nx">runTask</span><span class="p">(</span><span class="dl">"</span><span class="s2">slack-dev-channel</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">in 3 days</span><span class="dl">"</span><span class="p">,</span> <span class="nx">slackify</span><span class="p">(</span><span class="dl">"</span><span class="s2">üï∞: A new RFC was published 3 days ago.</span><span class="dl">"</span><span class="p">))</span>
    <span class="k">await</span> <span class="nx">peril</span><span class="p">.</span><span class="nx">runTask</span><span class="p">(</span><span class="dl">"</span><span class="s2">slack-dev-channel</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">in 7 days</span><span class="dl">"</span><span class="p">,</span> <span class="nx">slackify</span><span class="p">(</span><span class="dl">"</span><span class="s2">üï∞: A new RFC is ready to be resolved.</span><span class="dl">"</span><span class="p">))</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Triggered slack notifications</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Implementation-wise, there is a single Peril API which recieves webhooks from GitHub. This triggers a ‚ÄúRunner‚Äù which
is a hosted docker container (think, like, serverless) which hosts the runtime. The runner will then run the
Dangerfile, triggering things like comments on PRs or any other interesting side-effect.</p>

<p><img src="/images/peril-state/peril-stack.png" /></p>

<p>This is where things get tricky, I first explored running code inside a tightened <a href="https://github.com/patriksimek/vm2">virtual machine for node</a>
but eventually found enough holes that it was definitely not going to work against malicious user-code in the same
process as Peril. I lucked out to a potential answer to this when building out documentation for <a href="http://danger.systems/js/">danger-js</a>,
which could <a href="https://celebrateurbanbirds.org/learn/gardening/providing-water-for-birds/">feed many birds with one bowl</a>. I could separate out the execution context (think: the runtime
DSL, the webhook JSON, and a bunch of installation specific config) as JSON and then pass that servers/processes
then turn that back into a useful runtime again in a separate client which runs the Dangerfile (the name for a
<code class="language-plaintext highlighter-rouge">js</code>/<code class="language-plaintext highlighter-rouge">ts</code> file running in the Peril JavaScript Environment. )</p>

<p>This idea was so compelling that I first used it to create a version of Danger that runs
<a href="https://github.com/danger/danger-swift">native to swift</a> to figure out the kinks of what actually needs to be
transmitted. For Peril, this meant I could explore having the evaluation of user-code inside a completely different
server. I initially explored <a href="https://github.com/danger/peril/issues/159">using AWS Lambda</a> to run user-code, it‚Äôs cheap, fast and mature. However, it‚Äôs
possible for lambda instances to communicate with each other, as each run is not <a href="https://aws.amazon.com/blogs/compute/container-reuse-in-lambda/">a fresh process</a>.
Making it not a secure platform for un-trusted code.</p>

<p>Not deterred, I explored the world of docker hosting as a service - first exploring running my own cluster <a href="https://aws.amazon.com/ecs/">on AWS
ECS</a> and then settling <a href="https://hyper.sh">on Hyper</a> which offered sandboxed runs that booted in a few seconds. This is
where my first real dive into obsessive statelessness comes in. The docker container, and the hyper environment
contains no config by default. There is no Peril information available inside that runtime environment.</p>

<p>The information about a Peril run comes exclusively from Peril. In my head, I call this dependency injection for the
runtime environment. You can get a sense for what the full JSON looks like in this
<a href="https://github.com/danger/peril/blob/master/source/github/events/handlers/_tests/fixtures/PerilRunnerEventBootStrapExample.json">fixtured file generated by tests</a>.
It contains everything from (temporary) GitHub access tokens (only for your installation), to environment variables
for your run and the webhook JSON. The runtime environment only knows that information for the duration of the
process then all access tokens expires after 30 seconds of it starting regardless.</p>

<h2 id="user-sessions-are-ephemeral">User Sessions are ephemeral</h2>

<p>With the runtime security figured out, and reasonably stable, I could start thinking about how people can understand
what‚Äôs happening on their installations inside peril.</p>

<p><img src="/images/peril-state/peril-dashboard.png" /></p>

<p>I know, a beauty right? Taking ideas from Ashkan‚Äôs <a href="https://artsy.github.io/blog/2016/10/26/jwt-artsy-journey/">post on JWT‚Äôs</a> I explored using JWTs to fix a few user-y,
database-y related problems.</p>

<p>A JWT is a string made of three components, a header which says how it is signed, a base64 chunk of JSON data and a
signature verifying the data. You can always read the data inside a JWT, but you need to know the public key used to
sign the token to verify that it‚Äôs not been tampered with or created from another source.</p>

<p>This brings us to my first problem when building out multi-account Peril: User accounts. For Peril the root element
of the domain model is a GitHub Installation. A first-glance perspective on building a web service like this would
have me creating a user model which can keep track of permission to installations and unique user settings. With
<a href="https://www.wired.co.uk/article/what-is-gdpr-uk-eu-legislation-compliance-summary-fines-2018">GDPR so freshly baked</a> I really didn‚Äôt see any actual value in keeping this kind of data. Instead I added
enough metadata to a JWT to replace a user model completely.</p>

<p>I opted to rely on GitHub‚Äôs Oauth API to verify what orgs a user has access to. This means GitHub hosts both the
user model, and the permission relationships. This is always set up outside of Peril, and so there‚Äôs no need for
duplication of the objects and connections inside this service.</p>

<h4 id="heres-an-example-jwt">Here‚Äôs an example JWT</h4>

<script src="https://gist.github.com/orta/0265c143e2c4f473d4dff5cc6980d1a4.js"></script>

<p>You could throw it into <a href="https://jwt.io">jwt.io</a> to look at what‚Äôs inside it, but I‚Äôll do that for you:</p>

<h4 id="when-decrypted">When decrypted</h4>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"iat"</span><span class="p">:</span><span class="w"> </span><span class="mi">1529198097</span><span class="p">,</span><span class="w">
  </span><span class="nl">"iss"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"123"</span><span class="p">,</span><span class="w"> </span><span class="s2">"321"</span><span class="p">],</span><span class="w">
  </span><span class="nl">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"user"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Orta"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"avatar_url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"https://avatars2.githubusercontent.com/u/49038?v=4"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"exp"</span><span class="p">:</span><span class="w"> </span><span class="mi">1529201697</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>So far, I think that‚Äôs enough information for the dashboard. You can let people know what account they‚Äôre logged
into, and a show an avatar in a UI. The JWT is generated when you log in to Peril via GitHub OAuth, and Peril looks
up what installations you have access to via the GitHub API. The connected installations IDs are stamped into the
JWT in the <code class="language-plaintext highlighter-rouge">iss</code> section. This JWT is stored in the user‚Äôs browser via cookies, and the server never stores it.</p>

<p>In every API call from the front-end, the server validates that the JWT was signed by Peril, and has not expired. If
it‚Äôs OK - the server trusts the data inside the JWT and you have access to administrate the installations. No stored
sessions, no stored users.</p>

<p>There‚Äôs downsides to using a JWT like this. For example, what happens if the user is removed from the org? Until
that JWT has expired (1 month), the user will continue have access to the installation. This is a trade-off which
I‚Äôm OK to take right now. I think <a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">this post</a> covers a lot of the downsides of this stateless JWT
technique well. In the future, as Peril has access to org members being added or removed, I can build a way to
expire the token at runtime.</p>

<h2 id="temporary-tokens">Temporary Tokens</h2>

<p>The user/authentication JWT is not the only JWT in play in Peril.</p>

<p>I needed the ability for the JavaScript Runtime to send messages back to the Peril server. Peril re-uses JWTs for
creating a short-lived (2 min) token. This token only has access to a single installation and is given a
list of mutations it has allowlisted access to in the GraphQL API. This token is a part of the data injected in at
the start of the process. The Peril JavaScript DSL uses this token under the hood when you run particular functions.
This approach, the above post argues, is a perfect use-case for JWTs.</p>

<h2 id="temporary-webhooks">Temporary Webhooks</h2>

<p>With an admin user interface set up, you can now get a good overview of what your installation looks like in
Peril.</p>

<p><img src="/images/peril-state/admin.png" /></p>

<p>This is a good start, but it‚Äôs a static representation of a live system. In order to do any development of your
Dangerfiles in Peril, you would need to keep triggering the same event inside the GitHub and seeing how Peril
evaluates your code. Even with the rich type definitions, you‚Äôre unlikely to get it right first time.</p>

<p>And here‚Äôs where I made a compromise or two, in favour of a good abstraction. Ash recommended that perhaps storing
webhooks from GitHub and making it feasible to re-send them in Peril would make a great development environment. I
couldn‚Äôt think of a way to do that statelessly, so I opted to time-box them. Now you can trigger a 5 minute window
on an installation where any event sent to Peril will be stored in mongo for a week. After that they‚Äôre gone.</p>

<p>This is a great trade-off on data storage vs value of a feature. It‚Äôs been the best idea so far on how to handle
building a development mode into Peril, so I wouldn‚Äôt want to compromise the feature in favour of something that
won‚Äôt store any data.</p>

<h2 id="real-time-logging">Real-time logging</h2>

<p>On the flip side, I spent a long time thinking about how I can get logs from a Peril run to a user without having to
store those.</p>

<p>I came up with what feels like such an obvious answer in retrospect. When you open up the admin dashboard, it
connects to Peril via a websocket. This websocket is used to send real-time updates about when an event is
triggering a Dangerfile evaluation and its changing status. When the evaluation is finished, then the logs are
collected and sent through the websocket to any users connected to the associated installation. The feature is
particularly elegant because storing the logs for every Dangerfile run on something like S3 will not scale with my
wallet. Plus, I don‚Äôt want to have access to your logs ideally.</p>

<p><img src="/images/peril-state/websocket.png" /></p>

<p>Again, an interesting trade-off. You can only get logs when you‚Äôre looking for them, as opposed to when a problem
may actually have occurred. There‚Äôs things I can do to work around this if and when it becomes a pressing need, for
example keeping an installation‚Äôs logs around for a day in Peril. Alternatives to this could be that Peril allows
installations to define a webhook to receive the logs, or for Peril to pass them directly to a installation‚Äôs
<a href="https://papertrailapp.com">Papertrail</a> (or other hosted log services).</p>

<p>A lot of the obsession comes from a reasonable enough desire to ship something that people can trust, that could
start off small and hard enough that it doesn‚Äôt consume all my spare time with support and fixing fires. With a lot
of these ideas in tow, I‚Äôve been able to feel pretty confident in letting others access staging environments and use
my hosted version of Peril. Which means I can move on to the next items in my TODO list, making the dashboard make
sense and to start thinking about what the public facing product pages look like for Peril.</p>

<hr />

<p><em>Editor‚Äôs Note: This post has been updated as part of an effort to adopt more inclusive language across Artsy‚Äôs
GitHub repositories and editorial content (<a href="https://github.com/artsy/README/issues/427">RFC</a>).</em></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing Peril to the Artsy Org]]></title>
    <link href="https://artsy.github.io/blog/2017/09/04/Introducing-Peril/"/>
    <updated>2017-09-04T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2017/09/04/Introducing-Peril</id>
    <content type="html"><![CDATA[<p>Once Danger Ruby was stable enough for everyday use in 2015, it became obvious that running Danger on CI was both a 
positive and a negative. On the positive side, Danger has access to all artifacts created during testing - and on the negative 
side it takes a long time to get feedback. It was obvious that Danger could <a href="https://github.com/danger/danger/issues/42">run on a server</a>, but it was a big unknown what that could look like.</p>

<p>Eventually, <a href="/blog/2017/06/30/danger-one-oh-again/">I came to the conclusion</a> that we would need a JavaScript replacement of Danger - and so I applied
constraints to Danger JS that made a server-side version of Danger a possibility. It was a stroke of luck that around the 
time Danger JS became usable for day to day usage, that GitHub introduced <a href="https://developer.github.com/changes/2016-09-14-Integrations-Early-Access/">GitHub Apps</a> - so I started work on Peril. Peril is server-side Danger. The rest of this post talks about how we use it Artsy today, how you can use it yourself and where it‚Äôs heading.</p>

<!-- more -->

<p>In December 2016, I built out Peril in a sandbox org: <a href="https://github.com/PerilTest">PerilTest</a>, this gave me the chance to get a lot of things wrong safely. My biggest worry around Peril was leaking data though someone abusing the ability to evaluate a Dangerfile.</p>

<p>In May 2017, I introduced Peril into Artsy‚Äôs org, GitHub apps have the ability to pick and choose which repos to work with. 
I scoped the repos to existing open source projects which I was familiar with (<a href="https://github.com/artsy/emission">Emission</a>, <a href="https://github.com/artsy/reaction">Reaction</a> and <a href="https://github.com/artsy/positron">Positron</a>)
which gave a space to ensure stability and handle production edge-cases.</p>

<p>In August 2017, I created a new Peril instance for CocoaPods. I then finally flipped the switch to turn Peril on for all 
repos on the Artsy org and formalized the RFC process for changes. This is where we are now.</p>

<h2 id="getting-set-up">Getting Set Up</h2>

<p>For our Artsy org, I followed and improved the guide: <a href="https://github.com/danger/peril/blob/master/docs/setup_for_org.md">Setup for Org</a>. There are three key components:</p>

<ul>
  <li>Creating a GitHub app for your Org</li>
  <li>Hosting a Peril server</li>
  <li>Making up a Peril settings repo</li>
</ul>

<p>The guide covers the initial setup, but I‚Äôd like to cover the third part of our setup.</p>

<h2 id="how-artsys-peril-works">How Artsy‚Äôs Peril works</h2>

<p>The Artsy Peril settings are all on <a href="https://github.com/artsy/artsy-danger">artsy/artsy-danger</a>. The Artsy Peril heroku instance has the ENV var
<code class="language-plaintext highlighter-rouge">"DATABASE_JSON_FILE"</code> set to <code class="language-plaintext highlighter-rouge">"artsy/artsy-danger@peril.settings.json"</code>, so Peril will use <a href="https://github.com/artsy/artsy-danger/blob/master/peril.settings.json">that file</a> as the source of truth for all config. Here‚Äôs what it is today:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"settings"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"modules"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
      </span><span class="s2">"danger-plugin-spellcheck"</span><span class="p">,</span><span class="w"> 
      </span><span class="s2">"danger-plugin-yarn"</span><span class="p">,</span><span class="w"> 
      </span><span class="s2">"@slack/client"</span><span class="w">
    </span><span class="p">],</span><span class="w">
    </span><span class="nl">"env_vars"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"SLACK_RFC_WEBHOOK_URL"</span><span class="p">]</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"rules"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"pull_request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"artsy/artsy-danger@org/all-prs.ts"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"repos"</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"artsy/reaction"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"pull_request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"danger/pr.ts"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"artsy/positron"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"pull_request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"dangerfile.ts"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="nl">"artsy/artsy-danger"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"issues.opened"</span><span class="p">:</span><span class="w"> </span><span class="s2">"artsy/artsy-danger@danger/new_rfc.ts"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p><code>"settings":</code> These settings which conform to today's <a href="https://github.com/danger/peril/blob/752afeb37e3c1fdec512eb91687747d9a8a29337/source/db/index.ts#L26-L31">GitHubInstallationSettings</a>, here's the <a href="https://github.com/danger/peril/blob/master/source/db/index.ts">current version</a>. These are org-wide settings
that require a new deploy of the server to re-create.</p>

<p><code>"rules":</code> These are rules which are applied to every repo that Peril has access to. So in this case, every Pull Request in the org will make Peril run the Dangerfile at <code>"artsy/artsy-danger@org/all-prs.ts"</code>.</p>

<p><code>"repos":</code> These are repo-specific overrides, so a Pull Request to artsy/reaction would trigger both the org-wide Dangerfile, and one on the reaction repo.</p>

<h2 id="events">Events</h2>

<p>A Dangerfile evaluation occurs once a GitHub webhook is sent. In the above examples there are two events that Danger supports: 
<code class="language-plaintext highlighter-rouge">"pull_request"</code> and <code class="language-plaintext highlighter-rouge">"issues.opened"</code>. These are qualifiers that GitHub provide as a <a href="https://developer.github.com/v3/activity/events/types/events">Webhook EventTypes</a>.</p>

<p>There‚Äôs a lot of them: <code class="language-plaintext highlighter-rouge">commit_comment</code>, <code class="language-plaintext highlighter-rouge">create</code>, <code class="language-plaintext highlighter-rouge">delete</code>, <code class="language-plaintext highlighter-rouge">deployment</code>, <code class="language-plaintext highlighter-rouge">deployment_status</code>, <code class="language-plaintext highlighter-rouge">fork</code>, <code class="language-plaintext highlighter-rouge">gollum</code>, <code class="language-plaintext highlighter-rouge">installation</code>, <code class="language-plaintext highlighter-rouge">installation_repositories</code>, <code class="language-plaintext highlighter-rouge">issue_comment</code>, <code class="language-plaintext highlighter-rouge">issues</code>, <code class="language-plaintext highlighter-rouge">label</code>, <code class="language-plaintext highlighter-rouge">marketplace_purchase</code>, <code class="language-plaintext highlighter-rouge">member</code>, <code class="language-plaintext highlighter-rouge">membership</code>, <code class="language-plaintext highlighter-rouge">milestone</code>, <code class="language-plaintext highlighter-rouge">organization</code>, <code class="language-plaintext highlighter-rouge">org_block</code>, <code class="language-plaintext highlighter-rouge">page_build</code>, <code class="language-plaintext highlighter-rouge">project_card</code>, <code class="language-plaintext highlighter-rouge">project_column</code>, <code class="language-plaintext highlighter-rouge">project</code>, <code class="language-plaintext highlighter-rouge">public</code>, <code class="language-plaintext highlighter-rouge">pull_request</code>, <code class="language-plaintext highlighter-rouge">pull_request_review</code>, <code class="language-plaintext highlighter-rouge">pull_request_review_comment</code>, <code class="language-plaintext highlighter-rouge">push</code>, <code class="language-plaintext highlighter-rouge">release</code>, <code class="language-plaintext highlighter-rouge">repository</code>, <code class="language-plaintext highlighter-rouge">status</code>, <code class="language-plaintext highlighter-rouge">team</code>, <code class="language-plaintext highlighter-rouge">team_add</code>, <code class="language-plaintext highlighter-rouge">watch</code>.</p>

<p>Some of these events also have unique sub-actions too:</p>

<ul>
  <li>
    <p>For an <code class="language-plaintext highlighter-rouge">issue</code> event there is: <code class="language-plaintext highlighter-rouge">assigned</code>, <code class="language-plaintext highlighter-rouge">unassigned</code>, <code class="language-plaintext highlighter-rouge">labeled</code>, <code class="language-plaintext highlighter-rouge">unlabeled</code>, <code class="language-plaintext highlighter-rouge">opened</code>, <code class="language-plaintext highlighter-rouge">edited</code>,  <code class="language-plaintext highlighter-rouge">milestoned</code>, <code class="language-plaintext highlighter-rouge">demilestoned</code>, <code class="language-plaintext highlighter-rouge">closed</code>, or <code class="language-plaintext highlighter-rouge">reopened</code></p>
  </li>
  <li>
    <p>For a <code class="language-plaintext highlighter-rouge">pull_request</code> event there is: <code class="language-plaintext highlighter-rouge">assigned</code>, <code class="language-plaintext highlighter-rouge">unassigned</code>, <code class="language-plaintext highlighter-rouge">review_requested</code>, <code class="language-plaintext highlighter-rouge">review_request_removed</code>, <code class="language-plaintext highlighter-rouge">labeled</code>, <code class="language-plaintext highlighter-rouge">unlabeled</code>, <code class="language-plaintext highlighter-rouge">opened</code>, <code class="language-plaintext highlighter-rouge">edited</code>, <code class="language-plaintext highlighter-rouge">closed</code>, or <code class="language-plaintext highlighter-rouge">reopened</code></p>
  </li>
</ul>

<p>The way that you define rules in Peril gives you the ability to either focus on one action for an event type: <code class="language-plaintext highlighter-rouge">"issues.opened"</code> or all actions
on an event: <code class="language-plaintext highlighter-rouge">"pull_request"</code>. Once you get your head around this, you start to get a sense of the scope of Peril. At Artsy, we‚Äôve barely scratched the surface.</p>

<h3 id="growth">Growth</h3>

<p>I‚Äôve always advocated that Danger, and Peril should be <a href="http://danger.systems/js/usage/culture.html">applied incrementally</a>. This applies even more when you‚Äôre
making org changes that affect every developer - at least with Danger you can see the Pull Request that changes 
the Dangerfile. With Peril you get none of that.</p>

<p>So, we introduced <a href="https://github.com/artsy/artsy-danger/#rfcs">an RFC process for Peril changes</a>. There‚Äôs not much to it, if you want to add a rule that 
affects everyone then you need to make an issue following a template and then wait a week. If you make a new issue that
includes the title <code class="language-plaintext highlighter-rouge">RFC:</code> then Peril sends a slack message to our developer Channel</p>

<p><img src="/images/peril/peril-rfc.png" alt="/images/peril/peril-rfc.png" /></p>

<p>This was simple to build via Peril, I first added the npm module: <code class="language-plaintext highlighter-rouge">"@slack/client"</code> to the <code class="language-plaintext highlighter-rouge">"modules"</code> array, making it available to a Dangerfile. Then I added an environment variable to Peril for a newly minted Slack Incoming Webhook URL, and exposed it to Dangerfiles via: <code class="language-plaintext highlighter-rouge">"env_vars": ["SLACK_RFC_WEBHOOK_URL"]</code>.</p>

<p>Then I added a per-repo rule:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">    </span><span class="nl">"artsy/artsy-danger"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"issues.opened"</span><span class="p">:</span><span class="w"> </span><span class="s2">"artsy/artsy-danger@danger/new_rfc.ts"</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>This means the Dangerfile is only ran on <code class="language-plaintext highlighter-rouge">"issues"</code> with an <code class="language-plaintext highlighter-rouge">"opened"</code> action. I didn‚Äôt want the discussion around a rule spamming our slack with webhooks from the other actions. The file <code class="language-plaintext highlighter-rouge">danger/new_rfc.ts</code> looks like this:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">schedule</span><span class="p">,</span> <span class="nx">danger</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">danger</span><span class="dl">"</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">IncomingWebhook</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@slack/client</span><span class="dl">"</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Issues</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">github-webhook-event-types</span><span class="dl">"</span>

<span class="kr">declare</span> <span class="kd">const</span> <span class="nx">peril</span><span class="p">:</span> <span class="kr">any</span> <span class="c1">// danger/danger#351</span>

<span class="kd">const</span> <span class="nx">gh</span> <span class="o">=</span> <span class="nx">danger</span><span class="p">.</span><span class="nx">github</span> <span class="k">as</span> <span class="kr">any</span> <span class="k">as</span> <span class="nx">Issues</span>
<span class="kd">const</span> <span class="nx">issue</span> <span class="o">=</span> <span class="nx">gh</span><span class="p">.</span><span class="nx">issue</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">issue</span><span class="p">.</span><span class="nx">title</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">"</span><span class="s2">RFC:</span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">url</span> <span class="o">=</span> <span class="nx">peril</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">SLACK_RFC_WEBHOOK_URL</span> <span class="o">||</span> <span class="dl">""</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">webhook</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">IncomingWebhook</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
  <span class="nx">schedule</span><span class="p">(</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
   <span class="k">await</span> <span class="nx">webhook</span><span class="p">.</span><span class="nx">send</span><span class="p">({</span>
      <span class="na">unfurl_links</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
      <span class="na">attachments</span><span class="p">:</span> <span class="p">[{</span>
        <span class="na">pretext</span><span class="p">:</span> <span class="dl">"</span><span class="s2">üéâ A new Peril RFC has been published.</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">color</span><span class="p">:</span> <span class="dl">"</span><span class="s2">good</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">title</span><span class="p">:</span> <span class="nx">issue</span><span class="p">.</span><span class="nx">title</span><span class="p">,</span>
        <span class="na">title_link</span><span class="p">:</span> <span class="nx">issue</span><span class="p">.</span><span class="nx">html_url</span><span class="p">,</span>
        <span class="na">author_name</span><span class="p">:</span> <span class="nx">issue</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">login</span><span class="p">,</span>
        <span class="na">author_icon</span><span class="p">:</span> <span class="nx">issue</span><span class="p">.</span><span class="nx">user</span><span class="p">.</span><span class="nx">avatar_url</span>
      <span class="p">}]</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>For events that are not a <code class="language-plaintext highlighter-rouge">"pull_request"</code> the <code class="language-plaintext highlighter-rouge">danger.github</code> object is the JSON for the event.  You can get TypeScript types available for every GitHub event via the NPM module <a href="https://www.npmjs.com/package/github-webhook-event-types">github-webhook-event-types</a> which makes it much easier to work with.</p>

<h2 id="where-to-go-from-here">Where to go from here?</h2>

<p>Right now we have <a href="https://github.com/artsy/artsy-danger/issues?utf8=‚úì&amp;q=is%3Aissue%20RFC">a few RFCs</a>, and I don‚Äôt spend all day making Peril rules, I‚Äôve gotta <a href="https://github.com/artsy/emission/pulls?utf8=‚úì&amp;q=consignments%20">do work y‚Äôknow</a>. We‚Äôre going to slowly build out our Peril infrastructure.</p>

<p>I‚Äôm interested in exploring two ideas big for peril at the moment:</p>

<ul>
  <li>
    <p>What a Peril plugin system looks like: You can include modules which can listen to events and react themselves. An org-wide spellcheck on markdown files could be as easy as including <code class="language-plaintext highlighter-rouge">"modules": ["peril-plugin-spellcheck"]</code>.</p>
  </li>
  <li>
    <p>What <a href="https://github.com/danger/peril/issues/138">scheduled jobs</a> could look like for Peril: We have a bunch of checks I‚Äôd like to make on a a regular occasion, and then passing back feedback via slack or making an issue on the repo.</p>
  </li>
</ul>

<p>For example if a repo has an owner who isn‚Äôt in Artsy anymore, we should highlight that it needs a new owner.</p>

<p>If you‚Äôre interested in using Peril in large OSS projects, take a look at how Peril is used in CocoaPods via <a href="https://github.com/CocoaPods/peril-settings">CocoaPods/peril-settings</a>.</p>

<p>If you‚Äôre interested in using Peril in your org, run through the <a href="https://github.com/danger/peril/blob/master/docs/setup_for_org.md">Setup for Org</a> guide and help improve it when you inevitably have some weird issues.</p>

]]></content>
  </entry>
  
</feed>
