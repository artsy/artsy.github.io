<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: relay | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/relay/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2018-03-23T03:53:16+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Relay Mutations]]></title>
    <link href="http://artsy.github.io/blog/2017/04/26/Relay-Mutations/"/>
    <updated>2017-04-26T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/04/26/Relay-Mutations</id>
    <content type="html"><![CDATA[<blockquote><p>Hey there everyone, it took us two years to <a href="https://github.com/artsy/metaphysics/pull/583">make our</a> GraphQL implementation support any mutations. We opted to keep it read-only for quite a long time because we use GraphQL to consolidate multiple APIs, but as we start new projects as GraphQL + databases then understanding mutations becomes much more important.</p>

<p>Last month, I talked with the team at <a href="https://www.graph.cool/">Graph.cool</a> about having them talk through Relay mutations comprehensively as a guest post on the Artsy Engineering blog. So, I'm really excited to introduce this great post on the topic by <a href="http://twitter.com/nikolasburk">Nikolas Burk</a>.</p>

<p>-- Orta</p></blockquote>

<a name="The.Magic.behind.Relay.Mutations"></a>
<h1>The Magic behind Relay Mutations</h1>

<p><a href="https://facebook.github.io/relay/">Relay</a> is a powerful GraphQL client for React and React Native applications. It was open sourced by Facebook alongside GraphQL in 2015 and is a great tool for supporting you with managing your app's data layer.</p>

<p>In this post, we are going to explore how Relay mutations work by looking at a React Native app. The code can be found on <a href="https://github.com/graphcool-examples/react-native-relay-pokedex-example">GitHub</a>. Our sample application is a simple <em>Pokedex</em>, where users can manage their Pokemons.</p>

<p><img src="http://i.imgur.com/S21GfEo.png" alt="" /></p>

<blockquote><p>Note: We're going to assume a basic familiarity with GraphQL in this article. If you haven't heard of GraphQL before, the <a href="www.graphql.org">documentation</a> and the <a href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile/">GraphQL for iOS Developers</a> post are great places to start. If you're interested in learning more about Relay in general, head over to <a href="www.learnrelay.org">Learn Relay</a> for a comprehensive tutorial.</p></blockquote>

<!-- more -->


<p>If you want to run the example with your own GraphQL server, you can use <a href="https://www.graph.cool/graphql-up/">graphql-up</a> to quickly spin one up yourself from within your browser. Simply click the pink button and follow the instructions on the website.</p>

<p><a href="https://www.graph.cool/graphql-up/new?source=https://raw.githubusercontent.com/graphcool-examples/react-native-relay-pokedex-example/master/pokedex.schema"><img src="http://static.graph.cool/images/graphql-up.svg" alt="graphql-up" /></a></p>

<a name="Relay.-.A.brief.Overview"></a>
<h2>Relay - A brief Overview</h2>

<p>Relay is the most sophisticated GraphQL client available at the moment. Like GraphQL, it has been used and battle-tested internally by Facebook for many years before it was open sourced.</p>

<p>Relay surely isn't the easiest framework to learn - but when used correctly, it takes care of managing large parts of your app's data layer in a consistent and reliable manner! It therefore is particularly well-suited for complex applications with lots of data interdependencies and provides outstanding longterm developer productivity.</p>

<a name="Declarative.API.and.Colocation"></a>
<h3>Declarative API and Colocation</h3>

<p>With Relay, React components specify their data requirements in a declarative fashion, making use of GraphQL <em>fragments</em>.</p>

<blockquote><p>A <a href="https://learngraphql.com/basics/fragments">GraphQL fragment</a> is a selection of fields on a GraphQL type. You can use them to define <em>reusable sub-parts</em> of queries or mutations.</p></blockquote>

<p>Considering the <code>PokemonDetails</code> view above, we need to display the Pokemon's name and image. The fragment that represents these data requirements looks as follows:</p>

<pre><code>fragment PokemonDetails on Node {
  ... on Pokemon {
    id
    name
    url
  }
}
</code></pre>

<p>Note that the <code>id</code> is required so that Relay can identify the objects in the cache, so it's included in the payload as well (even if it's not displayed on the UI).</p>

<p>These fragments are kept in the same file as the React component, so UI and data requirements are <em>colocated</em>. Relay then uses a <a href="https://facebook.github.io/react/docs/higher-order-components.html">higher-order component</a> called <a href="https://facebook.github.io/relay/docs/guides-containers.html#content"><code>Relay.Container</code></a>, to wrap the component along with its data requirements. From this point, the developer doesn't have to worry about the data any more! It will be fetched behind the scenes and is made available to the component via its props.</p>

<a name="Build-time.Schema.Validation"></a>
<h3>Build-time Schema Validation</h3>

<p>Another great feature of Relay that ensures developer productivity is  <em>schema validation</em>. At build time, Relay checks your GraphQL queries, fragments and mutations to ensure their compatibility with the GraphQL API. It is thus able to catch any typos or other schema-related errors before you run (or even worse: deploy) your app, saving your users from unpleasant experiences. Note that the schema validation step requires a <a href="https://facebook.github.io/relay/docs/guides-babel-plugin.html">Babel Relay Plugin</a>.</p>

<a name="Mutations.in.Relay"></a>
<h2>Mutations in Relay</h2>

<a name="GraphQL.Recap"></a>
<h3>GraphQL Recap</h3>

<p>In GraphQL, a <em>mutation</em> is the only way to create, update or delete data on the server - they effectively are the GraphQL abstraction for <em>changing state</em> in your backend.</p>

<p>As an example, creating a new Pokemon in our sample app uses the following mutation:</p>

<pre><code>mutation CreatePokemon($name: String!, $url: String!) {
  createPokemon(input: {
    name: $name,
    url: $url
  }) {
    # payload of the mutation (will be returned by the server)
    pokemon {
      id 
    }
  }
}
</code></pre>

<p>Notice that mutations, similar to queries, also require a <em>payload</em> to be specified. This payload represents the information that we'd like to have returned from the server after the mutation was performed. In the above example, we're asking for the <code>id</code> of the new <code>pokemon</code>.</p>

<a name="The.Magic:.Declarative.Mutations....."></a>
<h3>The Magic: Declarative Mutations ðŸ”®</h3>

<p>Relay doesn't (yet) give the developer the ability to manually modify the data that it stores internally. Instead, with every change, it requires a declarative <em>description</em> of how the local cache should be updated after the change happened in the form of a <a href="https://facebook.github.io/relay/docs/guides-mutations.html#content">mutation</a> and then takes care of the update under the hood.</p>

<p>The description is provided by subclassing <code>Relay.Mutation</code> and implementing (at least) four methods that help Relay to properly update the local store:</p>

<ul>
<li><code>getMutation()</code>: the name of the mutation (from the GraphQL schema)</li>
<li><code>getVariables()</code>: the input variables for the mutation</li>
<li><code>getFatQuery()</code>: a GraphQL query that fetches all data that potentially was changed due to the mutation</li>
<li><code>getConfigs()</code>: a precise specification how the mutation should be incorporated into the cache</li>
</ul>


<p>In the following, we'll take a deeper look at the different kinds of mutations in our sample app, which are used for creating, updating and deleting Pokemons.</p>

<blockquote><p>Note: We're using the <a href="https://www.graph.cool/docs/reference/relay-api/overview-aizoong9ah">Graphcool Relay API</a> for this example. If you used <code>graphql-up</code> to create your own backend, you can explore the API by pasting the endpoint for the Relay API into the address bar of a browser.</p></blockquote>

<a name="Creating.a.new.Pokemon:..code.RANGE_ADD..code."></a>
<h3>Creating a new Pokemon: <code>RANGE_ADD</code></h3>

<p><img src="http://i.imgur.com/yskx5KU.png" alt="" /></p>

<p>Let's walk through the different methods and understand what information we have to provide so that Relay can successfully merge the newly created Pokemon into its store.</p>

<p>The first two methods, <code>getMutation()</code> and <code>getVariables()</code> are relatively obvious and can be retrieved directly from the documentation where the API is described.</p>

<p>The implementations look as follows:</p>

<pre><code class="js">getMutation() {
  return Relay.QL`mutation { createPokemon }`
}

getVariables() {
  return {
    name: this.props.name,
    url: this.props.url,
  }
}
</code></pre>

<p>Notice that the <code>props</code> of a <code>Relay.Mutation</code> are passed through its constructor. Here, we simply provide the <code>name</code> and the <code>url</code> of the Pokemon that is to be created.</p>

<p>Now, on to the interesting parts. In <code>getFatQuery()</code>, we need to specify the parts that might change due to the mutation. Here, we simply specify the <code>viewer</code>:</p>

<pre><code class="js">getFatQuery() {
  return Relay.QL`
    fragment on CreatePokemonPayload {
      viewer {
        allPokemons
      }
    }
  `
}
</code></pre>

<p>Notice that <em>every</em> subfield of <code>allPokemons</code> is also automatically included with this approach. In our example app, <code>allPokemons</code> is the only point we expect to change after our mutation is performed.</p>

<p>Finally, in <code>getConfigs()</code>, we need to specify the <a href="https://facebook.github.io/relay/docs/guides-mutations.html#mutator-configuration">mutator configurations</a>, telling Relay exactly how the new data should be incorporated into the cache. This is where the magic happens:</p>

<pre><code class="js">getConfigs() {
  return [{
    type: 'RANGE_ADD',
    parentName: 'viewer',
    parentID: this.props.viewerId,
    connectionName: 'allPokemons',
    edgeName: 'edge',
    rangeBehaviors: {
      '': 'append'
    }
  }]
}
</code></pre>

<p>We first express that we want to <em>add</em> the node using <code>RANGE_ADD</code> for the <code>type</code> (there are 5 different types in total).</p>

<p>Relay internally represents the stored data as a graph, so the remaining information expresses where exactly the new node should be hooked into the existing structure.</p>

<p>Let's consider the shape of the data before we move on:</p>

<pre><code>viewer {
  allPokemons {
    edges {
      node {
        id
        name
      }
    }
  }
}
</code></pre>

<p>Here we clearly see the direct connection between <code>viewer</code> and the Pokemons goes through <code>allPokemons</code> <em>connection</em>, so the <em>parent</em> of the new Pokemon is the <code>viewer</code>. The name of that connection is <code>allPokemons</code>, and lastly the <code>edgeName</code> is taken from the payload of the mutation.</p>

<p>The last piece, <code>rangeBehaviors</code>, specifies whether we want to <em>append</em> or <em>prepend</em> the new node.</p>

<p>Executing the mutation is as simple as calling <code>commitUpdate</code> on the <code>relay</code> prop that's injected to each component being wrapped with a <code>Relay.Container</code>. An instance of the mutation and the expected variables are passed as arguments to the constructor:</p>

<pre><code class="js">_sendCreatePokemonMutation = () =&gt; {
  const createPokemonMutation = new CreatePokemonMutation({
    viewerId: this.props.viewer.id,
    name: this.state.pokemonName,
    url: this.state.pokemonUrl,
  })
  this.props.relay.commitUpdate(createPokemonMutation)
}
</code></pre>

<a name="Updating.a.Pokemon:..code.FIELDS_CHANGE..code."></a>
<h3>Updating a Pokemon: <code>FIELDS_CHANGE</code></h3>

<p>Like with creating a Pokemon, <code>getMutation()</code> and <code>getVariables()</code> are trivial to implement and can be derived directly from the API documentation:</p>

<pre><code class="js">getMutation() {
  return Relay.QL`mutation { updatePokemon }`
}

getVariables() {
  return {
    id: this.props.id,
    name: this.props.name,
    url: this.props.url,
  }
}
</code></pre>

<p>In <code>getFatQuery()</code>, we only include the <code>pokemon</code> which includes the updated info this time, since that is the only part we expect to change after our mutation:</p>

<pre><code class="js">getFatQuery() {
  return Relay.QL`
    fragment on UpdatePokemonPayload {
      pokemon
    }
  `
}
</code></pre>

<p>Finally, <code>getConfigs()</code>, this time specifies a mutator configuration of type <code>FIELDS_CHANGE</code> since we're only updating properties on a single Pokemon:</p>

<pre><code class="js">getConfigs() {
  return [{
    type: 'FIELDS_CHANGE',
    fieldIDs: {
      pokemon: this.props.id,
    }
  }]
}
</code></pre>

<p>As sole additional piece of info, we declare the ID of the Pokemon that is being updated so that Relay has this information available when receiving the new Pokemon data.</p>

<a name="Deleting.a.Pokemon:..code.NODE_DELETE..code."></a>
<h3>Deleting a Pokemon: <code>NODE_DELETE</code></h3>

<p>As before, <code>getMutation()</code> and <code>getVariables()</code> are self-explanatory:</p>

<pre><code class="js">getMutation() {
  return Relay.QL`mutation { deletePokemon }`
}

getVariables() {
  return {
    id: this.props.id,
  }
}
</code></pre>

<p>Then, in <code>getFatQuery()</code>, we need to retrieve the <code>pokemon</code> from the mutation payload:</p>

<pre><code class="js">getFatQuery() {
  return Relay.QL`
    fragment on DeletePokemonPayload {
      pokemon
    }
  `
}
</code></pre>

<p>In <code>getConfigs()</code>, we're getting to know another mutator configuration type called <code>NODE_DELETE</code>. This one requires a <code>parentName</code> as well as a <code>connectionName</code>, both coming from the mutation payload and specifying where that node existed in Relay's data graph. Another requirement, that is specifically relevant for the implementation of a GraphQL server, is that the mutation payload of a deleting mutation always needs to return the <code>id</code> of the deleted node so that Relay can find that node in its store. Taking all of this together, our implementation of <code>getConfigs()</code> can be written like so:</p>

<pre><code class="js">getConfigs() {
  return [{
    type: 'NODE_DELETE',
    parentName: 'pokemon',
    connectionName: 'edge',
    deletedIDFieldName: 'deletedId'
  }]
}
</code></pre>

<a name="Wrapping.Up"></a>
<h2>Wrapping Up</h2>

<p>Relay has a lot of benefits that make it a very compelling framework to use for state management and interaction with GraphQL APIs. Its major strengths are a highly optimized cache, thoughtful UI integration as well as the declarative API for data fetching and mutations.</p>

<p>The initial version of Relay came with a notable learning curve due to lots of magic happening behind the scenes. However, Facebook recently released the first release candidates of <a href="https://github.com/facebook/relay/releases/">Relay v1.0.0</a> (<em>Relay Modern</em>) with the <a href="https://code.facebook.com/posts/1362748677097871">goal of making Relay generally more approachable</a>.</p>

<p>It's worth noting that Relay isn't the only available GraphQL client. Apollo Client is a great alternative which is a lot easier to get started with. <a href="https://www.graph.cool/docs/tutorials/relay-vs-apollo-iechu0shia/">For a detailed comparison please refer to this article.</a></p>

<p>If you want to learn more about GraphQL and want to stay up-to-date with the latest news of the GraphQL community, subscribe to <a href="https://graphqlweekly.com/">GraphQL Weekly</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Workshop: React Native]]></title>
    <link href="http://artsy.github.io/blog/2017/02/06/React-Native-Workshop/"/>
    <updated>2017-02-06T12:18:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/02/06/React-Native-Workshop</id>
    <content type="html"><![CDATA[<p>Hey there, so you've decided to take a look at React Native? Well, last week I ran a workshop inside Artsy on <a href="https://facebook.github.io/react-native/">React Native</a> and <a href="https://facebook.github.io/relay/">Relay</a>.</p>

<p>The video takes you from <code>react-native init</code> to having the initial structure of a View Controller based on Relay with a real working API request. The video is about 45 minutes, with inline questions.</p>

<p>If you wanted to just run through the notes, you could probably get it working in about 10 minutes.</p>

<p>Jump <a href="https://www.youtube.com/watch?v=PYC47YKnK4k">to YouTube</a> for the video, or click more for a smaller inline preview, as well as all of the speakers notes to copy &amp; paste from. There is also a full copy of the end-result at <a href="https://github.com/orta/Relay-Artist-Example">orta/Relay-Artist-Example</a>.</p>

<!-- more -->


<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/PYC47YKnK4k ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>

<p>Beautiful right?</p>

<p><img src="https://github.com/orta/Relay-Artist-Example/blob/master/screenshots/workshop.png?raw=true"></p>

<p>Below are the notes so you can follow along</p>

<hr />

<a name="Setup"></a>
<h1>Setup</h1>

<ul>
<li>Install <a href="https://yarnpkg.com">Yarn</a></li>
<li>Install React Native - https://facebook.github.io/react-native/docs/getting-started.html</li>
<li>Create a new project via <code>react-native init ArtistExample</code></li>
</ul>


<a name="Verifying.your.install"></a>
<h1>Verifying your install</h1>

<ul>
<li><code>cd ArtistExample</code></li>
<li>Run <code>yarn run jest</code> to verify specs</li>
</ul>


<a name="Starting.out"></a>
<h1>Starting out</h1>

<ul>
<li>Run <code>yarn start</code> - this loads the packager.</li>
</ul>


<p>The packager is the part of React Native which compiles your JavaScript. This JavaScript creates a virtual DOM, which React Native uses to create an equivilent view heirarchy.</p>

<ul>
<li>Run <code>react-native run-ios</code> to launch the project in a sim.</li>
</ul>


<a name="Tada.-.it.s.your.1st.RN.app"></a>
<h3>Tada - it's your 1st RN app</h3>

<p>That's it. Let's look at some real code. Browse the source code.</p>

<a name="Relay"></a>
<h3>Relay</h3>

<p>We're using Relay, this will take a bit of setup. <a href="https://github.com/artsy/emission/commit/c6660fe505f38491f4a1d23dc7f41a2baec5657d">Here is @alloy setting up Relay in Emission</a></p>

<p>Add <code>relay</code> and <code>babel-relay-plugin</code> - we <a href="https://github.com/facebook/relay/issues/1061">use a fork</a></p>

<pre><code class="sh">yarn add react-relay@https://github.com/alloy/relay/releases/download/v0.9.3/react-relay-0.9.3.tgz
yarn add babel-relay-plugin@https://github.com/alloy/relay/releases/download/v0.9.3/babel-relay-plugin-0.9.3.tgz
</code></pre>

<p>Then the schema into a data folder:</p>

<pre><code class="sh">mkdir data
curl https://raw.githubusercontent.com/artsy/emission/master/data/schema.graphql &gt; data/schema.graphql
curl https://raw.githubusercontent.com/artsy/emission/master/data/schema.js &gt; data/schema.js
curl https://raw.githubusercontent.com/artsy/emission/master/data/schema.json &gt; data/schema.json
</code></pre>

<p>Then hook up the plugin:
- Add <code>"plugins": ["./data/schema"],</code> to <code>.babelrc</code>.</p>

<a name="First.edit"></a>
<h3>First edit</h3>

<ul>
<li>Turn on Live Reloading and HMR with <code>cmd + d</code></li>
<li>Turn BG white. Awesome.</li>
</ul>


<p>Magic, it does it in real-time.</p>

<a name="Making.components"></a>
<h3>Making components</h3>

<ul>
<li>Make <code>lib</code>, <code>lib/artists</code> and <code>lib/artists/artist.js</code></li>
<li>Move <code>ArtistExample</code> Component from <code>index.ios.js</code> to <code>lib/artists/artist.js</code></li>
<li>Change the class to <code>Artist</code>, and edit the title to reflect a different component</li>
<li>Go back and nuke most of the <code>index.ios.js</code> make it just refer to `Artist``</li>
</ul>


<pre><code class="js">import Artist from "./lib/artist/artist"

export default class ArtistExample extends Component {
  render() {
    return (
      &lt;Artist /&gt;
    );
  }
}
</code></pre>

<a name="Relay.Setup"></a>
<h3>Relay Setup</h3>

<p>Explain there are three useful bits <a href="https://sgwilym.github.io/relay-visual-learners/">parts of Relay</a>:</p>

<ul>
<li>Routes</li>
<li>RootContainer</li>
<li>Relay.Container</li>
</ul>


<p>We will talk about them as we go on, but first we need to tell Relay where Metaphysics is. So we need to set up a network layer:</p>

<pre><code class="js">import Relay from 'react-relay'

const metaphysicsURL = 'https://metaphysics-staging.artsy.net'

Relay.injectNetworkLayer(
  new Relay.DefaultNetworkLayer(metaphysicsURL, {
    headers: {
      'X-XAPP-Token': "[go to staging.artsy.net and do `sd.ARTSY_XAPP_TOKEN` in console]",
    }
  })
)
</code></pre>

<p>Next we need to create a Relay Route, this <em>doesnt</em> directly represent a URL representation, but it often can/does.
E.g. in our case this will represent <code>/artist/:artistID</code>.</p>

<ul>
<li>create <code>lib/artist/route.js</code> add</li>
</ul>


<pre><code class="js">import Relay from 'react-relay'

export default  class ArtistRoute extends Relay.Route {
  static queries = {
    artist: (component, params) =&gt; Relay.QL`
      query {
        artist(id: $artistID) {
          ${component.getFragment('artist', params)}
        }
      }
    `,
  };

  static paramDefinitions = {
    artistID: { required: true },
  };

  static routeName = 'ArtistRoute';
}
</code></pre>

<ul>
<li>Hook this up inside <code>index.ios.js</code>, add an import, and create instance of Route:</li>
</ul>


<pre><code class="js">import ArtistRoute from "./lib/artist/route"

const glennRoute = new ArtistRoute({
  artistID: "glenn-brown"
})
</code></pre>

<p>  Then change the components render function:</p>

<pre><code class="js">export default class ArtistExample extends Component {
    render = () =&gt; &lt;Relay.RootContainer Component={Artist} route={glennRoute} /&gt;
}
</code></pre>

<p>See error, that means it's trying to access a Relay Component, and we have a React component. Let's make it a Relay Component:</p>

<ul>
<li><p>Remove the <code>export default</code> from the <code>Artist</code> class in <code>lib/artist/artist.js</code></p></li>
<li><p>Add Relay fragment at the bottom</p></li>
</ul>


<pre><code class="js">export default Relay.createContainer(Artist, {
  fragments: {
    artist: () =&gt; Relay.QL`
      fragment on Artist {
        _id
        id
        name
      }
    `,
  }
})
</code></pre>

<pre><code class="js">class Artist extends Component {
  render() {
    const title = `Hello, I am ${this.props.artist.name}`
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text style={styles.welcome}&gt;{title}&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
}
</code></pre>

<hr />

<p>Prove the Relay concept by adding <code>years</code> to GraphQL and add this to the render function:</p>

<pre><code class="js">class Artist extends Component {
  render() {
    const title = `Hey ${this.props.artist.name}`
    return (
      &lt;View style={styles.container}&gt;
        &lt;Text style={styles.welcome}&gt;{title}&lt;/Text&gt;
        &lt;Text style={styles.welcome}&gt;{this.props.artist.years}&lt;/Text&gt;
      &lt;/View&gt;
    );
  }
}
</code></pre>

<p>Tada! You've made a working relay component. Just start making more of these now, and you have an app!</p>

<a name="Looking.Stylish."></a>
<h3>Looking Stylish!</h3>

<p>OK, we now have the minimum we need - we got API data coming in as props. Now we want to make it look pretty.</p>

<ul>
<li>Add <code>mkdir assets</code>, and <code>mkdir assets/fonts</code></li>
</ul>


<pre><code class="sh">curl -L https://github.com/artsy/Artsy-OSSUIFonts/raw/master/Pod/Assets/EBGaramond12-Italic.ttf &gt; assets/EBGaramond12-Italic.ttf
curl -L https://github.com/artsy/Artsy-OSSUIFonts/raw/master/Pod/Assets/EBGaramond12-Regular.ttf &gt; assets/EBGaramond12-Regular.ttf
curl -L https://github.com/artsy/Artsy-OSSUIFonts/raw/master/Pod/Assets/texgyreadventor-bold.ttf &gt; assets/texgyreadventor-bold.ttf
</code></pre>

<ul>
<li>edit <code>package.json</code></li>
</ul>


<pre><code> "rnpm": {
    "assets": ["./assets"]
  }
</code></pre>

<ul>
<li>run <code>react-native link</code>, restart iOS app, by killing it.</li>
<li><p>run <code>react-native run-ios</code></p></li>
<li><p>Add custom styles to the two bits of info on screen:</p></li>
</ul>


<pre><code class="js">&lt;Text style={styles.title}&gt;{this.props.artist.name.toUpperCase()}&lt;/Text&gt;
&lt;Text style={styles.subtitle}&gt;{this.props.artist.years}&lt;/Text&gt;
</code></pre>

<pre><code class="js">const styles = StyleSheet.create({
  container: {
    flex: 1,
    marginTop: 20,
    alignItems: 'center',
    backgroundColor: 'white',
  },
  title: {
    fontSize: 20,
    textAlign: 'center',
    margin: 10,
    fontFamily: "TeXGyreAdventor-Regular"
  },
  subtitle: {
    textAlign: 'center',
    color: '#333333',
    fontFamily: 'EBGaramond12-Regular',
    marginBottom: 5,
  },
});
</code></pre>

<p>And that is our styles. Covering all of the major use cases of React Native for us.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploration: Front-end JavaScript at Artsy in 2017]]></title>
    <link href="http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/"/>
    <updated>2017-02-05T12:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017</id>
    <content type="html"><![CDATA[<center>
 <img src="/images/js2017/js.svg" style="width:300px;">
</center>


<p>The Artsy web team have been early adopters of node, and for the last 4 years the stable stack for the Artsy website has been predominantly been Node + CoffeeScript + Express + Backbone. In 2016 the mobile team <a href="/blog/2016/08/15/React-Native-at-Artsy/">announced</a> that it had moved to React Native, matching the web team as using JavaScript as the tools of their trade.</p>

<p>Historically we have always had two separate dev teams for building Artsy.net and the corresponding iOS app, we call them (Art) Collector Web, and Collector Mobile. By the end of 2016 we decided to merge the teams. The merger has given way to a whole plethora of ideas about what contemporary JavaScript looks like and we've been experimenting with finding common, natural patterns between web and native.</p>

<p>This post tries to encapsulate what we consider to be our consolidated stack for web/native Artsy in 2017.</p>

<p><strong>TLDR:</strong> <a href="#TypeScript">TypeScript</a>, <a href="#GraphQL">GraphQL</a>, <a href="#React...React.Native">React/React Native</a>, <a href="#Relay">Relay</a>, <a href="#Yarn">Yarn</a>, <a href="#Jest">Jest</a>, and <a href="#Visual.Studio.Code">Visual Studio Code</a>.</p>

<!-- more -->


<a name="Overview"></a>
<h2>Overview</h2>

<p>Our web stack has been <a href="/blog/2013/11/30/rendering-on-the-server-and-client-in-node-dot-js/">ezel.js</a> since 2013, and continues to be a mature and well thought out technology. Since then, there has been explorations on a successor to that framework using React and GraphQL with <a href="https://github.com/muraljs/mural">muraljs</a>. However, since the merger, a lot more of our focus has been on trying to find something that feels similar on both React and React Native.</p>

<center>
 <img src="/images/js2017/ts.svg" style="width:300px;">
</center>


<a name="TypeScript"></a>
<h2>TypeScript</h2>

<p><a href="http://www.typescriptlang.org">TypeScript</a> and <a href="https://flowtype.org/">Flow</a> really moved JavaScript forwards in the last few years. They both tackle the essential problems of "how can I trust my code does what I think", "how can I be sure of this change" and "how can I build better tools for JavaScript" in different ways.</p>

<p>Yes, the title of this section is TypeScript and yet I instantly include Flow. I don't think you can, or should talk about TypeScript without understanding it's relationship to Flow.</p>

<p>Both <a href="http://www.typescriptlang.org/play/#src=function%20addNumbers(first%3A%20number%2C%20second%3A%20number)%20%7B%0D%0A%09return%20first%20%2B%20second%0D%0A%7D%0D%0A%0D%0AaddNumbers(1%2C%202)%0D%0A">TypeScript</a> and <a href="https://flowtype.org/docs/five-simple-examples.html#adding-type-annotations">Flow</a> provide a structure for applying Types to JavaScript.</p>

<p>Both <a href="http://www.typescriptlang.org/play/#src=var%20one%20%3D%201%0D%0A%0D%0Aone%20%3D%20%22%22%0D%0A">TypeScript</a> and <a href="https://flowtype.org/docs/classes.html#type-annotations-vs-inference">Flow</a> will infer typing metadata from untyped data.</p>

<p>Both <a href="https://www.npmjs.com/%7Etypes">TypeScript</a> and <a href="https://github.com/flowtype/flow-typed">Flow</a> have systems for applying types to node modules.</p>

<p>We initially went with Flow, as Flow is a <a href="https://discuss.reactjs.org/t/if-typescript-is-so-great-how-come-all-notable-reactjs-projects-use-babel/4887">considerably easier sell</a> to others, as it integrates inside existing JavaScript projects with less issues. Flow acts as a separate tool to a babel-based JavaScript project, whereas TypeScript is a full on replacement for that tooling.</p>

<p><em>Why bother though?</em> JavaScript has existed for decades without type annotations, and everyone seems to have got on pretty well. One of the key features that a typing system gives you is top-notch tooling. An editor can use the type interfaces to provide auto-completion, inline documentation and inline warning/errors as you work. Type systems will help catch errors before you have even pressed save.</p>

<p></article>
<a href='/images/js2017/types.png' style="">
  <img src="/images/js2017/types.png" alt="The Artsy Tech Stack 2017" style="width:100%;">
</a>
<article class="post">
</p>

<p>What works really well for typed JavaScript is that you can easily opt out of it when you need to. Then you're back to normal "do whatever you want" JavaScript land, no problem.</p>

<p>We moved from Flow simply because TypeScript had better integration with <a href="https://code.visualstudio.com">Visual Studio Code</a> (VS Code). For a few months I devoted time to improving the Flow integration in VS Code, and tried learning OCaml to help out on the <a href="https://github.com/facebook/flow">Flow tool</a> itself. In the end though, when we compared to how solid VS Code felt with TypeScript - we decided it was worth converting our projects.</p>

<p>Both TypeScript and Flow provide nearly every Type structure found inside Objective-C and Swift, so teaching the rest of the team how they work is easy from our native experiences.</p>

<p><a name="TypeScript-Extension"></a>One particularly interesting part of TypeScript that we are keeping our eyes on is this <a href="https://github.com/Microsoft/TypeScript/issues/6508">language extensibility issue</a>, if it turns out well, we will be looking into integrating the other technologies mentioned here into TypeScript itself.</p>

<center>
 <img src="/images/js2017/graphql.svg" style="width:300px;">
</center>


<a name="GraphQL"></a>
<h2>GraphQL</h2>

<p>GraphQL is a way to handle API requests. I consider it the successor to REST when working with front-end clients. A big claim, yeah. So, what is it?</p>

<p>Officially <a href="https://github.com/facebook/graphql">GraphQL is a specification</a>. A server can conform to the GraphQL spec, and then clients can make queries against it. Think of it a bit like how SQL is a standardized way of doing database queries across multiple databases types.</p>

<p>As a client, you <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Networking/ARRouter.m#L1011">send</a> a "<a href="http://graphql.org/docs/getting-started/#queries">JSON-shaped query</a>" structure, which is hierarchical and easy to read:</p>

<pre><code class="json">{
  artwork(id: "kimber-berry-as-close-to-magic-as-you-can-get") {
    id
    additional_information

    is_price_hidden
    is_inquireable
  }
}
</code></pre>

<blockquote><p>This will search for a <a href="https://www.artsy.net/artwork/kimber-berry-as-close-to-magic-as-you-can-get">specific artwork</a>, with the response JSON as the Artwork's <code>id</code>, <code>additional_information</code>, <code>is_price_hidden</code> and <code>is_inquireable</code>.</p></blockquote>

<p>It's important to note here, the data being sent <em>back</em> is specifically  what you ask for. This is not defined on the server as a <em>short</em> or <em>embedded</em> version of a model, but the specific data the client requested. When bandwidth and speed is crucial, this is the other way in which GraphQL vastly improves an app-user's experience.</p>

<p>This is in stark contrast to other successors to REST APIs, the hypermedia APIs, like <a href="http://stateless.co/hal_specification.html">HAL</a> and <a href="http://jsonapi.org">JSON-API</a> - both of which are optimised for caching, and rely on "one model, one request" types of API access. E.g. a list of Artworks would actually contain a list of hrefs instead of the model data, and you have to fetch each model in a separate request.</p>

<p>Hypermedia APIs have a really useful space in cross-server communications, but are extremely wasteful of the most precious resource for a front-end device - bandwidth. <a href="latency">Latency matters considerably</a>, on mobile where bandwidth is spotty, and attention spans are short you need to do everything possible to show more than a loading spinner.</p>

<p>I have previously explored our usage of GraphQL from the perspective of a native developer <a href="/blog/2016/06/19/graphql-for-mobile/">in 2016</a>. So I'll leave that post to describe our implementation of a GraphQL server.</p>

<p>One exciting movement in the space of GraphQL is <a href="https://githubengineering.com/the-github-graphql-api/">GitHub moving to GraphQL</a> for their new APIs.</p>

<center>
 <img src="/images/react-native/artsy_react_logo.svg" style="width:300px;">
</center>


<a name="React...React.Native"></a>
<h2>React / React Native</h2>

<p>React is a Facebook project which offers a uni-direction Component model that <em>can</em> replace MVC in a front-end application. React was built out of a desire to abstract away a web page's true view hierarchy (called the DOM) so that they could make changes to the view in memory and then React would handle finding the differences between view states.</p>

<p>You create a set of Components to encapsulate each part of the state of the page. React makes it easy to make components that are functional in the <a href="https://en.wikipedia.org/wiki/functional_reactive_programming">Functional Reactive Programming</a> sense. They act like a function which takes some specially declared state and it is rendered into HTML.</p>

<p>A component optionally uses a language called <a href="#jsx">JSX</a> to visualise how each component's child components are set up, here's an example of a React component using JSX <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/home/search_bar.js">from Emission, our React Native library</a>:</p>

<pre><code class="js">export default class SearchBar extends React.Component {
  render() {
    return (
      &lt;TouchableWithoutFeedback onPress={this.handleTap.bind(this)}&gt;
        &lt;View style={styles.container}&gt;
          &lt;Image style={styles.searchIcon} source={require('../../../images/SearchButton.png')}/&gt;
          &lt;Text style={styles.text}&gt;Search for artists and artworks...&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/TouchableWithoutFeedback&gt;
    )
  }

  handleTap() {
    Switchboard.presentModalViewController(this, '/search')
  }
}
</code></pre>

<p>By providing a well encapsulated Component model, you can aggressively reduce the amount of redundant code you need to build an application. By not initially writing to the DOM, React can decide what has changed between user actions and that means you have to juggle significantly less state.</p>

<p>We can then build on React via React-Native to allow the same style of code to exist inside the mobile sphere, where typically you have had unique languages and tooling.</p>

<p>React Native is an implementation of React where instead of having React's virtual DOM map to a web page's DOM, it creates a native view hierarchy. In the case of iOS that is a <code>UIView</code> hierarchy, and in Android, a <code>View</code> hierarchy.</p>

<p>If you'd like to find out why the iOS team moved to React Native, check our <a href="/series/react-native-at-artsy/">series of posts on React Native</a>.</p>

<center>
 <img src="/images/js2017/relay.svg" style="width:300px;">
</center>


<a name="Relay"></a>
<h2>Relay</h2>

<p>Any front-end client has a lot of work to do on every page:</p>

<ul>
<li>Fetching all the data for a view hierarchy.</li>
<li>Managing asynchronous state transitions and coordinating concurrent requests.</li>
<li>Managing errors.</li>
<li>Retrying failed requests.</li>
<li>Updating the local cache after receiving new results/changes the server objects responses.</li>
<li>Optimistically updating the UI while waiting for the server to respond to mutations.</li>
</ul>


<p>This is typically handled in a per-page basis, for example the API details, and state management between a Gene page, and an Artist page are different. In part because they have different data-models, but also that they have different correlated data. However, they do share a lot of the common responsibilities mentioned above. In our native side, we struggled to find abstractions that would work across multiple pages. Relay fixes this, and does it in a shockingly elegant way.</p>

<p>Relay is a framework for building data-driven React apps which relies on a deep connection to GraphQL. You wrap your React components inside a Relay container, which handles the networking and setting the state for your component.</p>

<pre><code class="js">// This is a normal React component, taken directly from our app
// It will optionally show a description if one exists on a gene.

class Biography extends React.Component {
  render() {
    const gene = this.props.gene
    if (!gene.description) { return null }

    return (
      &lt;View&gt;
        &lt;SerifText style={styles.blurb} numberOfLines={0}&gt;{gene.description}&lt;/SerifText&gt;
      &lt;/View&gt;
    )
  }
}

// Take the above component `Biography`, and wrap it with a Relay Container.
// Then provide what parts of a GraphQL request the `Biography` needs

export default Relay.createContainer(Biography, {
  fragments: {
    gene: () =&gt; Relay.QL`
      fragment on Gene {
        description
      }
    `,
  }
})

// When the `Biography` component is rendered, the component is given props of 
// `gene` with a `description` by the Relay container. 
</code></pre>

<p>Relay handles this by having each component in your view hierarchy exposing the fragments of a GraphQL query. There is a pre-render stage where all of your components fragments are brought together to make a single API request. So in the case of the Gene, it may look something like:</p>

<pre><code class="json">{
  gene(id: "the-fantastic") {
    // could have come from the root component's fragment
    id
    name 

    // came from the above Header fragment
    description 

    // could have come from a RelatedArtists component's fragment
    trending_artists {
      name
      href
    }
  }
}
</code></pre>

<p>The data is first looked up inside Relay's local cache, and then any un-cached items are requested from the network. The results of the query is then moved into the component via it's props. Relay will only provide the specific data each component has requested. So the <code>Header</code> component would get nothing for <code>this.props.gene.name</code>. This data-masking is a great way of ensuring the connection between component and API.</p>

<p>I'd strongly recommend taking the dive into both the <a href="https://facebook.github.io/relay/docs/thinking-in-graphql.html">Thinking with GraphQL</a> and then <a href="https://facebook.github.io/relay/docs/thinking-in-relay.html">Thinking with Relay</a> tutorials to learn more. Finally, <a href="https://www.learnrelay.org">Learn Relay</a> and <a href="https://sgwilym.github.io/relay-visual-learners/">Relay for Visual Learners</a> are great tutorials to help you get comfortable with the concepts.</p>

<center>
 <img src="/images/js2017/yarn.svg" style="width:300px;">
</center>


<a name="Yarn"></a>
<h2>Yarn</h2>

<p>I have a lot of respect for NPM, their scale is <a href="http://blog.npmjs.org/post/143451680695/how-many-npm-users-are-there">through the roof</a>. They built out the foundations for a massive, thriving community. They did a great job. Like a lot of the JavaScript ecosystem, their tooling allows you to get away with a lot of things. You can have the same dependency inside the app with multiple versions, or apps with a dependency tree that is different each time you run <code>npm install</code>.</p>

<p>We have multiple engineers who have worked on a dependency manager for half a decade, having indeterminate builds in JavaScript was something that worried us greatly. Luckily, there is <a href="https://yarnpkg.com">Yarn</a>.</p>

<p>Yarn is a Facebook project that replaces the NPM <a href="https://en.wikipedia.org/wiki/Command-line_interface">cli</a> client. It's very new, so unlike NPM it does not have to worry about backwards compatibility. It is what I'd imagine a fresh re-write of the NPM cli would look like.</p>

<p>Yarn is significantly faster, has a determinate process for setting up projects and uses a lockfile by default to ensure everyone using the project gets the exact same dependency tree. It uses NPM as a server, and so you get the same node modules as with the NPM cli.</p>

<p>Sometimes Yarn gives you pleasant surprises too, my favourite being that <code>yarn [x]</code> will check to see if that is a local command that you could run, saving a bunch of redundant settings.</p>

<p>Converting a codebase can be as simple as going into your project and running:</p>

<pre><code class="sh">npm install -g yarn
yarn install
</code></pre>

<p>Now you have a lockfile, and are using yarn. Awesome, if you are migrating from a project with a shrink-wrap - I have a script which will generate a summary of the changes for you: <a href="https://gist.github.com/orta/cb6d0b8256852c1f01ecf1d803b664c9">script</a>, <a href="https://github.com/artsy/metaphysics/pull/479">example</a>.</p>

<center>
 <img src="/images/js2017/jest.svg" style="width:300px;">
</center>


<a name="Jest"></a>
<h2>Jest</h2>

<p>One of the things that I find particularly pleasant about the JavaScript ecosystem are their testing tools. With our React Native, we came into the ecosystem with fresh eyes, and it was pretty obvious that Jest was an exceptional testing framework. I hear historically Jest has been a bit meh, but it is without a doubt worth another look.</p>

<p><strong>The watcher</strong> - The majority of your usage of Jest is with it running in watcher mode. This mode uses your git diff as a seed for what to run tests against. Jest will use that diff to define all the files that the changed code touches, and then all of the tests that cover those files.</p>

<p>For example, I make a change in one source file and 60 tests run from 6 different test suites. Finishing in under a second.</p>

<p></article>
<a href='/images/js2017/jest-watcher.gif' style="">
  <img src="/images/js2017/jest-watcher.gif" alt="Jest's awesome watch mode" style="width:100%;">
</a>
<article class="post">
</p>

<p>Not all tests are as important to a run, so Jest also keeps track of which tests failed last time and will run those first next time. This reduces iteration time considerably.</p>

<p><strong>Fast and safe</strong> - You think the watcher is smart? Well the way Jest handle test suites is also extremely elegant. Jest keeps track of how long each test suite took to run, and then will weigh the test suites across different processes in order to speed up the overall test suite. If Jest thinks they're all going to be really quick (like my GIF above) they will all happen in one process, as that can also be faster.</p>

<p>Each test suite is an entirely sandboxed node virtual machine, so you cannot have tests influencing each other.</p>

<p><strong>Snapshots</strong> - Jest provides a concept called snapshots, which provides an easy way to compare JavaScript objects. One place where this really shines is with React components. <a href="https://github.com/artsy/emission/blob/ec565b8492540b4e33066364b415c7906ec1e028/lib/containers/__tests__/gene-tests.js#L121-L158">For example</a>:</p>

<pre><code class="js">it('looks like expected', () =&gt; {
  const props = {
      gene:{...}
    }

  const tree = renderer.create(
    &lt;Gene geneID={props.gene.name} medium="painting" price_range="*-100000" gene={props.gene}/&gt;
  ).toJSON()

  expect(tree).toMatchSnapshot()
})
</code></pre>

<p>Now we will get a test failure when any changes happen in the component tree. For example, if I changed the background color to <code>blue</code> from <code>white</code>. I get a fail like this:</p>

<p><img src="/images/js2017/jest-snapshots.png" style="width:100%"></p>

<p>While that example is trivial, we really want to have tests like this to ensure we understand how changes propagate throughout the app.</p>

<p><strong>No config</strong> - When we first integrated Jest, we had no config. Now, to make sure that TypeScript works how we'd like, we require some setup. However, having smart defaults which works in most cases say a lot about the care and attention paid to Developer Experience from the Jest team. The documentation covers default integrations for: Babel, TypeScript and webpack. Three of the biggest modern tools for getting stuff done with node.</p>

<p><strong>Comprehensive API</strong> - Snapshots, watchers, custom matchers, useful JSON output, ESLint linters, Elegant Mocking tools and natural support for async code. All in one project.</p>

<p>If you're interested, there is a lot of work around automating the migration between different testing frameworks in <a href="https://github.com/skovhus/jest-codemods">jest-codemods</a> - getting started has never been easier. I'd also recommend looking at <a href="https://wallabyjs.com">wallaby.js</a> and <a href="https://github.com/orta/vscode-jest">vscode-jest</a> for tooling.</p>

<center>
 <img src="/images/vscode/vscode_logo_artsy.svg" style="width:300px;">
</center>


<a name="Visual.Studio.Code"></a>
<h2>Visual Studio Code</h2>

<p>Had you told me two years ago that my main editor would be a JavaScript app, I'd have bought you a beer for such a great joke.</p>

<p>Visual Studio Code was the app that changed my mind.</p>

<p>I've done a longer write up on the how and why we use VS Code in <a href="/blog/2016/08/15/vscode/">JavaScript projects</a>, however here I'd like to consider the cultural aspect of the choice. It's common practice among web technologists to all have different editors on a project, and for their editors to generally do little work for them. A lot of this culture came from the TextMate and Rails days with the infamous <a href="https://twitter.com/dhh/status/492706473936314369?lang=en">blog in 15 minutes video</a>. When I was a web developer, I also did this.</p>

<p>When you spend a lot of time in a <a href="https://developer.apple.com/xcode/">powerful IDE</a>, it gets pretty hard to go back to a bare-bones editor. VS Code sits at a good (just past) half-way point between text editor and IDE. You can get a lot of the flexibility from a text editor, making it good for one off files and IDEs where you have fully spec'd out projects.</p>

<p>Being able to have project specific setups is where VS Code really starts to shine. One thing that is working well for us is to gradually add project settings for our apps, first we add the ability to run tests with an attached debugger by adding a <code>launch.json</code>:</p>

<pre><code class="json">{
    "name": "Run Tests With Debugger (slower, use yarn for normal work)",
    "type": "node2",
    "request": "launch",
    "port": 5858,
    "address": "localhost",
    "sourceMaps": true,
    "stopOnEntry": false,
    "runtimeExecutable": null,
    "runtimeArgs": [
      "--debug-brk",
      "./node_modules/.bin/jest",
      "-i"
    ],
    "cwd": "${workspaceRoot}"
}
</code></pre>

<p>With this we can showcase how easy it is to use an inline debugger with source-maps, when working with tricky test logic. No more <code>console.log</code>. That's usually a great way to start moving everyone to a consistent environment. Then we add <a href="https://code.visualstudio.com/updates/v1_6#_workspace-extension-recommendations">recommended extensions</a> to the project.</p>

<p>Trying to set a consistent  development environment might sound a bit corporate for a ~25 person dev team, but one chief advantage is that you can feel comfortable taking time at work to improve your tooling knowing it will improve the tooling of everyone else on your team.</p>

<p>I've been exploring a consolidated <a href="https://github.com/artsy/vscode-artsy">Artsy VS Code</a> extension to handle extension dependencies and small tasks, but it's still early days. It's awesome that I can even think at that level of abstraction though.</p>

<a name="End"></a>
<h3>End</h3>

<p>None of these technologies are under a year old, all of them have adoption by substantial amount of companies. Nothing feels  either controversial or novel. This is great. It feels like a lot of the interesting work for us so far has been around improving the spaces between the projects: Finding improvements for generating types <a href="https://github.com/avantcredit/gql2ts/blob/master/Changelog.md">from GraphQL</a> or <a href="https://github.com/alloy/relay2ts">Relay</a>, adding <a href="https://github.com/facebook/jest/commit/e597e5c46f8f4925d9a10c73d8eab05a2c4b8bc3">editor support to jest</a>, adding Danger to <a href="https://github.com/facebook/jest/pull/2508">our dependencies</a> and improving our <a href="https://github.com/orta/vscode-react-native-storybooks">tooling</a> <a href="https://github.com/orta/vscode-jest">for</a> <a href="https://github.com/alloy/vscode-relay">vscode</a>. The front-end is still a pretty small dev team, so we want to do high impact, small projects that can make our tools drastically better.</p>

<p>React, React-Native, Jest, Yarn are all big Facebook projects. In the iOS world, there is a sense of wariness around building an app so heavily around Facebook tech, based on <a href="http://joehewitt.com/2009/03/23/the-three20-project">three20</a> - which I think is a bit unfair. From my perspective, determining whether you should have something as a dependency <a href="/blog/2015/09/18/Cocoa-Architecture-Dependencies/">should be nuanced</a>, but at a minimum you should feel like you can contribute bug fixes and ideally you should be able to maintain the project if it needs it. With Facebook projects, they've shown to be really open to PRs and discussion, and our work in them makes us feel comfortable to maintain a fork if needed.</p>

<p>We're still exploring the space where we can share code between web and mobile. I'd like to hope within a few months we can write up how that is going on. For now, if you're interested in prototypes, we've been moving our React Native components to the web inside <a href="https://github.com/alloy/relational-theory/">Relational Theory</a> and <a href="https://github.com/orta/systems-theory/">Systems Theory</a> tries bringing new ideas from Relational Theory back to React Native.</p>

<p>I have grown to love working with typed JavaScript to ensure soundness, with React and Relay to drastically reduce the amount of code we need to write and to provide awesome root abstractions to build on. Mix that with a hackable editor with substantial language support and it feels like almost exclusively writing business domain logic.</p>
]]></content>
  </entry>
  
</feed>
