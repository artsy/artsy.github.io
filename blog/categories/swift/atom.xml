<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: swift | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2016-02-02T17:08:41+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Being a Good OSS Citizen]]></title>
    <link href="http://artsy.github.io/blog/2016/01/28/being-a-good-open-source-citizen/"/>
    <updated>2016-01-28T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/01/28/being-a-good-open-source-citizen</id>
    <content type="html"><![CDATA[<p>Let's take a look at the day in the life of an open source citizen: me. On our app, I was given <a href="https://github.com/artsy/eigen/issues/971">an issue</a> that would allow users to refine what kinds of sale artworks they were looking at, and it included this <em>awesome</em> slider control so they could set min/max price ranges.</p>

<!-- more -->


<p></div></div><a href='/images/2016-01-28-being-a-good-open-source-citizen/design.png'><img src="/images/2016-01-28-being-a-good-open-source-citizen/design.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Nice.</p>

<p>But iOS doesn't have a slider like that built into UIKit, so I headed to <a href="https://cocoapods.org">CocoaPods.org</a> to find something that would work for me. Searching for "range slider" yielded a bunch of results, and I looked through three or four of them.</p>

<p>I picked <a href="https://cocoapods.org/pods/MARKRangeSlider">this one</a> because it did <em>almost exactly</em> what I needed, provided a reasonable level of customization, and had a history of development leading up to a recent v1.0.</p>

<p>But I said it did "almost exactly" what I needed, which meant I'd have to modify it. At this point, many developers either look for a different library or abandon the idea of using an existing library altogether and invent one themselves. That's a shame, because it's almost always faster and easier to improve an existing library than it is to build your own.</p>

<p>So let's step through what I did to modify this library for my needs. First, I checked to see if there was an issue for my feature already opened on the repository; maybe someone else had tried this, and I could benefit from their experience! That wasn't the case, so I forked the library to my personal account and cloned my fork locally. Now I can modify the library's code and commit it to my fork.</p>

<p>Next I add the library to my <code>Podfile</code>, but I'm clever about it.</p>

<pre><code class="rb">pod 'MARKRangeSlider', :path =&gt; '../MARKRangeSlider'
</code></pre>

<p>This tells CocoaPods that I'm <em>working</em> on the pod, and, it is stored in a local directory (the one where I cloned my fork). This makes it a "development pod", so that the files in Xcode are actually the ones I've cloned locally.</p>

<p>This is a really important, but subtle point. Normally, CocoaPods downloads copies of the files and stores those copies, but in this case, it refers to the existing files. It doesn't copy them at all: any changes I make to the library while working on my app are to the files I cloned. That means they can be easily committed and pushed up to my fork.</p>

<p>That's exactly what I did. I made my changes from within the app until I was satisfied, and <a href="https://github.com/ashfurrow/MARKRangeSlider/commit/aefbeb181b62c8c257a7d0ada1e75834489b1909">pushed them to my fork</a>, then pointed the <code>Podfile</code> to my fork of the pod.</p>

<pre><code class="rb">pod 'MARKRangeSlider', :git =&gt; 'https://github.com/ashfurrow/MARKRangeSlider.git'
</code></pre>

<p>Nice. At this point, I continued on as a developer, running a <code>pod install</code> to download the forked library with my commits as usual. I finished building the feature and <a href="https://github.com/artsy/eigen/pull/1075">PR'd it using my fork</a>.</p>

<p><img src="/images/2016-01-28-being-a-good-open-source-citizen/done.gif" alt="" /></p>

<p>I could've stopped here, but that'd be a shame. Someone else might want the same changes I made, and I should submit them back. I <a href="https://github.com/vadymmarkov/MARKRangeSlider/pull/22">opened a PR</a> on the library to contribute my changes back, and I made sure to explain <em>why</em> my changes were necessary. Because our app is open source, I was even able to link to <em>our</em> PR to show the library author how their work was being used.</p>

<p>The next morning, I woke up to find my PR had been merged, and after the author pushed an updated version of the library (including my changes), I updated our app's <code>Podfile</code> once more.</p>

<pre><code class="rb">pod 'MARKRangeSlider'
</code></pre>

<p>Then ran <code>pod update MARKRangeSlider</code> so it would update <em>just</em> that pod, and point it to the new release. I re-ran the unit tests to make sure I hadn't broken anything, and <a href="https://github.com/artsy/eigen/pull/1077">PR'd the change</a>.</p>

<p>This sounds like a lot, and having written it all out, I guess it is. But it's a series of small steps, not big ones, and I've worked like this long enough that it's second-nature to me now.</p>

<hr />

<p>I believe that using existing open source libraries is almost always better than writing your own, and I believe that improvements made to open source ought to be shared. Those beliefs shape my behaviour as a developer, and as a person.</p>

<p>Making your first contribution to a project may seem scary, but we all <a href="https://github.com/B-Sides/ELCSlider/pull/1">start somewhere</a>. It gets easier, and in time, you will become a paragon of open source citizenry.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Teaching Swift at Artsy]]></title>
    <link href="http://artsy.github.io/blog/2016/01/26/swift-at-artsy/"/>
    <updated>2016-01-26T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/01/26/swift-at-artsy</id>
    <content type="html"><![CDATA[<p>While the Artsy engineering team includes many disciplines, tech stacks, and personalities, we all share a few things in common: a respect for each other, an appreciation of art-meets-science, and a celebration of learning. These are actually traits shared with our entire company, even non-engineers. So last Summer when Orta and I had some down time, it occurred to us how we could do something super-productive that was congruent with our values: we could teach the company Swift.</p>

<!-- more -->


<p>Like most project ideas, the first step was to create a <a href="https://github.com/orta/Swift-at-Artsy">GitHub repo</a>. We made it open source because <a href="http://code.dblock.org/2015/02/09/becoming-open-source-by-default.html">why not</a>. Orta and I chatted and realized that to teach the company Swift, we would need two tracks:</p>

<ul>
<li>A track for newcomers who may have never programmed before.</li>
<li>A track for anyone who could explain what "object-oriented programming" meant.</li>
</ul>


<p>It was really important to us to include beginners who had no exposure to programming â€“ the digital marketing and genoming teams specifically were keen to learn how to program.</p>

<p>I'm a big believer in using "newcomer" and "informed" to describe the two groups of developers â€“ it helps prevent newcomers from feeling inadequate and better describes the expectations for students.</p>

<p>We also focused on Swift-only, no iOS. That allowed us to focus on the language â€“ which was fun because it let us focus on us learning new stuff, too â€“ and we kept the course to five one-hour sessions (per track).</p>

<p>Next step was obviously to create a Slack chatroom. We re-purposed the oft-neglected room dedicated to Taylor Swift and turned it into a place where anyone could ask questions and share resources. It's also a helpful place to @channel everyone to remind them about the classes.</p>

<p></div></div><a href='/images/2016-01-26-swift-at-artsy/chatroom.png'><img src="/images/2016-01-26-swift-at-artsy/chatroom.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Orta taught the beginner course and I TA'd it, answering questions as he instructed and offering suggestions when I felt something should be clarified (kind of like pair-programming except for teaching). We switched roles for the informed class. Preparing course materials was done through GitHub pull requests, which integrated well into our existing workflow on the mobile team.</p>

<p>We ran into some troubles in the first classes of both tracks: Swift 2 was in beta, and getting everyone on the correct versions of Xcode proved... difficult. Keeping them up-to-date as Xcode betas continued to be released over five weeks was also challenging. This was a problem in both tracks, but some problems were track-specific.</p>

<p>Explaining fundamental concepts like variables and for-loops to beginners is challenging. It reminded me of when I TA'd intro-to-Java courses in University (while the code then was obviously much uglier, <code>javac</code> is arguably more user-friendly than Xcode). Having the pair-programming approach worked well to help explain these concepts.</p>

<p>The biggest challenge with the informed class was rounding everyone up to actually attend the classes. Engineers are addicted to being busy, and like most side-projects, everyone was initially very excited about the course, but that interest dropped off quickly. Orta would help by physically going to our colleagues' desks and gently reminding them.</p>

<p>Regardless of the challenges, the course had a significant impact, both within Artsy and in the larger Swift community. Some of the course materials have been <a href="https://github.com/orta/Swift-at-Artsy/blob/master/Beginners/Lesson%20One/README_ZH.md">translated into Chinese</a> and we regularly received suggestions (and occasionally corrections) about our content. Newcomers to programming gained insights into <em>what exactly engineers do</em> and why bugs happen, while informed colleagues saw parallels between Swift and their own favourite languages (most often Scala). The course materials have also helped other mobile team members (who usually write only Objective-C) get started with Swift.</p>

<p>The beginner students really appreciated <a href="https://github.com/orta/Swift-at-Artsy/tree/master/Beginners/Lesson%20Three">lesson three</a> because we used real-world (scaled down) data structures that Artsy actually uses. We presented problems to solve â€“ problems our colleagues were familiar with from their day-to-day work â€“ and we showed how they can be solved with programming. <a href="https://github.com/orta/Swift-at-Artsy/tree/master/Beginners/Lesson%20Four">Lesson four </a> was the most well-received lesson as it featured some concrete "making the computer do cool stuff" material.</p>

<p>Finally, there was just a great sense of accomplishment. Orta and I had taken time during a downtime in engineering work and turned it into something that helped the company and helped the community. We got thanked internally and externally, and that felt great; helping others has a lot of tangible benefits, but feeling good about it is one of my favourites.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eidolon: Code Review]]></title>
    <link href="http://artsy.github.io/blog/2016/01/14/eidolon-code-review/"/>
    <updated>2016-01-14T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/01/14/eidolon-code-review</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/artsy/eidolon">Eidolon</a> is the third app from Artsy's mobile team, and it was the <a href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">first to be developed totally in the open</a>. It's often used as a reference for what an app written in Swift, or written using FRP, should look like. Given how interested the community seems to be around the app, it's about time we did a walkthrough of the code.</p>

<!-- more -->


<p>This was done as a part of the engineering team's weekly lunch and learn sessions, where we get together and share what we've been working on. Since most of you aren't Artsy engineers, and so you can't ask questions in-person, please feel free to <a href="https://github.com/artsy/eidolon/issues/new">open an issue</a> to ask for any clarifications.</p>

<p>Jump <a href="https://www.youtube.com/watch?v=LAAMk7oLrmg">to YouTube</a> for the video, or click more for a smaller inline preview.</p>

<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/LAAMk7oLrmg ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Upgrading to RxSwift]]></title>
    <link href="http://artsy.github.io/blog/2015/12/08/reactive-cocoa-to-rxswift/"/>
    <updated>2015-12-08T12:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2015/12/08/reactive-cocoa-to-rxswift</id>
    <content type="html"><![CDATA[<p>When we <a href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">built Eidolon last year</a>, Swift was still pre-1.0 and we couldn't rely on the wide variety of available Swift libraries we enjoy today. I wanted to build it using functional reactive programming, because that's how I believe <a href="https://realm.io/news/altconf-ash-furrow-functional-reactive-swift/">everyone should write software</a>, but there were no Swift-based FRP libraries at the time. As a compromise, I used ReactiveCocoa's Objective-C API (the Swift API was months away from an alpha).</p>

<!-- more -->


<p>The choice to use an Objective-C API â€“ one that heavily relies on the runtime â€“ limited us in terms of what Swift features we could use. We had a lot of closures use <code>AnyObject!</code> as parameter types, requiring constant checks for <code>nil</code> and conditional casts to specific types. It was a real nightmare. We had a lot of code that looked like this:</p>

<pre><code class="swift">signal.map { object in
    if let castObject = object as? WhateverType {
        return castObject.thingWeAreMappingTo()
    } else {
        return SomeSensibleMissingValue
    }
}
</code></pre>

<p>Swift 2's <code>guard</code> statements helped clean this up, but the fundamental problem was that we were using an FRP library not suited for Swift.</p>

<p>While we had <a href="https://github.com/ashfurrow/Swift-RAC-Macros">built replacements</a> for the Objective-C runtime features that weren't available in Swift, we knew that a migration away from RAC's Objective-C API would eventually be necessary.</p>

<p>I used a bit of down-time recently to tackle the problem, starting with some small bits and pieces before dedicating two weeks to finish it. Here we go!</p>

<h3>Benefits</h3>

<p>The key benefits of using a Swift-based FRP framework include:</p>

<ul>
<li>Using the type-checker to catch bugs at compile-time.</li>
<li>Writing fewer lines of code.</li>
<li>Writing more expressive code.</li>
<li>Having fun with the type checker and protocol extensions.</li>
</ul>


<p>When Apple announced Swift, they stressed how safe of a language it was. Now that we were moving to a Swift-based FRP framework, we would finally benefit from those safety features.</p>

<p>This makes new features easier and faster to build. It gives me more confidence when I make a new deploy that things won't break. And like I mentioned above, it's just a lot more fun to write Swift with Swift-based frameworks.</p>

<h3>Process</h3>

<p>When we wrote Eidolon, ReactiveCocoa was more-or-less the only iOS FRP library around. That's fine, because ReactiveCocoa is <em>awesome</em>. But today, there are a variety of frameworks and <a href="https://ashfurrow.com/blog/reactivecocoa-vs-rxswift/">they're <em>all</em> awesome</a>. So we have a choice to make.</p>

<p>Sticking with ReactiveCocoa would mean that we could make a gradual transition (there's a bridge between the Objective-C and Swift APIs). This is <em>kind of</em> a benefit, but also kind of a drawback. I don't really trust myself enough to move off of Objective-C's API completely if a bridge is there â€“ it's just too tempting to leave some parts of the app using the old API.</p>

<p>So instead I decided to not consider the existing code. I asked myself: "If I were choosing an FRP library today for a <em>brand-new</em> app, which one would I choose?"</p>

<p>The answer to that question is <a href="https://github.com/ReactiveX/RxSwift">RxSwift</a>.</p>

<p>RxSwift is a Swift implementation of the <a href="http://reactivex.io">ReactiveX APIs</a>, which bring a few great benefits. The API is well-defined and unlikely to include breaking changes, there are reference implementations for Rx in other languages, and tutorials/resources for other Rx frameworks apply directly to this library. There is some extra overhead from having to interact with a larger community, and <a href="http://stackoverflow.com/questions/32542846/reactivecocoa-vs-rxswift-pros-and-cons/32581824#32581824">there are technical distinctions</a> that might influence your decision. Ultimately, though, I chose RxSwift because I've found their community much more pleasant to interact with.</p>

<p>I started the process by <a href="https://github.com/artsy/eidolon/commit/8e6e86d733e36d3c0b3db581019d09296d04cd68">removing ReactiveCocoa and adding RxSwift to our Podfile</a>. Of course, that made the <em>entire app break</em>, which was fine.</p>

<p>I was working off a "develop" branch, so having the app in an uncompilable state for a few weeks would be no problem.</p>

<p>Then the remaining process was simple: find a compiler error, fix it, and find a new one. 27 days later, <a href="https://github.com/artsy/eidolon/commit/8e6e86d733e36d3c0b3db581019d09296d04cd68">we merged the changes into master</a>.</p>

<p>The process was prioritized in the following way:</p>

<ol>
<li>Get the app compiling again.</li>
<li>Get the app more-or-less working (no crashes for common use cases).</li>
<li>Get the unit tests compiling again.</li>
<li>Get the unit tests <em>completing</em> without crashing.</li>
<li>Get the unit tests <em>passing</em> (locally and on CI).</li>
<li>Thoroughly test the app to verify it still works properly.</li>
</ol>


<p>We're currently wrapping up the final stage, but I expect to release a new build for production use later this week.</p>

<h3>Biggest Challenges</h3>

<p>The biggest challenges were keeping an eye on the end result. When you go for so long without being able to see the benefits of your work, it's easy to get discouraged.</p>

<p>This is the first major app I've written in Swift with FRP, so there were new patterns and practices I had to learn. Checking in with the RxSwift team helped a lot, with a lot of assistance from <a href="https://twitter.com/bontoJR">Junior</a> in particular. Making the changes in the open also <a href="https://github.com/artsy/eidolon/pull/569#commitcomment-14632425">let others provide feedback on our progress</a>.</p>

<p>One of the biggest challenges was the structure of the existing code. Our bid-fulfillment process shares <em>a lot</em> of state â€“ much of it in ways that we wouldn't write today. But I didn't want to increase the scope of the transition to RxSwift to <em>also</em> include removing all shared state from the app â€“ scope creep is really dangerous when your project already spans weeks. It was hard to resist this temptation, but I feel it worked out for the best.</p>

<h3>Things That Were Easier than Expected</h3>

<p>Things generally went easier than I had anticipated. Using a new library for the first time in production, I had a persistent fear that I would get close to completing the transition, but some fundamental misunderstanding of mine would completely undermine all my work. This turned out to be mild impostor syndrome â€“ with a few small exceptions, the app worked correctly as soon as it compiled ðŸŽ‰</p>

<p>I tried to get rid of <code>dynamic</code> properties in views, controllers, and view models, but left them on models to use KVO with <code>rx_observe</code>. I tried not to use KVO a lot, and instead rely on <code>Variable</code> properties, which wrap a value in a type that can be observed. I'm still finding a balance between these two approaches, but this is largely a personal preference.</p>

<p>A common pattern became defining a private <code>Variable</code> and a public <code>Observable</code>, which would constrain the state (a common theme in FRP).</p>

<pre><code class="swift">private let _password = Variable("")
var password: Observable&lt;String&gt; {
    return _password.asObservable()
}
</code></pre>

<p><code>_password</code> is now the read/write property accessible only within the type, while <code>password</code> is a publicly read-only <code>Observable</code>. This pattern takes a bit of typing, so I'm still looking for a way to further abstract it. Maybe a Swift preprocessor would help.</p>

<h3>Lessons Learned</h3>

<p>The biggest lesson I learned was not about RxSwift specifically, but more about how to use the type system to <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">stay DRY</a>. For example, I was writing this kind of code in our unit tests <em>a lot</em>:</p>

<pre><code class="swift">expect(try! subject.expiryDatesAreValidSignal.asBlocking().first()) == false
</code></pre>

<p>(By "a lot", I mean that I had to write this code twice before deciding to find a better way.)</p>

<p>So I wrote an extension to the <code>ObservableType</code> protocol that would abstract this unit-testing code into a reusable function and operator.</p>

<pre><code class="swift">func equalFirst&lt;T: Equatable&gt;(expectedValue: T?) -&gt; MatcherFunc&lt;Observable&lt;T&gt;&gt; {
    return MatcherFunc { actualExpression, failureMessage in

        failureMessage.postfixMessage = "equal &lt;\(expectedValue)&gt;"
        let actualValue = try actualExpression.evaluate()?.toBlocking().first()

        let matches = actualValue == expectedValue
        return matches
    }
}

func ==&lt;T: Equatable&gt;(lhs: Expectation&lt;Observable&lt;T&gt;&gt;, rhs: T?) {
    lhs.to(equalFirst(rhs))
}
</code></pre>

<p>So now my unit tests' expectations look like this:</p>

<pre><code class="swift">expect(subject.expiryDatesAreValid) == false
</code></pre>

<p>Nice â€“ way better.</p>

<p>This is just one example â€“ one that <a href="https://github.com/artsy/eidolon/issues/570">we will be moving into its own library</a>.</p>

<p>Swift's type system is really, really powerful. <a href="https://github.com/artsy/eidolon/blob/cb31168fa29dcc7815fd4a2e30e7c000bd1820ce/Kiosk/UIKit+Rx.swift">Here</a> are some RxSwift-specific extensions we added to UIKit, and <a href="https://github.com/artsy/eidolon/blob/cb31168fa29dcc7815fd4a2e30e7c000bd1820ce/Kiosk/App/SwiftExtensions.swift#L22-L56">here</a> are some general Swift extensions that we've found helpful.</p>

<p>There's a danger in going overboard, of course. A few times, I was tempted to make an extension on string-convertible <code>Variable</code>s to make them themselves string-convertible, for example. That might make <em>writing</em> code easier, but its functionality would not be obvious when <em>reading</em> it later on.</p>

<p>I tried to keep changes like this as obvious and simple as possible, and every addition was peer-reviewed by Orta.</p>

<h3>Community Impact</h3>

<p>Throughout the course of the transition to RxSwift, <a href="https://github.com/ReactiveX/RxSwift/pulls?utf8=%E2%9C%93&amp;q=is%3Apr+author%3Aashfurrow">I made a few contributions to the framework</a>, but the things I wanted to add were outside the immediate scope of the project maintainers' vision. Totally understandable. <a href="https://github.com/ReactiveX/RxSwift/issues/265">With their assistance</a>, Orta and I and others helped to create a <a href="https://github.com/RxSwiftCommunity">new organization for community-run, RxSwift-based libraries</a>.</p>

<p>Now RxSwift can stay lean and focused while the community has a dedicated space to improve all of our ideas, together. <a href="https://github.com/RxSwiftCommunity/NSObject-Rx">One library</a> I wrote during this project is already under the organization's umbrella, with <a href="https://github.com/RxSwiftCommunity/contributors/issues/4">another on the way</a>.</p>

<p>Helping to create a new organization gave me an opportunity to practice my community-building skills. It was exciting to <a href="https://github.com/RxSwiftCommunity/contributors">re-apply Moya's contributor guidelines</a> in a new setting, helping to set a positive tone for a growing community. I had a lot of guidance from Orta and Eloy, who of course have <a href="https://cocoapods.org">done this before</a>.</p>

<p>Making positive changes to the developer community â€“ and, on a larger scale, to the world â€“ is something I've <a href="https://ashfurrow.com/blog/building-my-career/">decided to pursue as my career</a>. I wouldn't have come to that conclusion if it weren't for the thoughtfulness and generosity of my colleagues and of the RxSwift community.</p>

<hr />

<p>This transition project has been exciting, but at times it has been exhausting, too. While I'm <a href="https://github.com/artsy/eidolon/pull/569">glad it's over</a>, the past few weeks have impacted my life in a significant â€“ and positive â€“ way. I've never been more excited to be doing what I'm doing, and to be working in the growing open source Swift community. Thank you, everyone.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Emergence: Code Review]]></title>
    <link href="http://artsy.github.io/blog/2015/11/05/Emergence-Code-Review/"/>
    <updated>2015-11-05T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2015/11/05/Emergence-Code-Review</id>
    <content type="html"><![CDATA[<p>We released the fourth app from the mobile team, <a href="https://github.com/artsy/Emergence/">Emergence</a>, on day one for the new Apple TV and are currently getting around 2k downloads a day. The codebase was created by a single developer, and we didn't want to keep that knowledge siloed. So, I ran an hour long code review session last night where I talked through the codebase, explained why some decisions were made and about the differences between tvOS and UIKit.</p>

<p>Given that I had been asked to write a blog post about tvOS in general, I felt that making the code review public for anyone to watch would be a nice alternative to the usual long-form writing on this blog.</p>

<p>Jump <a href="https://www.youtube.com/watch?v=NErVWhEzIBM">to YouTube</a> for the video, or click more for a smaller inline preview.</p>

<!-- more -->


<p></div></div><iframe width='100%' height='600' src='https://www.youtube.com/embed/NErVWhEzIBM ' frameborder='0' allowfullscreen></iframe><div class='meta-container'><header>&nbsp;</header></div><div class='content-container'><div class='entry-content'></p>
]]></content>
  </entry>
  
</feed>
