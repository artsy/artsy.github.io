<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: node | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/node/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2021-06-03T17:00:54+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Becoming Mobile First]]></title>
    <link href="https://artsy.github.io/blog/2020/09/29/becoming-mobile-first-at-artsy/"/>
    <updated>2020-09-29T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/09/29/becoming-mobile-first-at-artsy</id>
    <content type="html"><![CDATA[<p>It was a Wednesday, mid-summer 2019. I don't know which Wednesday specifically, but I know that it was <em>a</em>
Wednesday because I was attending Artsy's weekly all-hands meeting. Two hundred colleagues were also there (many
dialing in remotely) and we were all listening to
<a href="https://files.artsy.net/documents/artsy-names-new-ceo.pdf">Artsy's new CEO</a> talk about the company's direction.
Mike Steib had only been around for a few months at that point, getting to know the business. He was talking about
the product direction, and I was listening intently.</p>

<p>With Artsy's iOS app, I knew there were only really two directions we could go. As I listened, I reflected on how
we had gotten here.</p>

<!-- more -->


<p>When I joined Artsy in 2014, I joined the Mobile Team. It was an amazing team. While we were called the "mobile"
team, we only worked on Artsy's iOS apps and not the mobile website.</p>

<p>By 2016, Artsy Engineering had grown to the size that having only a "mobile team" and a "web team" was no longer
working well. We dissolved both teams and distributed the engineers into
<a href="https://artsy.github.io/blog/2016/03/28/artsy-engineering-organization-stack/">new product teams</a>, focused on
vertical aspects of Artsy's business. Auctions. Partner Success. Editorial. And so on. The idea was that each team
would have total autonomy over building products to support their slice of the business, and each would have the
engineering and design resources to build new features across both our web and iOS canvases.</p>

<p>That structure worked well, and continues to work well today (we have continued re-organizing ourselves into new
teams to better meet business goals). But once we dissolved the mobile team, there was no longer anyone looking at
our iOS software holistically. The app had become a series of silos â€“ each silo was internally consistent, but
distinct from each other. Often each silo was written in distinct programming languages (we had also started
adopting React Native).</p>

<p>New iOS technologies had been created by Apple, but our teams weren't taking full advantage of them. We would
update to support the latest versions of Xcode and iOS in the free time between other tickets. It wasn't ideal. Of
the <a href="https://github.com/artsy/mobile">five original members of the Mobile Team</a>, everyone else had moved on except
me.</p>

<p>As a product, the app was languishing.</p>

<p>Yet despite this, it was also hugely popular among our users and very important to Artsy's business. Art collectors
love our app! It gets a large percentage of our total sessions. Also, users place an outsized number of auction
bids and artwork inquiries using our app relative to the number of sessions on our website. In fact, the highest
value artwork transaction <em>ever</em> to take place on Artsy was made on an iPad, running software that I helped build.
I'm still pretty proud of that.</p>

<p>So, Wednesday all-hands. I stood there, not sure of what would happen next. I could see Artsy either making a
massive investment in the app, or I could see Artsy cutting its losses and focusing on the software that we already
knew how to build. Which direction we took largely depended on this new CEO, who was now standing in front of us
all and describing the direction Artsy's product would take next.</p>

<a name="The.Dream"></a>
<h2>The Dream</h2>

<p>Mike said something that caused a lot of raised eyebrows in the crowd. People were excited. <em>I</em> was excited.
Artsy's product organization would shift to adopt a "mobile-first strategy."</p>

<p>Someone asked "does this mean the app will reach feature parity with Artsy's website?"</p>

<p>Mike responded: "No. It means that features are going to launch <em>first</em> on the app. If anything, it's the <em>website</em>
that will be catching up <em>to the app</em>."</p>

<p>I was kind of blown away! I mean, this had been the spirit of our original re-org in 2016, but that hadn't really
materialized. The app had continued to trail the website. At most, only one product team was ever building new
features for the app (usually which ever team I happened to be on). Shifting to this mobile-first strategy would be
a <em>massive</em> undertaking, but I was keen.</p>

<p>In August, an email landed in my inbox from Artsy's head of software. He wanted to spin up a new team to focus on
the app: the team would be responsible for supporting Artsy's new mobile-first product strategy. He wanted to know
what I thought, and he wanted to know if I was interested in leading the team.</p>

<p>Honestly, it was a dream come true.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/rfc.png" alt="Screenshot of the RFC for creating the Mobile Experience team" /></p>

<p>Here we are, a year later. This is the story of how Artsy created its Mobile Experience team. How we recovered a
languishing iOS app. How engineers helped shift the product organization to a mobile-first product strategy. And
how Artsy grew from <em>sometimes</em> having <em>a</em> team working on the app, to usually having <em>every</em> team working on it.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/faq.png" alt="Another screenshot of the RFC for creating the Mobile Experience team, describing frequently asked questions" /></p>

<a name="Getting.Our.Bearings"></a>
<h2>Getting Our Bearings</h2>

<p>When Artsy created its new Mobile Experience team, we were already resource-constrained and so the new team would
need to be nimble. We had three full-time engineers (myself as tech lead, and two others), assisted by a designer,
product manager, and data analyst, who would each be spending only half their work time on the Mobile Experience
team. We needed to be scrappy. I'm really proud of the work that that early team accomplished, and I look back
fondly on those first few months working with Sam, Joanna, David, Kieran, and Ani.</p>

<p>The first thing we did was define our own mandate. What was this team responsible for? What was it <em>not</em>
responsible for? "Mobile Experience" is pretty vague, and we had to answer a lot of upfront questions. Would we be
responsible for <em>all</em> of Artsy's iOS software? No, just the main collector app. Would we be responsible for Artsy's
mobile website? No, that's too far-reaching. What about Android? Well, yes, eventually...</p>

<p>After we decided on our mandate, the next step was to get really familiar with the existing app. We storyboarded
out all the existing screens and their connections to one another.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/walkthrough.png" alt="Screenshot of all the screens in our app laid out to discuss" /></p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/brainstorm.png" alt="Screenshot of a brainstorm for app ideas" /></p>

<p>No one on our team had complete knowledge of every screen in the app, not even me, so exploring it together was a
great way to uncover what needed immediate attention. One example was our partner page, which displayed information
to our users about Artsy's partners: galleries, museums, auction houses, etc. We learned that the app actually used
an ancient web view, and it didn't even show the partner's <em>artworks</em>. The artworks! Probably the most important
thing for it to do!</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/old_partner.png" alt="Screenshot of a presentation showing the old partner page" /></p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/new_partner.png" alt="Screenshot of a presentation showing the new partner page, which looks much nicer" /></p>

<p>This is where "being scrappy" started to take root. Usually when developing new features, Artsy designers iterate
on a design before we plan on execution, then we implement, test, and deploy. The nice part of replacing something
that was <em>obviously broken</em> was that we didn't feel beholden to this usual process; whatever we built would be
better than what we had. One engineer and our designer started the new partner page with a quick pencil sketch,
using the app's existing UI abstractions to design something that we could quickly build. Once we had a prototype,
the engineer and designer iterated. The whole project took only about three weeks.</p>

<a name="Early.Wins"></a>
<h2>Early Wins</h2>

<p>Learning about the app itself was critical, but equally important was learning about how our users <em>used</em> the app.
We scheduled user interviews and, in the mean time, looked into our anonymized user analytics. Our data analyst
found a few representative sessions and we walked through each action that a user took. One big lesson here was how
much our app users relied on the app's search feature, which was still written in Objective-C and hadn't been
updated in a long time. We found that users would often search for the same query several times in the same
session. For example, users would search for "banksy", wander off exploring some art, and then return to search for
"bansky" again. And again. And again.</p>

<p>Our search implementation didn't show users their own recent searches, which would have greatly reduced the amount
of friction users experienced while exploring the art world in the app. Our other engineer took point working with
our designer to migrate the app's search to React Native. We also added some other features to our search page,
like adding entity subtitles so users would know if the result they were tapping on was an artwork, and artist, a
gallery, and so on. The whole project took about a month to complete, and we have continued to iterate on the app's
search.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/new_search.png" alt="Screenshot of a presentation showing the new search" /></p>

<p>In early conversations with company leadership, the Mobile Experience team settled on an... interesting strategy to
what we would prioritize. Our mission was "to make the app not suck." This might seem harsh! But it came from a
place of caring. We knew how much better the app could be and we were motivated to make that a reality. In the
spring of 2020, the team felt like we had reached a point where the app no longer "sucked" â€“ our goal now was "to
make the app amazing."</p>

<p>During 2020, we made a lot of changes to the app. We had built a new home page, a profile tab for users, granular
push notification settings, Sign In with Apple, and more.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/new_home.png" alt="Screenshot of a presentation showing the new home page" /></p>

<p>It was really exciting to show off our progress to the rest of the company at our monthly Demo Day, especially in
those early months. The product team makes up only a quarter of our company and it was really cool to hear gallery
liaisons complementing our new partner page, or sales people complementing our refreshed home feed. I think that
people had gotten so used to the app not moving much at all that this sudden high velocity of development was as
exciting for them as it was for us.</p>

<a name="Setting.Up.Others.To.Succeed"></a>
<h2>Setting Up Others To Succeed</h2>

<p>Artsy's goal for the Mobile Experience team was explicitly <em>not</em> to centralize all our iOS feature development, and
so our mandate included much more that just working on iOS software ourselves. We wanted to sit between a typical
product team and a "platform" team, to provide infrastructure and assistance so any team at Artsy could develop
their own iOS feature. This was a big challenge, and required work at the individual and team levels.</p>

<p>The first step was apparent before we even created the Mobile Experience team. Artsy Engineering runs skills
surveys every six months, and we knew that building iOS software in React Native was something Artsy engineers
weren't really familiar with, but that they really wanted to learn more about. I worked with the Engineering team's
Peer Learning Working Group to design a curriculum â€“ big shout out to Christina and Adam for their help here!</p>

<p><a href="https://artsy.github.io/blog/2019/12/03/ios-learning-group/">The iOS Learning Group took four weeks to deliver four lessons</a>.
The learners were mostly web engineers, so I emphasized the familiar parts of writing React Native software. I also
provided weekly office hours for learners to get assistance with homework. I even stretched my wings as an
educator, developing new skills around curriculum design and delivery. After the course, learners responded
positively to the experience and we have integrated lessons learned from the iOS Learning Group into subsequent
peer learning groups.</p>

<a name="Aligning.Product.Releases"></a>
<h2>Aligning Product Releases</h2>

<p>Now that engineers had a solid grasp of how to build software in our application, we could re-align our product
development process around iOS. I can't speak to the design side of this, but from a product perspective the most
critical milestone was defining a regular 2-week app release cadence. Let me explain.</p>

<p>Prior to the Mobile Experience team, we released the app pretty irregularly. We would release whenever we had
something big to release, basically. There are two major flaws with that approach. The first problem is that since
each release was bigger, each release was scarier. No one really felt confident releasing app updates. The second
problem was that large pieces of work tended to get coupled together. This came to a head last summer when we were
blocked from releasing an redesigned artwork view because we were waiting for a major overhaul to Artsy's GraphQL
API to be completed. Without guidance or structure, different teams were building big projects and both had their
changes in our default branch â€“ it was a bit chaotic.</p>

<p>These two problems are incidental to how we worked at Artsy but there is another, inherent problem to developing
mobile apps:
<a href="https://artsy.github.io/blog/2020/03/02/ios-deploys-super-weird-totally-normal/">deploying iOS software is weird</a>.
Engineers, designers, and product managers at Artsy are used to being able to quickly and cheaply deploy software
to the <em>web</em>, not the App Store. iOS software is deployed to our user's hardware, not to servers we control, which
introduces the possibility that users might not upgrade. Software we shipped years ago is still being run today â€“
we have the analytics to prove it. Not to mention that every app update has to go through Apple's App Store review
process. Getting our product team aligned on a release schedule might also help us get aligned on the weirdness of
deploying iOS software.</p>

<center>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">iOS developers! I have a question for you. I hear a lot about teams releasing app updates on a 2-week cadence, to increase user confidence/App Store ranking/team morale/etc.<br><br>Have any teams shared their experiences with this? Bonus points for any quantitative data. Thanks!! ðŸ¤—</p>&mdash; Ash Furrow (@ashfurrow) <a href="https://twitter.com/ashfurrow/status/1184845989510811649?ref_src=twsrc%5Etfw">October 17, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>


<p><br /></p>

<p>As the Mobile Experience team formed, I reached out to other mobile teams to find out about how they structured
regular releases. <a href="https://twitter.com/Cform">Matt Greenwell</a> from BuzzFeed was really helpful in particular,
outlining their experience of the pros and cons of a regular release cadence. We implemented a two-week release
cadence so that all product teams could align their own feature development and testing around this predictable
structure. We also created documentation for teams to hide their in-progress work behind feature flags. And
finally, we refined our app QA process; teams would QA their own features and bug fixes while the Mobile Experience
team would used a QA script to test the app <em>generally</em>, every other Monday, before submitting an update to the App
Store.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/cadence.png" alt="Calendar describing our cadence on an example sprint" /></p>

<a name="Making.Deploys.Not.Scary"></a>
<h2>Making Deploys Not Scary</h2>

<p>To further help teams get into the habit of developing and releasing iOS software often, we created nightly betas.
We also adopted a clever idea from our web colleagues: deploy blocks. In case of a technical reason to not release
a beta, we create a block and the CI job that deploys the beta would fail with a descriptive message. This reduced
a lot of chatter in Slack where engineers would ask "could I make a new beta?" Instead, engineers usually just wait
for the nightly beta. And if they get impatient, they now default to action (their beta deploy will fail if we set
up a block).</p>

<p>All of this was automated through <a href="https://fastlane.tools">fastlane</a> on our CI provider. We had been using fastlane
for a long time at Artsy, but the Mobile Experience team took the time to share knowledge of how it worked. Any
engineer at Artsy can now make a beta (<code>make deploy</code>) or promote the latest beta to an App Store submission
(<code>make promote_beta_to_submission</code>).</p>

<p>We deploy more often and, consequently, each deploy is less scary. And everyone is aware of the need to hide
in-progress work behind feature flags. At this point, updates to our app are mundane, predictable, and boring. Just
the way we like them.</p>

<a name="Being.Generous.With.Our.Time"></a>
<h2>Being Generous With Our Time</h2>

<p>Our QA and deploy process touches on something I want to go into more detail about, which is how the Mobile
Experience team helped support other product teams. I described earlier how Mobile Experience sits somewhere
between a normal product team and a platform team, and we leveraged that to our advantage. It would have been easy
to become primarily a supportive team, and leave feature development up to others. However, that would leave us
unaware of how day-to-day development <em>feels</em> in the app. We own the platform, and that includes the developer
experience. By sitting in this ambiguous in-between state, we stayed aware of both the needs of everyday
developers, and the needs of our platform.</p>

<p>I would encourage engineers from other teams to ask us for help, which led to a lot of pairing sessions. To be
honest, I think it probably interfered with our productivity, but it was worth it. A half hour of my time spent
pairing with a colleague might save them three hours of banging their head against Xcode. But it's not the time
saved that I care about, it's the head-banging. I want engineers at Artsy to feel empowered to build their own iOS
software, and that's only going to happen if they feel comfortable and supported.</p>

<p>When the Galleries team kicked off their ambitious Viewing Rooms project, we helped them get started by lending an
engineer to them for a few sprints. When they ran into problems, we were generous with our time by pairing with
them. When they were nearing completion, we helped them test the new feature. This all culminated in a smooth
release.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/new_loader.png" alt="Screenshot of a presentation showing the new home page's new loading indicator" /></p>

<p>Speaking of Developer Experience, we took a keen interest in standardizing our best practices and modernizing the
codebase. We
<a href="https://github.com/artsy/eigen/blob/dc81bbc9cd33d51d10054a6c57e61a1bd0ee3e75/docs/preferred_practices.md">documented how we wanted the app's codebase to look</a>
and set up
<a href="https://github.com/artsy/eigen/blob/dc81bbc9cd33d51d10054a6c57e61a1bd0ee3e75/tslint-rules/useWrappedComponentsRule.js">processes like lint rules</a>
to encourage developers to follow our best practices. We also invited any engineer at Artsy to join our
twice-weekly Knowledge Share meetings (I'll discuss these in-depth shortly). We looked for bottle necks in the
development process and found many problems, which we addressed.
<a href="https://github.com/artsy/eigen/pull/3022">We combined the Native iOS and React Native repositories</a> (which had
historically been separated). <a href="https://github.com/artsy/eigen/pull/3105">We overhauled the CI configuration</a> to
leverage heavy caching â€“ average build times dropped from fifteen minutes to less than five.
<a href="https://github.com/artsy/eigen/pull/3210">And we adopted stricter TypeScript compiler settings</a> so that engineers
would be forced to deal with nullability and other causes of bugs. (Hey, sometimes you need a carrot and sometimes
you need a stick.)</p>

<p>The React Native community has grown a lot since 2016. If Artsy were to begin our adoption of React Native today,
we would be really well-supported by a community that has defined best practices, documented standard approaches to
problems, and a consolidated opinion on what a React Native codebase should "feel" like. None of that existed in
2016, and our early architectural decisions don't really reflect contemporary best practices. We continue working
to bring our codebase closer to resembling a fresh project created with <code>react-native init</code>.</p>

<p>I'm extraordinarily happy with how things have shaped up, and in the direction we continue to move. This is all an
ongoing process, and should remain an ongoing process. For example, engineers were still facing a bottleneck with
core parts of our app's routing logic that were in Objective-C, so we recently
<a href="https://github.com/artsy/eigen/pull/3771">moved all routing to TypeScript</a>. Not only does moving code out of
Objective-C make it easier for everyone to build, but it also ladders up to a cross-platform Artsy app.</p>

<p>We still have older practices in the app that we want to migrate away from, like testing with Enzyme. But overall,
things are looking good!</p>

<iframe width="100%" height="400" src="https://www.youtube.com/embed/IEn2_WSKFHw" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


<a name="Knowledge.Shares"></a>
<h2>Knowledge Shares</h2>

<p>We achieved most of these big, infrastructural changes in meetings called <em>Knowledge Shares</em>, which I mentioned
earlier. I should write a dedicated blog post on these (update: <a href="/blog/2020/12/09/share-your-knowledge/">I did write one</a>), but in short: Knowledge Shares are a <em>structured</em> time to
facilitate <em>unstructured learning</em>. Anyone can bring a topic to Knowledge Share, from a ticket that they're stuck
on to an idea they have to a neat trick they recently learned. We set aside these two hours a week to discuss
whatever the team wants, and we don't only invite engineers.</p>

<p>New feature designs, product roadmaps, and data analyses are often brought up by our non-engineering colleagues; we
discuss these at the beginning of the meetings to make sure everyone's time is respected. Throughout the week,
someone will raise a question in Slack. Before we had Knowledge Share meetings, we might schedule a dedicated
half-hour meeting to discussing this question. But instead, we now say "alright let's chat about this at tomorrow's
KS." Usually the discussion lasts a lot less than a half hour, so we save time and needless context-switching.</p>

<p>Knowledge Shares are also a manifestation of my philosophy of tech leadership, which is this: none of us have built
an Artsy before, so instead of optimizing for building an Artsy, let's optimize for <em>learning</em> how to build an
Artsy. The best Artsy we can build. And as a natural byproduct, an Artsy gets built. But it's the <em>learning</em> that
is treated as the paramount goal.</p>

<p>Like I said, I owe you a whole blog post on Knowledge Share meetings. I hope I have conveyed how important these
scheduled "structured unstructured learning" times have been for us.</p>

<a name="The.Results"></a>
<h2>The Results</h2>

<p>So where does that leave us? It's been a year and change, where are we now? Well I'm happy to say that we've made a
huge impact. We've gone from only having (at most) one product team writing iOS software at a time to having nearly
<em>every</em> product team building iOS software. Artsy is through the woods of its transition to a mobile-first product
strategy. We still have a ways to go, but it feels like we have finally realized the dream we had in 2016 where
every team is fully equipped and empowered to deliver on their own business goals, across all of Artsy's canvasses.</p>

<p>Our App Store ranking has shot through the roof â€“ not surprising considering our "make it not suck" and then "make
it amazing" approach. Artsy's iOS app rating now sits at a stout 4.7.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/ratings.png" alt="Screenshot of a graph showing an increasing average App Store rating" /></p>

<p>We've also started tracking our iOS developer experience within Artsy. We know exactly where we still need work
because we ask our engineers where they need support.</p>

<p>It's taken a mammoth effort, and there's so much more that I could talk about, but this blog post is long enough
already! Looking at the work we've done, the ways we've done it, and the results of our effort... I feel ecstatic.</p>

<a name="Next.Steps"></a>
<h2>Next Steps</h2>

<p>All that said, Artsy's product team is currently embarking on another reorganization. With so much technical and
product debt paid off, Artsy has evolved past the need for a dedicated Mobile Experience team. It's bittersweet,
but I'm proud to say that the new Collector Experience team is about to be born. Our team will continue to own the
mobile platform, including its holistic user experience and day-to-day developer experience, but we'll have an
expanded mandate. That mandate includes a cross-platform Artsy app that will work for collectors on Android as well
as iOS.</p>

<p>The Mobile Experience team has grown, too. Since we started last year with just a few engineers and limited product
support, we now boast a full roster of engineers and product support. I want to thank everyone on the team,
currently: David, Sam, Brian, Mike, Brittney, Pavlos, and Mounir. You have made the past year an incredibly
rewarding experience for me as I learn the ropes of technical leadership. I'm so proud of what we've built together
and I'm excited for what the new Collector Experience team is going to do next!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deploying canaries with auto]]></title>
    <link href="https://artsy.github.io/blog/2020/02/20/deploying-canaries-with-auto/"/>
    <updated>2020-02-20T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/02/20/deploying-canaries-with-auto</id>
    <content type="html"><![CDATA[<p>Coordinating changes across many packages in the node ecosystem can be quite the challenge. You can use <code>npm link</code>
or <code>yarn link</code> to create a symlink of the package you're developing on into another package, but it
<a href="https://github.com/yarnpkg/yarn/issues/1761#issuecomment-259706202">has some drawbacks</a>. If you're doing local
development and need to rapidly see updates and <code>yarn link</code> isn't working out there's always tools like
<a href="https://github.com/whitecolor/yalc#yalc">yalc</a> to help you out. That's really only for local development though.</p>

<p>What if you need to test packages together in a staging environment? Generally the approach would to be to deploy a
<a href="https://martinfowler.com/bliki/CanaryRelease.html">canary</a> version to npm that you can use in your staging
environment. I'll go over how to do that and how Artsy automates it.</p>

<!-- more -->


<p>Publishing a canary isn't necessarily very hard. It's just a regular publish to npm with a few more steps.</p>

<p>For example, if we were wanting to publish a canary version of <code>@artsy/reaction</code></p>

<ol>
<li>Update <code>package.json</code>, set version to a canary version, e.g. <code>2.0.0-canary-&lt;PR#&gt;</code>, <code>3.1.5-canary-&lt;PR#&gt;</code>, ...</li>
<li>Run <code>npm publish --tag canary</code> in <code>reaction</code> to publish the package under the canary tag</li>
<li>Run <code>yarn add @artsy/reaction@canary</code> to install canary package in the consuming system</li>
</ol>


<p><em>Tip: Running <code>npm dist-tag ls</code> can be helpful to see what tagged packages are available</em></p>

<p>For a lot of people, that'd be enough. End blog post. Here at Artsy, we like things to be a little more
frictionless.</p>

<p>We're already big fans of <a href="https://github.com/intuit/auto">Auto</a>, Intuit's tool for automatically deploying
releases on PR merges. Orta wrote an awesome blog post on how we
<a href="https://artsy.github.io/blog/2019/01/03/label-based-prs/">migrated to auto</a> from semantic-release a while back.</p>

<p>As a short recap, <code>Auto</code> makes the deployable units of a package be a PR instead of a commit. It uses labels like
<code>Version: Major</code>, <code>Version: Minor</code>, etc to determine how the PR will affect the package version. When a PR is
merged it'll automatically cut a released based on that label.</p>

<p>As a testament to how awesome <code>Auto</code> is, it already supports
<a href="https://intuit.github.io/auto/pages/generated/canary.html">canary deployments</a> out of the box!</p>

<p>Essentially when we're on a branch that isn't master our CI runs this command:</p>

<pre><code>auto canary
</code></pre>

<p>and auto takes care of publishing a canary version to NPM <em>and</em> updating the PR description with the version and
instructions on how to use it.</p>

<p>You can <a href="https://github.com/artsy/reaction/pull/3168">check out the PR</a> where I enabled it on reaction to see it in
action. The CI configuration itself is layered behind some
<a href="https://circleci.com/docs/2.0/orb-intro/">CircleCI Orb</a>s. You can find all that configuration in
<a href="https://github.com/artsy/orbs">artsy/orbs</a> if you're curious.</p>

<p>Ultimately the culmination of this work means that every PR to a library at Artsy gets a canary. It's incredibly
simple to test changes in another system now.</p>

<p>There is, however, one caveat. Being as canaries are being deployed to NPM, they need our NPM token. We can't just
share that with everyone, so this functionality doesn't work on forks. Given how CircleCI works, this includes
forks from folks who even have write access to the repository. We're thinking about how to solve that problem but
that'll be another blog post for another day.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keeping Artsy's dependencies up to date]]></title>
    <link href="https://artsy.github.io/blog/2018/11/26/keeping-dependencies-updated/"/>
    <updated>2018-11-26T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2018/11/26/keeping-dependencies-updated</id>
    <content type="html"><![CDATA[<p>Hey everyone! I'm Justin, a senior engineer here at Artsy. I've been here for about 6 months and I'm a bit overdue
on my first blog post. This will be one of a series of posts I'm dubbing <em>roads and bridges</em> (<a href="https://www.fordfoundation.org/about/library/reports-and-studies/roads-and-bridges-the-unseen-labor-behind-our-digital-infrastructure/">thanks Orta</a>)
describing infrastructure and tooling work here at Artsy.</p>

<a name="Backstory"></a>
<h3>Backstory</h3>

<p>Here at Artsy we have a lot of internal dependencies. Keeping these dependencies up to date across all of our
projects can be a bit of a headache. For example, there's <a href="https://github.com/artsy/palette">Palette</a> (our <a href="https://www.uxpin.com/studio/blog/design-systems-vs-pattern-libraries-vs-style-guides-whats-difference/">design system</a>)
which is consumed by <a href="https://github.com/artsy/reaction">Reaction</a> (our react component/app library), <a href="https://github.com/artsy/emission">Emission</a> (our React Native
application), <a href="https://github.com/artsy/force">Force</a> (our main site), and <a href="https://github.com/artsy/positron">Positron</a> (our editorial creation tool). That's not
even an exhaustive list. As you can imagine, after making an update to <a href="https://github.com/artsy/palette">Palette</a> we have to make a lot of
Pull Requests to get everything synced up across our many projects. And that's just <em>one</em> dependency.</p>

<!-- more -->


<a name="Evaluating.the.problem"></a>
<h3>Evaluating the problem</h3>

<p>There are a few services out there that connect to GitHub and helps you keep your dependencies up to date. I'd
personally used <a href="https://greenkeeper.io/">Greenkeeper</a> in the past and it seemed to work fairly well for my uses. I'd also
heard about <a href="https://renovatebot.com/">Renovate</a> which is another option that actually supports more package managers than just
yarn/npm. Great! Plenty to evaluate here. Anytime I'm evaluating a new service there are a few questions I ask
myself upfront to help a good decision:</p>

<ol>
<li>What are my exact needs</li>
<li>Can this solution scale to meet future needs</li>
</ol>


<p>The first point is straight-forward, but there's a little twist. We have a <em>lot</em> of dependencies. If we got PRs for
all of them we'd be pretty much unable to do anything. In this case we wanted to specifically limit it to packages
that are published by Artsy (on the <code>@artsy</code> npm namespace).</p>

<p>The second you have to be a bit careful with. Don't try to project too far or you'll end up choosing a solution far
too complex for your current needs. In this case, I wanted something that we could selectively extend in the future
to cover other dependencies. Things like <code>react</code> and <code>react-dom</code> or <code>typescript</code>. Incremental increases without a
ton of noise.</p>

<a name="Picking.a.solution"></a>
<h3>Picking a solution</h3>

<p>First things first... we have to have a solution that can update only Artsy's dependencies. I started digging
through <a href="https://greenkeeper.io/">Greenkeeper</a>'s docs and found a reference to an <a href="https://greenkeeper.io/docs.html#ignoring-dependencies">ignore</a> option.
Essentially any package that you don't want <a href="https://greenkeeper.io/">GreenKeeper</a> to automatically update you can put in this
ignore list. That's not really doable in our usecase because we want to ignore everything but a small subset of
packages.</p>

<p>Checking out <a href="https://renovatebot.com/">Renovate</a>'s docs I found a more promising option:
<a href="https://renovatebot.com/docs/configuration-options/#excludepackagepatterns">excludePackagePatterns</a>. All I really want to do is include Artsy packages, but this sounded
like I could do the inverse by excluding all non-Artsy packages. Being as it had that option, supported more
package managers, and had a more friendly pricing scheme than <a href="https://greenkeeper.io/">Greenkeeper</a> I decided to give
<a href="https://renovatebot.com/">Renovate</a> a shot.</p>

<a name="Making.it.happen"></a>
<h3>Making it happen</h3>

<p>I began by enabling <a href="https://renovatebot.com/">Renovate</a> on <a href="https://github.com/artsy/force">Force</a>. You can see the PR <a href="https://github.com/artsy/force/pull/3086">here</a>.
<a href="https://renovatebot.com/">Renovate</a> has a <em>really</em> excellent on-boarding experience. It first creates a PR that adds its own
configuration. It shows you what packages will be updated based on that configuration. As you update the config,
Renovate will update the PR body to show you the results of your changes. This gives you the opportunity to update
the configuration before it officially activates. If you click the edited dropdown on the PR body you'll see all
the changes Renovate made to the issue while I was trying to figure out the configuration.</p>

<p><img src="/images/2018-11-26-keeping-dependencies-updated/issue-history.png" alt="GitHub PR edit history" /></p>

<p>It took me a while to figure everything out, just take a look at the <a href="https://github.com/artsy/force/pull/3086/commits">commit history</a>. I'm going to
work through the final setup just to give you an idea of our setup.</p>

<p>First, I extended <a href="https://renovatebot.com/">Renovate</a>'s base config.</p>

<pre><code>{
  "extends": [
    "config:base"
  ],
  ...
}
</code></pre>

<p>If you've worked with <a href="https://eslint.org">eslint</a>, <a href="https://babeljs.io/docs/en/options#extends">babel</a>, or other tools in the js ecosystem, you've probably
seen this type of configuration extension. It essentially allows us to use their best practices out of the box.
Check out their <a href="https://github.com/renovatebot/presets/blob/ef6a6e2e6d3e6ba25239d57d808b0e4dc64f32a3/packages/renovate-config-config/package.json#L19-L34">presets repo</a> if you want to know what it adds specifically.</p>

<p>Next, I set the <a href="https://help.github.com/articles/assigning-issues-and-pull-requests-to-other-github-users/">assignees</a>. When <a href="https://renovatebot.com/">Renovate</a> opens a new PR, it'll assign it to these people
so that the PR doesn't get missed.</p>

<p>The actual meat of the change is the <code>packageRules</code> setup.</p>

<pre><code>{
  ...
  "packageRules": [{
    "packagePatterns": ["*"],
    "excludePackagePatterns": ["^@artsy"],
    "enabled": false
  }],
  ...
}
</code></pre>

<p><a href="https://renovatebot.com/">Renovate</a> allows you to set up multiple different <code>packageRules</code> and there's a lot of configuration for
them. I'm not going to go through more than I did, but feel free to read more in their
<a href="https://renovatebot.com/docs/configuration-options/#packagerules">docs</a>. In the <code>packageRule</code> that I setup, I specified <code>packagePatterns</code> with an
asterisk to select all dependencies. Then using <code>excludePackagePatteners</code> I excluded anything that started with
<code>@artsy</code>. Finally (and most importantly), I set <code>enabled</code> to <code>false</code> to disable the dependencies matching those
combinations of rules. That last part took me a while to figure out. When you're building package rules in
<a href="https://renovatebot.com/">Renovate</a>, think of it as building out a list of operations to perform.</p>

<p>The last few pieces of config are a little more straight-forward and you can read about those in the docs. The one
thing that I'll mention is that <a href="https://renovatebot.com/docs/configuration-options/#vulnerabilityalerts">vulnerabilityAlerts</a> <em>ignores</em> <code>packageRules</code> and
triggers update PRs for anything that's reported to have a vulnerability. You'll have to explicitly disable it if
you only want reports on certain packages. Though, having it on probably isn't a bad idea...</p>

<a name="Wrapping.up"></a>
<h3>Wrapping up</h3>

<p>So, that's how we configured <a href="https://renovatebot.com/">Renovate</a> to automatically update npm dependencies in Artsy's namespace.
It's been extremely useful already. I also went ahead and pulled our configuration out into a <a href="https://github.com/artsy/renovate-config">shared
repo</a> so that we didn't have to copy these configurations across all of our projects. That's
a blog post for another day.</p>

<p>Be well friends.</p>

<!-- prettier-ignore -->


<!-- prettier-ignore -->


<!-- prettier-ignore -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Express Reloadable: Optimizing Express.js Development Speed]]></title>
    <link href="https://artsy.github.io/blog/2017/12/05/Express-Reloadable-Update/"/>
    <updated>2017-12-05T14:18:00+00:00</updated>
    <id>https://artsy.github.io/blog/2017/12/05/Express-Reloadable-Update</id>
    <content type="html"><![CDATA[<p>In <a href="artsy.github.io/blog/2017/09/05/Modernizing-Force/">Modernizing Force</a> we discussed some of the tools we've been working with to modernize <a href="https://www.artsy.net/">Artsy.net</a>'s development environment, from introducing Babel and React to the creation of <a href="https://github.com/artsy/stitch">@artsy/stitch</a>. Increasing overall development speed was another aim, and to that end we released <a href="https://github.com/artsy/express-reloadable">@artsy/express-reloadable</a> which automatically hot-swaps Express.js code without the restart. In this post I'd like to cover some of the issues we've faced since then, and in particular our solution to library code-sharing in Express apps.</p>

<!-- more -->


<p>It's common to share NPM packages across projects, and oftentimes packages are developed in parallel. Package <code>A</code> depends on <code>B</code>, but <code>B</code> has a bug and you don't want to have to republish (and reinstall) the package in order to see changes made locally. <code>yarn link</code> (or <code>npm link</code>) was developed for instances like this and while it works great for stop and start processes where boot time is quick, it falls short if the development environment takes a while to load. In UI-rich environments like <a href="https://github.com/artsy/positron">Positron</a> (our Publishing CMS called "Writer") and <a href="https://github.com/artsy/force">Force</a>, each boot would come at a high time-cost due to upfront compilation of assets. Tools like <a href="https://github.com/remy/nodemon">nodemon</a> would automatically stop and start our server process when assets changed but that still didn't alleviate slow iteration times.</p>

<p>To recap from a <a href="/blog/2017/09/05/Modernizing-Force#iteration-time">previous post</a>, <a href="https://github.com/artsy/express-reloadable">@artsy/express-reloadable</a> allows devs to immediately see changes to running Express.js app code:</p>

<pre><code class="javascript">import express from 'express'
import { createReloadable, isDevelopment } from '@artsy/express-reloadable'

const app = express()

if (isDevelopment) {
  const mountAndReload = createReloadable(app, require)
  mountAndReload('./api')
}
</code></pre>

<p>Changes made within the <code>api</code> folder are detected and instantly hot-swapped in, and all that's required is a new http request; this is down from an average dev cycle of about 40 seconds for Artsy.net. However, we found an exception while building out Artsy's new <a href="https://www.artsy.net/article/artsy-editorial-midwest-made-artists-mike-kelley-jim-shaw">editorial pages</a>, which involved sharing React components from our UI library <a href="https://github.com/artsy/reaction">Reaction</a> <a href="https://github.com/artsy/positron/blob/master/client/apps/edit/components/content/section_tool/index.jsx#L11">between Positron</a> <a href="https://github.com/artsy/force/blob/master/desktop/apps/article/components/InfiniteScrollArticle.js#L9">and Force</a>. Even though we ran <code>yarn link @artsy/reaction</code> in each consumer app, changes would not be detected and so we had to do a full restart.</p>

<p>To address this, a new <code>watchModules</code> feature <a href="https://github.com/artsy/express-reloadable/pull/3">was added</a>:</p>

<pre><code class="javascript">mountAndReload('./api', {
  watchModules: [
    '@artsy/reaction',
  ]
})
</code></pre>

<p>Similar to how files in <code>api/</code> are hot-swapped in on change, symlinked NPM modules placed in the <code>watchModules</code> array will now be reloaded, too.</p>

<p>References:</p>

<ul>
<li><a href="https://github.com/artsy/express-reloadable">@artsy/express-reloadable</a></li>
<li><a href="https://github.com/artsy/positron">Positron</a></li>
<li><a href="https://github.com/artsy/reaction">Reaction</a></li>
<li><a href="https://github.com/artsy/force">Force</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mashing Data, Making Maps]]></title>
    <link href="https://artsy.github.io/blog/2017/01/25/mashing-maps/"/>
    <updated>2017-01-25T14:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2017/01/25/mashing-maps</id>
    <content type="html"><![CDATA[<p>We have a lot of really awesome data. Things worth exploring, and visualizing. We have an entire team devoted to it, <a href="https://www.artsy.net/article/artsy-jobs-data-analyst">looks like they're hiring too</a>. Not all of the output of the data comes from that team though, 2 years ago our Director of Product Engineering, <a href="https://github.com/craigspaeth">Craig Spaeth</a> created a <a href="https://github.com/artsy/partner-map">static-site generator</a> that mapped our partners around the globe. Last week I've been improving it.</p>

<p><img src="/images/mappings/preview.gif" alt="An animated map of galleries" /></p>

<p>Projects like these happen in most companies, quick hacks for one offs that are opened 2 years later by someone completely different to build on top of it. In trying to follow <a href="http://programmer.97things.oreilly.com/wiki/index.php/The_Boy_Scout_Rule">the Boy Scout rule</a>, I've cleaned it up and consolidated some other similar projects. This post is a rough road-map of what making <a href="https://github.com/artsy/partner-map/pull/3">this PR</a> looked like.</p>

<!-- more -->


<p>The aim was to visualise data we had created on when galleries were founded. Then to be able to see how that corresponds with our artwork inquiry data.</p>

<a name="Coming.back.to.an.npm.app.2.years.later"></a>
<h2>Coming back to an npm app 2 years later</h2>

<p>Straight off the bat, nothing worked :D</p>

<p>This isn't too surprising, I'm pretty sure we'd have the same problem with an iOS project too. This was mainly due to dependencies switching between major versions due to zero locking on any of the versions.</p>

<pre><code class="json">{
  ...
  "dependencies": {
    "async": "*",
    "browserify": "*",
    "coffee-script": "*",
    "coffeeify": "*",
    "d3": "*",
    "datamaps": "git://github.com/markmarkoh/datamaps.git",
    "mongojs": "*",
    "topojson": "*",
    "watchify": "*"
  }
}
</code></pre>

<p><a href="/blog/2016/11/14/JS-Glossary/#yarn">Switching to Yarn</a> fixed this by introducing a lock file, this means that the next time someone else comes along they'll get the exact same setup that I've been working against.</p>

<a name="CoffeeScript"></a>
<h2>CoffeeScript</h2>

<p>I have zero experience with <a href="http://coffeescript.org">CoffeeScript</a>. My high-level JavaScript experience only comes from the last 6 months, and it's a different world at the minute. Two years ago CoffeeScript was in it's prime, as the first of the JavaScript transpilers - if this is new to you, I'd strongly recommend watching this talk:</p>

<iframe width="640" height="360" src="https://www.youtube.com/embed/DspYurD75Ns" frameborder="0" allowfullscreen></iframe>


<p>&nbsp;</p>

<p>We have a lot of CoffeeScript in production, here's a few key parts of Artsy's infrastructure:</p>

<ul>
<li><a href="https://github.com/artsy/force">artsy/force</a> - our website</li>
<li><a href="https://github.com/artsy/microgravity">artsy/microgravity</a> - our mobile website</li>
<li><a href="https://github.com/artsy/positron">artsy/positron</a> - our editorial staff's CMS</li>
</ul>


<p><a href="https://github.com/artsy?language=coffeescript">..and there's more</a>. Thus having an understanding of it is pretty essential to writing code across all of Artsy's businesses. The TLDR for CoffeeScript is that it applies a lot of the elegance in Ruby to JavaScript. You should feel comfortable with JavaScript before using it, as it requires understanding what the language facade is doing.</p>

<p>A lot of the best ideas from CoffeeScript have been migrated into <a href="/blog/2016/11/14/JS-Glossary/#es6">modern JavaScript</a>. My favourite is ease in how functions can be created:</p>

<pre><code class="coffee">random = (min, max) -&gt; Math.round(Math.random() * (max - min) + min)
</code></pre>

<p>It also supports my favourite part of <a href="http://danger.systems/guides/a_quick_ruby_overview.html#variables-and-keyword-syntax">Ruby's handling of code-flow</a> using single-line reverse ifs:</p>

<pre><code class="coffee">pgClient.connect (err) -&gt; 
  console.error(err) if err
</code></pre>

<p>Which gets to the crux of CoffeeScript's ideology, I would often start with writing it in JavaScript in my head, then slowly remove syntax. When I got stuck I visited <a href="http://js2.coffee">js.coffee</a> to see how something I know what I want to write would look.</p>

<a name="Databases"></a>
<h2>Databases</h2>

<p>You want to convert all data your companies data into something useful? You better get that data available locally or you're going to spend a long time iterating. As a side-effect of Artsy converting <a href="/blog/2014/05/12/continuous-integration-for-service-oriented-architectures/">to microservices</a> I needed three separate databases to connect all the data I needed. It covers over two types of databases: MongoDB and Postgres.</p>

<a name="MongoDB"></a>
<h3>MongoDB</h3>

<p>MongoDB is a NoSQL document store database, this means it has no formal data-structure. It feels very JavaScript-y because of this. I host it <a href="http://gcollazo.github.io/mongodbapp/">inside an app</a>, and I <a href="https://robomongo.org">use RoboMongo</a> to inspect it.</p>

<p></div></div><a href='/images/mappings/robomongo.png'><img src="/images/mappings/robomongo.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>This works out nicely, I needed to make a local copy of the databases, so I used the answers from this <a href="http://stackoverflow.com/questions/23652402/how-to-copy-a-collection-from-one-mongodb-to-another">stack overflow</a></p>

<pre><code class="sh"># You'll need to figure out how to connect to your database
mongoexport -d gravity_staging -c artworks -o artworks_collection.json

# Then into merge it into your development machine
mongoimport -d gravity_development -c artworks --file artworks_collection.json
</code></pre>

<p>Doing this for the specific collections you're interested in will help get you set up.</p>

<a name="Postgres"></a>
<h3>Postgres</h3>

<p>Other databases I needed access to were Postgres databases, I don't know much about databases but Postgres seems to be <a href="https://blog.heroku.com/postgres-essentials">Heroku's favourite database</a> so I'll take that endorsement as gold. It's an SQL database, which you can do <a href="https://github.com/calebmer/postgraphql">amazing things with</a>. I host it <a href="http://postgresapp.com">inside an app</a> and use <a href="https://eggerapps.at/postico/">Postico</a> to inspect it.</p>

<p></div></div><a href='/images/mappings/postico.png'><img src="/images/mappings/postico.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>I grabbed a <a href="https://devcenter.heroku.com/articles/heroku-postgres-backups">backup</a> of our databases, they come down as a <a href="https://www.commandprompt.com/blog/a_better_backup_with_postgresql_using_pg_dump/">pg_dump file</a> file which you can replicate locally in your postgres using a command like:</p>

<pre><code class="sh">pg_restore --verbose --clean --no-acl --no-owner -h localhost -U [your_name] -d [db_name] [filepath]
</code></pre>

<a name="Database.as.CSV"></a>
<h3>Database as CSV</h3>

<p>This almost gave me all the data necessary to start work. The other part is a good chunk of new data we wanted mapping was not in a database, it was in a collection of spreadsheet files and occasionally hosted on google docs. Meaning it's time to reach for a good parser. Whenever this happens I reach for Ruby, which ships with a great CSV parser/writer. I also open the CSV inside <a href="http://www.apple.com/numbers/">Numbers</a> from Apple, which does a great job of providing visibility ( and letting you make quick changes.)</p>

<p>I have a bunch of scripts like this, one which generate more CSV files - I'm keeping the filenames intact to give you a real sense of how much of a quick hack these are:</p>

<pre><code class="ruby"># Create a new CSV file
CSV.open("/Users/orta/Downloads/end-result.csv", "wb") do |csv|
  # Loop through both derived tables
  tables = ["Partners-Table 1.csv", "Non-Partners-Table 1.csv"]
  tables.each do |t| 
    CSV.foreach("/Users/orta/Documents/Gallery\ Date\ Research/" + t) do |row|
      next unless row[0] # bad data
      next unless row[1] # no dates

      # don't trust the CSV
      query = Regexp.new(row[0], Regexp::IGNORECASE)
      partner = Partner.where(given_name: query).first
      partner ||= Partner.where(display_name: query).first

      start_date = row[1]

      # did we find a partner &amp; a location?
      if partner and partner.location_coordinates and partner.location_coordinates.first
        loc = partner.location_coordinates.first
        csv &lt;&lt; [partner.name, start_date, loc[:lat], loc[:lon]]
      else
        csv &lt;&lt; [row[0], start_date, nil, nil]
        # look up org in burden inside postgres
        # go from org -&gt; lat, long via location's organization_id
      end
    end
  end
end
</code></pre>

<p>Once this was ready I created a new script to pull things from another databasea, in theory this code could have gone inside the previous script, but it felt like a good time to get up and make a tea during a pairing session.</p>

<pre><code class="ruby">require 'CSV'
conn = PG.connect(host: "localhost", dbname: 'burden')

# Write to another end-results
CSV.open("/Users/orta/Downloads/end-result-2.csv", "wb") do |csv|
  CSV.foreach("/Users/orta/Downloads/end-result.csv") do |row|
    # gravity lookups passed, don't need to do anything
    if row &amp;&amp; row[2]
      # put in the normal row
      csv &lt;&lt; row
      next
    end

    # Galleries  have ' in their names, breaking SQL
    name = row[0].gsub(/'/, "\\'")
    result = conn.exec( "SELECT latitude, longitude FROM locations WHERE organization_id in (SELECT id FROM organizations WHERE name = '#{name}') " )

    # If we've found something, set it
    if result.cmd_tuples &gt; 0 and result[0]
      row[2] = result[0]["latitude"]
      row[3] = result[0]["longitude"]
    end
    result.clear

    csv &lt;&lt; row
  end
end
</code></pre>

<p>Then finally with a fully fleshed out CSV, I could convert that into something that's useful for this project, JSON:</p>

<pre><code class="ruby">require 'CSV'
require 'JSON'

data = []
CSV.foreach("/Users/orta/Downloads/end-result-2.csv") do |row|
  created_at = row[1]
  if row[1] &amp;&amp; created_at.strip.length &gt; 0 &amp;&amp; row[2] and row[3]
    data &lt;&lt; { name: row[0], radius: 4, created_at: created_at.to_i, latitude: row[2].to_f, longitude: row[3].to_f }
  end
end

File.open("/Users/orta/dev/js/sites/partner-map/data/jsons/galleries-subset.json","w") { |f| f.write( data.sort_by { |h| h[:created_at] }.to_json) }
</code></pre>

<p>And that gives me the raw data that I can now use with our mapping system.</p>

<a name="D3...Datamaps"></a>
<h2>D3 + Datamaps</h2>

<p>There are concepts that you can just pick up, because they are simple evolutions of something you know. <a href="https://d3js.org">D3 is not one of these</a>. D3 is a system for making data-based graphical documents. Learning how to do D3 properly takes time and a perspective change. Luckily we had a Lunch &amp; Learn <a href="https://twitter.com/orta/status/809451441882628096">2 weeks ago on D3</a> and now I am a total domain expert.</p>

<p>I jest. However, the talk was definitely enough to do the majority of what I wanted to do. Which was take some static data, and animate it over time. In these cases I get out the trusty <code>setTimeout</code> API call in JavaScript which gets the ball rolling.</p>

<p>I had a few thousand datapoints with a <code>date_created</code> attribute, so it was pretty simple to pull that out and  group them according to a time interval. I wanted the freedom to decide how long each animation should last, there probably is a D3 API for this kind of thing but I never spent the time researching. Maybe the next developer can do that.</p>

<p>We use the <em>amazing</em> library <a href="http://datamaps.github.io">Datamaps</a> to show the globe and handle a lot of the lat/long -> pixel mathematics. It is built in a D3 mindset, so with each interval of the animation, I added all of the locations or arcs to it and D3/Datamaps will derive the difference between what it has and what is new and animate those. This makes thinking about the animation simple.</p>

<a name="Too.much.data"></a>
<h2>Too much data</h2>

<p>One problem I kept hitting against was that we were working with a dataset that couldn't fit into memory. Initially a direct port of our algorithm to get all of Artsy's partners and locations would crash node due to memory pressure. Originally we were working with a much smaller data-set, now it's multiple orders of magnitude bigger. These were pretty easy to fix with a bit of understanding about all the asynchronous callbacks and by finding the <code>async.eachOfLimit</code> <a href="http://caolan.github.io/async/docs.html#eachOfLimit">function</a>.</p>

<p>Another issue with the amount of data came through trying to visualise them. It would bring down my computer, in the end after trying a few ideas (looking for averages, grouping similar data-points) I found the simplest option to be the one worth shipping. <code>rand(x, y)</code>.</p>

<pre><code class="coffee">#
# Take a set of arcs, and pick a random 1 in x
# yarn run coffee -- data/inquiries/inquiry-random-subsets.coffee
#

fs = require 'fs'

# Random number between min, max
random = (min, max) -&gt; Math.round(Math.random() * (max - min) + min)

# Take an array or arcs, and reduce it to one in amount, then save to path
derive = (amount, arcs, path) -&gt;
  luckyOnes = arcs.filter (arc) -&gt; random(0, amount) == 23
  console.log "There are #{luckyOnes.length} arcs from #{arcs.length} in #{path}"
  fs.writeFileSync __dirname + '/' + path, JSON.stringify luckyOnes

all_arcs = require '../jsons/every-inquiry-arcs.json'
derive(1500, all_arcs, "../jsons/all-inquiries-random-subset.json")
</code></pre>

<p>This ended up creating a pretty useful representation of the whole data-set, in a way that is actually renderable without killing the browser's process.</p>

<a name="Code.Cleanup...Docs"></a>
<h2>Code Cleanup + Docs</h2>

<p>I spent most of my time inside <a href="https://github.com/artsy/partner-map">artsy/partner-map</a> but we had another repo with very similar code, <a href="https://github.com/artsy/inquiry-map">partner/inquiry-map</a>. So I took the time to merge the two of them, officially deprecating inquiry-map. Now those maps can be generated by partner-map, and there's space for more expansion.</p>

<p>Other than that, I took the time to improve the repo and to do this write-up, so that the next person who comes along can have an idea of some of the scripts and how they all fit together.</p>

<a name="Going.solo"></a>
<h2>Going solo</h2>

<p>For a project like this, I did no code review, no testing or other staples of engineering culture at Artsy. This is fine for a project of this scope and pace.</p>

<p>However, I think it's always worth throwing in an extra 2-3 hours at the end of a hack project to write up some of the tricky parts and cleaning up the codebase for the next person. If you don't write some tests, then writing some docs or do a <a href="http://artsy.github.io/blog/2015/11/05/Emergence-Code-Review/">quick video</a>.</p>
]]></content>
  </entry>
  
</feed>
