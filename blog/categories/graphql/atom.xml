<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: GraphQL | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/graphql/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2024-05-17T14:49:02+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Effortless Pagination with GraphQL and Relay? Really!]]></title>
    <link href="https://artsy.github.io/blog/2020/01/21/graphql-relay-windowed-pagination/"/>
    <updated>2020-01-21T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/01/21/graphql-relay-windowed-pagination</id>
    <content type="html"><![CDATA[<p>It’s the year 2020. You use a modern front-end stack of <a href="https://relay.dev/">Relay</a>,
<a href="https://graphql.org/">GraphQL</a>, <a href="https://reactjs.org/">React</a> and <a href="https://www.typescriptlang.org/">TypeScript</a>.
You can build an infinite scroll ‘feed’ type UI totally out of the box with these tools, by mostly putting together
boilerplate (proper <a href="https://facebook.github.io/relay/graphql/connections.htm#sec-Connection-Types">connections</a>,
along with a <a href="https://relay.dev/docs/en/pagination-container">pagination container</a>). You have a design system, and
are rapidly building up a component library. Things are great!</p>

<p>Then you take a look at the latest design comps for a ‘browse’ type page, and you see that the
<a href="https://medium.com/simple-human/7-reasons-why-infinite-scrolling-is-probably-a-bad-idea-a0139e13c96b">controversial</a>
infinite scroll has been replaced by a more traditional pagination bar.</p>

<p>You know the one. Like the following, from <a href="https://www.amazon.com">Amazon</a>:</p>

<p><img src="/images/2020-01-21-graphql-relay-windowed-pagination/amazon.png" /></p>

<p>You start to realize that the cursor-based setup of a connection, along with a Relay pagination container, does not
lend itself to this more traditional UI. For one thing, a user can arbitrarily ‘jump’ to any page by including a
<code class="language-plaintext highlighter-rouge">?page=X</code> query param (typically). For another, the user can only actually see the current page of content, versus
a feed. As you go to sleep and dream of REST, Rails controllers, <a href="https://github.com/kaminari/kaminari">kaminari</a>,
<a href="https://github.com/mislav/will_paginate">will_paginate</a>, and a simpler time, you start to have a vision…</p>

<!-- more -->

<p>To get a good primer of what a GraphQL connection is and why they’re so useful, read this
<a href="https://blog.apollographql.com/explaining-graphql-connections-c48b7c3d6976">excellent Apollo blogpost</a>. Seriously.
It’s one of the best writeups on this subject out there. I’ll assume basic familiarity with connection types from
this point forward.</p>

<p>We prefer to use connections in place of lists almost always. Not only do they provide a preferred cursor-based
pagination API for clients, but their type specification (a map vs a list) is naturally forward-looking. Even if
you do no pagination, a pure list type can’t accomodate returning other metadata (such as a <code class="language-plaintext highlighter-rouge">totalCount</code>) alongside
the list. Additionally, if your data is very relational and better represented as nodes connected by edges (which
would contain data about the ‘join’ of the two nodes), the connection type gives one more flexibility than a simple
list. This (and more) is all covered in the aforementioned blog post.</p>

<p>So, let’s start by taking a look at our desired pagination UI, and think about what kind of schema/components make
sense.</p>

<p><img src="/images/2020-01-21-graphql-relay-windowed-pagination/pagination.png" /></p>

<p>There looks to be several types of appearances we want to show, based on the total size of our list and fixed page
size chosen, as well as the current page. There’s also some edge cases of empty lists, or lists that are short
enough to just display all their page numbers. Users can click on any displayed page number to jump to it. There’s
a prev/next navigation, which brings the user forward and back one page at a time. Whenever the current page
changes, the URL should update accordingly. For a responsive implementation, we want to hide the page numbers, and
only show the prev/next toggles on small screens.</p>

<p>Wow! Ok, we have our work cut out for us. But wait til you see how easy this is! There’ll be links to our actual
production components involved (all open-source) at the end.</p>

<h2 id="pagination-schema">Pagination Schema</h2>

<p>Let’s tackle the first part of this, which is: how do we adapt the
<a href="https://facebook.github.io/relay/graphql/connections.htm">GraphQL connection spec</a> in order to hold necessary
information that a UI might need? Generally we want the UI’s to be as simple as possible, and so if the server
could construct a suitable pagination schema, that would be preferable. The simpler our UI, and the more business
logic and good abstractions made in our GraphQL server, the more portable and reusable this all becomes.</p>

<p>What kind of data does the UI need, in order to render a particular page of contents? Well, for a particular page
we’d need to render the actual number it corresponds to. We’ll need to know if this is the current page or not (so
we can distinguish it in the UI from neighboring pages). And, we’ll need to know the actual cursor (think:
<a href="https://relay.dev/graphql/connections.htm">opaque string</a>) that corresponds to this page number. It seems likely
we’ll need some sort of way to construct cursors from page numbers, on the server.</p>

<p>So, check this out:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// SDL</span>
<span class="nx">type</span> <span class="nx">PageCursor</span> <span class="p">{</span>
  <span class="nl">cursor</span><span class="p">:</span> <span class="nb">String</span><span class="o">!</span>
  <span class="nx">pageNumber</span><span class="p">:</span> <span class="nx">Int</span><span class="o">!</span>
  <span class="nx">isCurrent</span><span class="p">:</span> <span class="nb">Boolean</span><span class="o">!</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">PageCursors</span> <span class="p">{</span>
  <span class="nl">first</span><span class="p">:</span> <span class="nx">PageCursor</span>
  <span class="nx">around</span><span class="p">:</span> <span class="p">[</span><span class="nx">PageCursor</span><span class="o">!</span><span class="p">]</span><span class="o">!</span>
  <span class="nx">last</span><span class="p">:</span> <span class="nx">PageCursor</span>
  <span class="nx">previous</span><span class="p">:</span> <span class="nx">PageCursor</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is our pagination schema. Including a field of type <code class="language-plaintext highlighter-rouge">pageCursors</code> as a connection-level field, onto a
connection, is sufficient for a UI to incredibly simply ‘just render’ a correct pagination bar always, and be able
to hook up proper interactions. We can fully construct a simple UI (using Relay, shown in the next section) that
can present and allow for the interactions desired, for windowed pagination.</p>

<p>But, of course we’re glossing over the implementation for such a <code class="language-plaintext highlighter-rouge">pageCursors</code> type, so let’s check that out before
looking at how a client might consume this.</p>

<p>Our backing API’s largely still paginate via offsets, and not cursors. That is, they accept page/size or
size/offset style arguments. We use <a href="https://github.com/graphql/graphql-relay-js">graphql-relay-js</a>, which includes
helpers to make sure types and resolvers are compatible with some Relay expectations. So, we use this library to
generate our cursors, and can convert the cursor to an offset. A page of 4 with a size of 10, returns the elements
numbered 30 - 39 in that list. So a page of 4 (and size of 10), is equivalent to an offset of 29 (and size of 10).
We have:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">pageToCursor</span> <span class="o">=</span> <span class="p">(</span><span class="nx">page</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">String</span><span class="p">((</span><span class="nx">page</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This gives us the offset of the last value of the previous page. While our upstream services are all still
paginating using this size/offset method, the <a href="https://relay.dev/graphql/connections.htm">GraphQL cursor spec</a>
prefers opaque cursors to be used on the client. This allows the actual implementation of pagination to change
upstream while clients remain unaffected. Thus if we ever update our upstream pagination arguments/logic/setup, we
could update this schema implementation accordingly, and clients would continue to be functional.</p>

<p>For inspiration in constructing our <code class="language-plaintext highlighter-rouge">first</code>, <code class="language-plaintext highlighter-rouge">last</code>, and <code class="language-plaintext highlighter-rouge">around</code> groups, we turn to
<a href="https://www.fngtps.com/">Fingertips</a> and their
<a href="https://github.com/Fingertips/peiji-san/blob/6bd1bc7c152961dcde376a8bcb2ca393b5b45829/lib/peiji_san/view_helper.rb#L87">pagination library</a>.
That code goes through the various cases possible (a short list, a long list where the current page is near the
front, middle or end, various degenerate cases, etc.), and returns a proper structure that represents this data. It
can handle all combinations of list sizes, and current position relative to the total size.</p>

<p>In pseudo-code, it looks like:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="nx">emptyList</span>
  <span class="nx">around</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">else</span> <span class="k">if</span> <span class="nx">listIsShort</span>
  <span class="nx">around</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">...</span><span class="nx">totalPages</span><span class="p">]</span>
<span class="k">else</span> <span class="k">if</span> <span class="nx">nearBeginning</span>
  <span class="nx">around</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">...</span><span class="mi">3</span><span class="p">]</span>
  <span class="nx">last</span> <span class="o">=</span> <span class="p">[</span><span class="nx">totalPages</span><span class="p">]</span>
<span class="k">else</span> <span class="k">if</span> <span class="nx">nearMiddle</span>
  <span class="nx">first</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="nx">middle</span> <span class="o">=</span> <span class="p">[</span><span class="nx">currentPage</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">currentPage</span><span class="p">,</span> <span class="nx">currentPage</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
  <span class="nx">last</span> <span class="o">=</span> <span class="p">[</span><span class="nx">totalPages</span><span class="p">]</span>
<span class="k">else</span> <span class="k">if</span> <span class="nx">nearEnd</span>
  <span class="nx">first</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="nx">around</span> <span class="o">=</span> <span class="p">[</span><span class="nx">last</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">last</span><span class="p">,</span> <span class="nx">last</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<p>Our full implementation of that method can be found
<a href="https://github.com/artsy/metaphysics/blob/205592be7f59970cf80313972ceb95bb1579c31f/src/schema/v2/fields/pagination.ts#L96">here</a>.</p>

<p>For a real-life example, check out
<a href="https://metaphysics-staging.artsy.net/v2?query=%7B%0AartworksConnection(first%3A5%2C%20after%3A%20%22YXJyYXljb25uZWN0aW9uOjE0%22)%20%7B%0A%20%20pageInfo%20%7B%0A%20%20%20%20hasNextPage%0A%20%20%20%20endCursor%0A%20%20%7D%0A%20%20pageCursors%7B%0A%20%20%20%20first%20%7B%0A%20%20%20%20%20%20cursor%0A%20%20%20%20%20%20page%0A%20%20%20%20%20%20isCurrent%0A%20%20%20%20%7D%0A%20%20%20%20last%20%7B%0A%20%20%20%20%20%20cursor%0A%20%20%20%20%20%20page%0A%20%20%20%20%20%20isCurrent%0A%20%20%20%20%7D%0A%20%20%20%20around%20%7B%0A%20%20%20%20%20%20cursor%0A%20%20%20%20%20%20page%0A%20%20%20%20%20%20isCurrent%0A%20%20%20%20%7D%0A%20%20%20%20previous%20%7B%0A%20%20%20%20%20%20page%0A%20%20%20%20%20%20cursor%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%7D">this link, corresponding to a page number of 4</a>.
You can adjust the arguments to see how the output changes based on where you are in the list. Try putting
different cursor values in! It looks like:</p>

<p><img src="/images/2020-01-21-graphql-relay-windowed-pagination/graphiql.png" /></p>

<p>Let’s look at a couple of other pieces of data requested here. One of these is a <code class="language-plaintext highlighter-rouge">previous</code> page cursor. This is to
support that action (the prev/next toggles) in the UI. However, we don’t need a custom <code class="language-plaintext highlighter-rouge">next</code> item to support that
behavior. That’s because we tend to use
<a href="https://facebook.github.io/relay/graphql/connections.htm#sec-Forward-pagination-arguments">forward-style pagination arguments</a>
with connections, which means the connection will already return the data needed for that action (remember, you can
implement a scrolling infinite scroll feed that always takes you to the next page right out of the box).
Specifically, the <code class="language-plaintext highlighter-rouge">hasNextPage</code> and <code class="language-plaintext highlighter-rouge">endCursor</code> are those fields from the
<a href="https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo.Fields">GraphQL <code class="language-plaintext highlighter-rouge">pageInfo</code> object</a>
which give you that information.</p>

<h2 id="companion-ui-component">Companion UI Component</h2>

<p>Ok, now that we have a connection and corresponding fields that provide the needed data, let’s take a look at a
simple React component that can render this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Page</span> <span class="o">=</span> <span class="p">({</span><span class="na">pageCursor</span><span class="p">:</span> <span class="p">{</span> <span class="nx">page</span><span class="p">,</span> <span class="nx">cursor</span> <span class="p">}})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">onClick</span><span class="p">(</span><span class="nx">cursor</span><span class="p">)}</span><span class="o">&gt;</span>
      <span class="p">{</span><span class="nx">page</span><span class="p">}</span>
    <span class="o">&lt;</span><span class="sr">/Button</span><span class="err">&gt;
</span>  <span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Show page 1 if `first` is present, and append with dots</span>
<span class="c1">// Show everything in `around`</span>
<span class="c1">// Show last page if present, and prepend with dots</span>
<span class="c1">//</span>
<span class="c1">// Show previous toggle, active if present</span>
<span class="c1">// Show next toggle, active if next page exists</span>
<span class="k">return</span> <span class="p">(</span>
  <span class="o">&lt;&gt;</span>
    <span class="p">{</span><span class="o">&lt;</span><span class="nx">Button</span> <span class="nx">disabled</span><span class="o">=</span><span class="p">{</span><span class="o">!</span><span class="nx">previous</span><span class="p">}</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">onClick</span><span class="p">(</span><span class="nx">previous</span><span class="p">.</span><span class="nx">cursor</span><span class="p">)}</span><span class="o">&gt;</span><span class="nx">Previous</span><span class="o">&lt;</span><span class="sr">/Button&gt;</span><span class="err">}
</span>    <span class="p">{</span><span class="nx">first</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">&lt;&gt;&lt;</span><span class="nx">Page</span> <span class="nx">pageCursor</span><span class="o">=</span><span class="p">{</span><span class="nx">first</span><span class="p">}</span> <span class="sr">/&gt;...&lt;/</span><span class="o">&gt;</span><span class="p">)}</span>
    <span class="p">{</span><span class="nx">around</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">page</span> <span class="o">=&gt;</span> <span class="o">&lt;</span><span class="nx">Page</span> <span class="nx">pageCursor</span><span class="o">=</span><span class="p">{</span><span class="nx">page</span><span class="p">}</span><span class="o">&gt;</span><span class="p">)}</span>
    <span class="p">{</span><span class="nx">last</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">...</span><span class="o">&lt;</span><span class="nx">Page</span> <span class="nx">pageCursor</span><span class="o">=</span><span class="p">{</span><span class="nx">last</span><span class="p">}</span> <span class="sr">/&gt;&lt;/</span><span class="o">&gt;</span><span class="p">)}</span>
    <span class="p">{</span><span class="o">&lt;</span><span class="nx">Button</span> <span class="nx">disabled</span><span class="o">=</span><span class="p">{</span><span class="o">!</span><span class="nx">hasNextPage</span><span class="p">}</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="nx">onNext</span><span class="p">()}</span><span class="o">&gt;</span><span class="nx">Next</span><span class="o">&lt;</span><span class="sr">/Button&gt;</span><span class="err">}
</span>  <span class="o">&lt;</span><span class="sr">/</span><span class="err">&gt;
</span><span class="p">)</span>
</code></pre></div></div>

<p>That’s basically it, visually speaking! The data provided by our GraphQL server is sufficient to render what’s
needed. You can see such a UI component in our design system
<a href="https://github.com/artsy/palette/blob/f882d32c3fdc6e7f81915c2922e3824bd26791e7/packages/palette/src/elements/Pagination/Pagination.tsx">here</a>.
It looks very similar to the above code. Of note, is since this is a simple UI component, it is vanilla React. It
is not a Relay component. It requires an <code class="language-plaintext highlighter-rouge">onClick</code> and <code class="language-plaintext highlighter-rouge">onNext</code> to be passed as props.</p>

<h2 id="relay-integration-step-i">Relay Integration Step I</h2>

<p>Now, let’s take a look at how we can build a Relay container that will use the above UI component. First, let’s
build a Relay-wrapped component of the above UI component. This is a fragment container, and lists all the fields
needed:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fragment</span> <span class="nx">Pagination_pageCursors</span> <span class="nx">on</span> <span class="nx">PageCursors</span> <span class="p">{</span>
  <span class="nx">around</span> <span class="p">{</span>
    <span class="nx">cursor</span>
    <span class="nx">page</span>
    <span class="nx">isCurrent</span>
  <span class="p">}</span>
  <span class="nx">first</span> <span class="p">{</span>
    <span class="nx">cursor</span>
    <span class="nx">page</span>
    <span class="nx">isCurrent</span>
  <span class="p">}</span>
  <span class="nx">last</span> <span class="p">{</span>
    <span class="nx">cursor</span>
    <span class="nx">page</span>
    <span class="nx">isCurrent</span>
  <span class="p">}</span>
  <span class="nx">previous</span> <span class="p">{</span>
    <span class="nx">cursor</span>
    <span class="nx">page</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As a fragment container, this doesn’t have the ability to fetch anything by itself. We want to pass in an <code class="language-plaintext highlighter-rouge">onClick</code>
and <code class="language-plaintext highlighter-rouge">onNext</code> prop from a parent, as well as the <code class="language-plaintext highlighter-rouge">hasNextPage</code> and <code class="language-plaintext highlighter-rouge">endCursor</code> data. Check out
<a href="https://github.com/artsy/reaction/blob/c6d630f8c3213f47c5124f63eda13fbb9d8f497b/src/Components/v2/Pagination.tsx">this component</a>
in our library to see how we take that vanilla React component mentioned above, and use the above fragment to make
a Relay fragment container out of it.</p>

<p>Now, we need to decide what kind of parent container is appropriate, and how this fragment container will be used.</p>

<h2 id="relay-integration-step-ii">Relay Integration Step II</h2>

<p>This is going to be confusing, but for this step, we use a
<a href="https://relay.dev/docs/en/refetch-container">refetch container</a> in order to present our paginated collection view,
rather than the aptly-named <a href="https://relay.dev/docs/en/pagination-container">Relay pagination container</a>. The
latter is more suited for an infinite scroll feed view (presenting all content already fetched, only adjacent pages
in a particular direction are able to be scrolled to, etc.) vs. the windowed pagination we are trying to
accomplish. The refetch container is a much more natural fit for our use case, despite the naming.</p>

<p>That fragment looks like:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fragment</span> <span class="nx">ConnectionResults_query</span> <span class="nx">on</span> <span class="nx">Query</span> <span class="p">{</span>
  <span class="nx">someConnection</span><span class="p">(</span><span class="nx">first</span><span class="p">:</span> <span class="nx">$first</span><span class="p">,</span> <span class="nx">after</span><span class="p">:</span> <span class="nx">$after</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">pageInfo</span> <span class="p">{</span>
      <span class="nx">hasNextPage</span>
      <span class="nx">endCursor</span>
    <span class="p">}</span>
    <span class="nx">pageCursors</span> <span class="p">{</span>
      <span class="p">...</span><span class="nx">Pagination_pageCursors</span>
    <span class="p">}</span>
    <span class="p">...</span><span class="nx">OtherStuffForYourView</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We include our <code class="language-plaintext highlighter-rouge">pageCursors</code> fragment, as well as the <code class="language-plaintext highlighter-rouge">hasNextPage</code> and <code class="language-plaintext highlighter-rouge">endCursor</code> from the <code class="language-plaintext highlighter-rouge">pageInfo</code> object. We
need to provide the <code class="language-plaintext highlighter-rouge">onClick</code> and <code class="language-plaintext highlighter-rouge">onNext</code> callbacks as well. Since this component will have access to a
<a href="https://relay.dev/docs/en/refetch-container#refetch"><code class="language-plaintext highlighter-rouge">relay</code> prop</a> since it is a refetch container, those look
like:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">handleNext</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">hasNextPage</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="p">(</span><span class="nx">endCursor</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">handleClick</span> <span class="o">=</span> <span class="p">(</span><span class="nx">cursor</span><span class="p">:</span> <span class="nx">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">relay</span><span class="p">.</span><span class="nx">refetch</span><span class="p">(</span>
    <span class="p">{</span>
      <span class="na">first</span><span class="p">:</span> <span class="nx">PAGE_SIZE</span><span class="p">,</span>
      <span class="na">after</span><span class="p">:</span> <span class="nx">cursor</span>
    <span class="p">},</span>
    <span class="kc">null</span><span class="p">,</span>
    <span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="cm">/* Update URL, set state, etc. */</span>
    <span class="p">}</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The refetch query defined for the container will look like:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">query</span> <span class="nx">SomeConnectionQuery</span><span class="p">(</span><span class="nx">$first</span><span class="p">:</span> <span class="nx">Int</span><span class="p">,</span> <span class="nx">$after</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span><span class="nx">ConnectionResults_query</span> <span class="p">@</span><span class="nd">arguments</span><span class="p">(</span><span class="nx">first</span><span class="p">:</span> <span class="nx">$first</span><span class="p">,</span> <span class="nx">after</span><span class="p">:</span> <span class="nx">$after</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’re pretty much done, this is all just Relay boilerplate at this point.</p>

<p>Putting it all together, our refetch container winds up rendering a fully functional pagination component in one
line:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">Pagination</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="nx">handleClick</span><span class="p">}</span> <span class="nx">onNext</span><span class="o">=</span><span class="p">{</span><span class="nx">handleNext</span><span class="p">}</span> <span class="nx">pageCursors</span><span class="o">=</span><span class="p">{</span><span class="nx">props</span><span class="p">.</span><span class="nx">pageCursors</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span></code></pre></div></div>

<p>That’s it! Any connection can have this pagination functionality added to it very simply. You include the page
cursor schema on the server for that type (we have a
<a href="https://github.com/artsy/metaphysics/blob/205592be7f59970cf80313972ceb95bb1579c31f/src/schema/v2/fields/pagination.ts#L160">factory method</a>
to help us do that automatically for any connection type). Then, following the above steps, you can quickly build a
Relay refetch container that displays and seamlessly paginates any list.</p>

<p>You can see an example of this in numerous places on the <a href="https://www.artsy.net">Artsy</a> website. Head on over to
our <a href="https://www.artsy.net/collect">Artworks browse experience</a> and have fun filtering and searching/browsing
through all accessible works! The pagination controls and functionality on this page, and others, are built using
the technique described in this post.</p>

<h2 id="examples">Examples</h2>

<p>Since our <a href="https://github.com/artsy/metaphysics">GraphQL orchestration layer</a>, our
<a href="https://github.com/artsy/palette">design system</a> and
<a href="https://github.com/artsy/reaction">UI component and app library</a> are all open source, here’s links to our actual
production implementation of the above:</p>

<ul>
  <li><a href="https://github.com/artsy/metaphysics/blob/205592be7f59970cf80313972ceb95bb1579c31f/src/schema/v2/fields/pagination.ts">Pagination schema in GraphQL</a></li>
  <li><a href="https://github.com/artsy/palette/blob/f882d32c3fdc6e7f81915c2922e3824bd26791e7/packages/palette/src/elements/Pagination/Pagination.tsx">React UI component</a></li>
  <li><a href="https://github.com/artsy/reaction/blob/c6d630f8c3213f47c5124f63eda13fbb9d8f497b/src/Components/v2/Pagination.tsx">Relay FragmentContainer wrapping of the above</a></li>
  <li><a href="https://github.com/artsy/reaction/blob/c6d630f8c3213f47c5124f63eda13fbb9d8f497b/src/Apps/Search/Routes/Artists/SearchResultsArtists.tsx">Relay RefetchContainer full example</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Better GraphQL Error Handling I - Using Custom Directives]]></title>
    <link href="https://artsy.github.io/blog/2020/01/13/graphql-custom-directives/"/>
    <updated>2020-01-13T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/01/13/graphql-custom-directives</id>
    <content type="html"><![CDATA[<p>This will be the first in a series of posts about how we used advanced GraphQL tooling and functionality to better
handle errors occurring during query resolution, and better equip clients to reason about such errors.</p>

<p>The goal is to describe our current approach, but also do a deep dive into specific ways we’ve extended our
<a href="https://github.com/artsy/metaphysics">GraphQL server</a> to help us accomplish that. If you are an interested GraphQL
user, you may find this useful, even if some of the larger context specifically around how we are using it to help
standardize error handling doesn’t apply.</p>

<!-- more -->

<h2 id="introduction-and-initial-context">Introduction and Initial Context</h2>

<p>At Artsy, we use GraphQL as our API language of choice. In particular,
<a href="https://artsy.github.io/blog/2018/05/08/is-graphql-the-future/">as</a>
<a href="https://artsy.github.io/blog/2016/06/19/graphql-for-mobile/">we’ve described</a>
<a href="https://artsy.github.io/blog/2016/11/02/improving-page-speed-with-graphql/">before</a>, we have an orchestration
layer speaking GraphQL, which is what our front-end clients talk to. The GraphQL orchestration layer wraps up
access to several backend services, which are made accessible via a combination of data loaders and
<a href="https://www.apollographql.com/docs/apollo-server/features/schema-stitching/">schema stitching</a>.
<a href="https://www.apollographql.com/docs/apollo-server/federation/introduction/">Apollo Federation</a> is another tool
people are using to bring together disparate backends when using GraphQL in an orchestration layer.</p>

<p>Now, consider the following query, which is a realistic one you might see when accessing a ‘product’ page.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nx">artwork</span><span class="p">(</span><span class="nx">id</span><span class="p">:</span> <span class="dl">"</span><span class="s2">andy-warhol-skull</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">mainContentStuff</span>
    <span class="nx">biographicalData</span>
    <span class="nx">userReviews</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>  <span class="err">#</span> <span class="nx">Accesses</span> <span class="nx">a</span> <span class="nx">back</span><span class="o">-</span><span class="nx">end</span> <span class="nx">reviews</span> <span class="nx">service</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Part of the <a href="https://graphql.github.io/graphql-spec/">GraphQL spec</a> advises that one should return a 2XX status
code, even if there are exceptions raised when resolving your query. A non-2XX status code from a GraphQL server
would indicate an error with the server itself. Errors that occur during query resolution can be consolidated and
placed in the <code class="language-plaintext highlighter-rouge">errors</code> key of the response. This is all
<a href="https://graphql.github.io/graphql-spec/draft/#sec-Errors">advised by the spec</a>, and so is found in most GraphQL
implementations.</p>

<p>Given that this query likely backs a product page, some questions about possible error handling behavior that
immediately arise:</p>

<ul>
  <li>If there are multiple fields erroring, which error (if any) is reported to the user?</li>
  <li>How does the UI decide whether an error is recoverable? That is, if the <code class="language-plaintext highlighter-rouge">mainContentStuff</code> field for a view has
errored, that’s probably not recoverable, and appropriate feedback should be displayed. But, if user reviews are
unavailable at this time, it’s likely you might still want to render the main view, but with that section
appropriately handled. Is there a generic way to handle this?</li>
</ul>

<h2 id="using-a-directive-to-eliminate-ambiguity">Using a Directive to Eliminate Ambiguity</h2>

<p>We decided to allow our UI components to declare, using a GraphQL directive, one and only one field in a query to
optionally be the ‘principal field’. That is, this is the field that, if there are any errors resolving it, should
result in an entire view rendering an appropriate error state. For web, this means a non-2XX status code and
resulting error page. Any errors occurring in field resolution of non-principal fields should still result in a 2XX
to the user, and the UI should be able to gracefully recover from the missing data. Since we use
React/Relay/GraphQL, and GraphQL queries are colocated with UI components, a GraphQL directive is particularly
useful.</p>

<p>Rewriting the above query, we might do something like:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nx">artwork</span><span class="p">(</span><span class="nx">id</span><span class="p">:</span> <span class="dl">"</span><span class="s2">andy-warhol-skull</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">mainContentStuff</span> <span class="p">@</span><span class="nd">principalField</span>
    <span class="nx">biographicalData</span>
    <span class="nx">userReviews</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>  <span class="err">#</span> <span class="nx">Accesses</span> <span class="nx">a</span> <span class="nx">back</span><span class="o">-</span><span class="nx">end</span> <span class="nx">reviews</span> <span class="nx">service</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This would mean that any errors occuring in resolving <code class="language-plaintext highlighter-rouge">mainContentStuff</code> would result in either a 500 status code
and error page to the user, or possibly a more specific error and status code. However, any errors occurring in
resolving user reviews or other fields, would not cause a 500 and error page. Instead, there would be a 200 and the
UI would render. This means that our UI components should generally be defensive about their incoming props being
<code class="language-plaintext highlighter-rouge">null</code> (which is likely what you’d see when the corresponding field errors during query resolution). Using
TypeScript and
<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html">strict null checking</a> can help
make your UI bulletproof to these sorts of issues.</p>

<p>With this context, let’s look at how we implement a custom <code class="language-plaintext highlighter-rouge">@principalField</code> GraphQL directive. Future posts in
this series talking about custom GraphQL functionality will likely skip this intro section.</p>

<h2 id="implementing-a-custom-graphql-directive">Implementing a Custom GraphQL Directive</h2>

<p>First, we have a new directive that we’d like to add to our schema. That is, we’d like a client to be able to
specify <code class="language-plaintext highlighter-rouge">@principalField</code> alongside any field, and have that query be validated correctly by the server. You can
<a href="https://metaphysics-staging.artsy.net/?query=%7B%0Aartwork(id%3A%22andy-warhol-skull%22)%20%40nonExistentDirective%7B%0A%20%20id%0A%7D%7D">see for yourself</a>
how <a href="https://github.com/graphql/graphql-js">graphql-js</a> and
<a href="https://github.com/graphql/express-graphql">express-graphql</a> respond when an unknown directive is specified. Your
GraphQL server implementation may look slightly different.</p>

<p>Turns out, that’s pretty easy to do in <code class="language-plaintext highlighter-rouge">graphql-js</code>. We declare a variable of type <code class="language-plaintext highlighter-rouge">GraphQLDirective</code>, which
operates on a <code class="language-plaintext highlighter-rouge">DirectiveLocation.FIELD</code> location:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">PrincipalFieldDirective</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">GraphQLDirective</span><span class="p">({</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">principalField</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">locations</span><span class="p">:</span> <span class="p">[</span><span class="nx">DirectiveLocation</span><span class="p">.</span><span class="nx">FIELD</span><span class="p">]</span>
<span class="p">})</span>
</code></pre></div></div>

<p>and then when we create our schema, we pass this in as <code class="language-plaintext highlighter-rouge">directives</code>. Since this will overwrite the
<a href="https://www.apollographql.com/docs/apollo-server/schema/directives/">default directives</a>, we need to append ours.</p>

<p>Something like:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">specifiedDirectives</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">graphql</span><span class="dl">"</span>

<span class="k">new</span> <span class="nx">GraphQLSchema</span><span class="p">({</span>
  <span class="na">directives</span><span class="p">:</span> <span class="p">[...</span><span class="nx">specifiedDirectives</span><span class="p">,</span> <span class="nx">PrincipalFieldDirective</span><span class="p">],</span>
  <span class="na">query</span><span class="p">:</span> <span class="p">...</span>
  <span class="p">...</span>
<span class="p">})</span>
</code></pre></div></div>

<p>In terms of the SDL for your schema, this is equivalent to the following line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>directive @principalField on FIELD
</code></pre></div></div>

<p>That’s it! You’ve successfully added a new directive to your schema. At this point, your GraphQL server will
properly validate and allow a <code class="language-plaintext highlighter-rouge">@principalField</code> directive specified by a client alongside any field. Now, we do
want to ensure that if this directive is used, it only appears once in your query. We can accomplish this with a
custom GraphQL validation, which we’ll cover in the next post.</p>

<p>So now, how should we implement the functionality of this directive? We decided that we want to use the
<a href="https://github.com/graphql/graphql-spec/blob/master/spec/Section%207%20--%20Response.md#response-format">extensions</a>
part of our GraphQL response to carry this data, a free-form map of data up to the implementor, which is a perfect
fit for this type of optional additional information. If an error occurs in a field tagged with the directive, we
want the response to look something like:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="err">...</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"extensions"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"principalField"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"error"</span><span class="p">:</span><span class="w"> </span><span class="err">...</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">express-graphql</code>, we’ll need a method appropriate for the
<a href="https://github.com/graphql/express-graphql#options">extensions</a> option. That looks like:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">principalFieldDirectiveExtension</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">documentAST</span><span class="p">,</span> <span class="nx">result</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">getPrincipalFieldDirectivePath</span><span class="p">(</span><span class="nx">documentAST</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">error</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">errors</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">e</span> <span class="o">=&gt;</span> <span class="nx">isEqual</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">path</span><span class="p">,</span> <span class="nx">path</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="p">{</span> <span class="na">principalField</span><span class="p">:</span> <span class="nx">error</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If there is a field designated with the principal field directive, and there is an error at that same path, we’ll
return that information, otherwise do nothing.</p>

<p>That’s it! We have one additional helper we need to write, <code class="language-plaintext highlighter-rouge">getPrincipalFieldDirectivePath</code>. This builds an array
of all the fields encountered to get to one tagged with our directive. It matches the way the
<a href="https://graphql.github.io/graphql-spec/June2018/#sec-Errors">path of an error</a> is constructed by the server, which
enables us to determine if a particular error was associated with a field tagged with the directive.</p>

<p>That looks like:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">visit</span><span class="p">,</span> <span class="nx">BREAK</span><span class="p">,</span> <span class="nx">DocumentNode</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">graphql</span><span class="dl">"</span>

<span class="k">export</span> <span class="kd">const</span> <span class="nx">getPrincipalFieldDirectivePath</span> <span class="o">=</span> <span class="p">(</span><span class="nx">documentNode</span><span class="p">:</span> <span class="nx">DocumentNode</span><span class="p">):</span> <span class="nx">string</span><span class="p">[]</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="na">path</span><span class="p">:</span> <span class="nx">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="nx">visit</span><span class="p">(</span><span class="nx">documentNode</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">Field</span><span class="p">:</span> <span class="p">{</span>
      <span class="nx">enter</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">alias</span> <span class="o">||</span> <span class="nx">node</span><span class="p">.</span><span class="nx">name</span><span class="p">).</span><span class="nx">value</span>
        <span class="nx">path</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
      <span class="p">},</span>
      <span class="nx">leave</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">path</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">Directive</span><span class="p">(</span><span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">name</span><span class="p">.</span><span class="nx">value</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">principalField</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">BREAK</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">})</span>

  <span class="k">return</span> <span class="nx">path</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This uses a <a href="https://graphql.org/graphql-js/language/#visit">GraphQL visitor</a> to traverse our query, and build up
an array of field names. We can exit early with that path if we encounter our directive.</p>

<h2 id="example-query">Example Query</h2>

<p>Let’s take a look at how you can use this in practice, in order to help standardize when and with what status a UI
can inform the user of an error.</p>

<p>Something like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  artwork(id: "andy-warhol-skull") @principalField {
    userReviews {
      notes
    }
    contents
    ...
  }
}
</code></pre></div></div>

<p>results in:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"artwork"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"extensions"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"principalFieldError"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"httpStatusCode"</span><span class="p">:</span><span class="w"> </span><span class="mi">404</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>and the UI can immediately return an appropriate message to the user, if the artwork is not found. If fetching the
artwork is successful, but there’s an issue with the reviews, the response will look like:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"data"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"artwork"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"userReviews"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w">
      </span><span class="nl">"contents"</span><span class="p">:</span><span class="w"> </span><span class="err">...</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>We can make sure that our UI components (likely Relay containers) corresponding to <code class="language-plaintext highlighter-rouge">userReviews</code> are defensive
about that incoming prop being <code class="language-plaintext highlighter-rouge">null</code>. Most likely a zero state (“No Reviews Found”), or just skipping the section
entirely, is appropriate.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this way, we can standardize on and remove ambiguity about how a UI handles one or more errors in query
resolution and exactly when such an error should be propagated and made user-facing. We can help ensure that our
UI’s are resilient to errors occurring in a leaf.</p>

<p>In the next post, we’ll look at how we can write a GraphQL validation rule to ensure that a client specifies at
most one field with the <code class="language-plaintext highlighter-rouge">@principalField</code> directive. After that, we’ll take a look at how you can successfully
parse and support GraphQL query resolution errors occurring in a variety of contexts such as during stitching.
Putting this altogether, we hope you will come away with a better understanding of how to extend your GraphQL
server with your own custom behaviors, and in particular how we’ve used these to better log/propagate/present the
potential errors occurring during a query.</p>
]]></content>
  </entry>
  
</feed>
