<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: graphql | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/graphql/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2018-10-06T14:40:21+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Relay Network Deep Dive]]></title>
    <link href="http://artsy.github.io/blog/2018/07/25/Relay-Networking-Deep-Dive/"/>
    <updated>2018-07-25T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/07/25/Relay-Networking-Deep-Dive</id>
    <content type="html"><![CDATA[<blockquote><p>Hey all, we have another guest post, this one comes from <a href="https://github.com/sibelius">Sibelius Seraphini</a> - a very active contributor to
Relay and its eco-system. When we spotted he had wrote an amazing article on how the networking aspects of Relay
comes together, we wanted to expand his reach and inform more people on how Relay comes together.</p>

<p>-- Orta</p></blockquote>

<p>Data fetching is a hard problem for apps. You need to ask yourself a lot of questions: How do you ask for data from
a server? How do you handle authentication? When is the right time to request data? How can you ensure you have all
the necessary data to render your views? How can you make sure you're not over-fetching? Can you do lazy loading?
When should you trigger lazy loading of data? What about pre-fetching data?</p>

<p><a href="https://facebook.github.io/relay/">Relay</a> is a framework for building data-driven applications which handles data fetching for you. For an
introduction to Relay, read <a href="https://facebook.github.io/relay/">their docs</a>, and also check out my Relay talk at <a href="https://speakerdeck.com/sibelius/reactconfbr-is-relay-modern-the-future">React Conf BR</a>.</p>

<blockquote><p>You don‚Äôt deep dive if you don‚Äôt know how to swim</p></blockquote>

<a name="TL.DR.Relay.Modern.Network"></a>
<h2>TL;DR Relay Modern Network</h2>

<p>Relay will aggregate the data requirements (fragments) for your components, then create a request to fulfill it. The
API to do this is via the <a href="https://facebook.github.io/relay/docs/en/relay-environment.html">Relay Environment</a>:</p>

<blockquote><p>The Relay "Environment" bundles together the configuration, cache storage, and network-handling that Relay needs
in order to operate.</p></blockquote>

<p>This post focuses on the "network-handling" part, the <a href="https://facebook.github.io/relay/docs/en/network-layer.html">Network Layer</a>. The network layer's responsibility
is to make a request to a server (or a local graphql) and return the response data to Relay. Your implementation
should conform to either <a href="https://github.com/facebook/relay/blob/v1.6.0/packages/relay-runtime/network/RelayNetworkTypes.js#L79-L90">FetchFunction</a> for a Promise-like API, or <a href="https://github.com/facebook/relay/blob/v1.6.0/packages/relay-runtime/network/RelayNetworkTypes.js#L92-L107">SubscribeFunction</a> for an
Observable-like API.</p>

<p>This article will provide 5 implementations of a Relay Network Interface, each of one providing more capabilities
than the other one, eventually enabling GraphQL Live Queries and Deferrable Queries.</p>

<p>You can see the code for these 5 network layers on GitHub here, open source under MIT license:
<a href="https://github.com/sibelius/relay-modern-network-deep-dive">https://github.com/sibelius/relay-modern-network-deep-dive</a>.</p>

<!-- more -->


<a name="Simplest.Network.Layer"></a>
<h3>Simplest Network Layer</h3>

<p>The simplest network layer would; get the request, send it to a GraphQL server to resolve and return the data to
Relay environment.</p>

<pre><code class="js">const fetchFunction = async (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: ?UploadableMap
) =&gt; {
  // Most GraphQL APIs expect a POST with a JSON
  // string containing the query and associated variables
  const body = JSON.stringify({
    query: request.text, // GraphQL text from input
    variables
  });

  const headers = {
    Accept: "application/json",
    "Content-type": "application/json",
    authorization: getToken()
  };

  const response = await fetchWithRetries(ENV.GRAPHQL_URL, {
    method: "POST",
    headers,
    body,
    fetchTimeout: 20000,
    retryDelays: [1000, 3000, 5000, 10000]
  });

  const data = await response.json();

  // Mutations should throw when they have errors, making it easier
  // for client code to react
  if (isMutation(request) &amp;&amp; data.errors) {
    throw data;
  }

  // We return the GraphQL response to update the Relay Environment
  // which updates internal store where relay keeps its data
  return data;
};
</code></pre>

<a name="Network.that.Handle.Uploadables"></a>
<h3>Network that Handle Uploadables</h3>

<p>The GraphQL spec does not handle form data, and so if you need to send along files to upload to your server with a
mutation, you'll want to use the uploadables API in Relay when you commit the mutation.</p>

<p>Adding uploadables in a mutation will inevitably get passed to your network interface, where you'll need to change
your request body to use FormData instead of the JSON string above:</p>

<pre><code class="js">function getRequestBodyWithUploadables(request, variables, uploadables) {
  let formData = new FormData();
  formData.append("query", request.text);
  formData.append("variables", JSON.stringify(variables));

  Object.keys(uploadables).forEach(key =&gt; {
    if (Object.prototype.hasOwnProperty.call(uploadables, key)) {
      formData.append(key, uploadables[key]);
    }
  });

  return formData;
}
</code></pre>

<a name="Network.that.Caches.Requests"></a>
<h3>Network that Caches Requests</h3>

<p>This builds on top of the other 2 implementations, we use
<a href="https://github.com/facebook/relay/blob/v1.6.0/packages/relay-runtime/network/RelayQueryResponseCache.js#L24-L29">RelayQueryResponseCache</a>
to query GraphQL requests based on query and variables.</p>

<p>Every time a mutation happens, we should invalidate our cache as we are not sure how a change can affect all cached
query responses.</p>

<pre><code class="js">// Create our own in-memory cache
const relayResponseCache = new RelayQueryResponseCache({ size: 250, ttl: oneMinute });

const cacheHandler = async (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: UploadableMap
) =&gt; {
  const queryID = request.text;

  // If it's a mutation, clear all cache, then call the implementation above
  if (isMutation(request)) {
    relayResponseCache.clear();
    return fetchFunction(request, variables, cacheConfig, uploadables);
  }

  // Try grab the request from the cache first
  const fromCache = relayResponseCache.get(queryID, variables);
  // Did it hit? Or did we suppress the cache for this request
  if (isQuery(request) &amp;&amp; fromCache !== null &amp;&amp; !forceFetch(cacheConfig)) {
    return fromCache;
  }

  // Make the request, and cache it if we get a response
  const fromServer = await fetchFunction(request, variables, cacheConfig, uploadables);
  if (fromServer) {
    relayResponseCache.set(queryID, variables, fromServer);
  }

  return fromServer;
};
</code></pre>

<a name="Network.using.Observable"></a>
<h3>Network using Observable</h3>

<p>Relay provides a limited implementation of the upcoming <a href="https://github.com/tc39/proposal-observable">ESObservables</a> spec. I recommend reading <a href="https://kriskowal.gitbooks.io/gtor/content/">A General
Theory of Reactivity</a> to understand why Observables are a great solution instead of promises in some
situations. Notably; a promise is one value in a time space, an observable is a stream of values in a time space.</p>

<!-- [TODO: Why Sink and not the Relay Observable? Observable is exported but has one more function (complete)] -->


<p>To work with this API, we're going to use a private interface for the observable object called Sink:</p>

<pre><code class="js">/**
 * A Sink is an object of methods provided by Observable during construction.
 * The methods are to be called to trigger each event. It also contains a closed
 * field to see if the resulting subscription has closed.
 */
export type Sink&lt;-T&gt; = {|
  +next: T =&gt; void,
  +error: (Error, isUncaughtThrownError?: boolean) =&gt; void,
  +complete: () =&gt; void,
  +closed: boolean
|};
</code></pre>

<p>Which is the shape of the Observable object we pass back to Relay:</p>

<pre><code class="js">const fetchFunction = async (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: ?UploadableMap,
  sink: Sink&lt;any&gt;
) =&gt; {
  const body = getRequestBody(request, variables, uploadables);

  const headers = {
    ...getHeaders(uploadables),
    authorization: getToken()
  };

  const response = await fetchWithRetries(ENV.GRAPHQL_URL, {
    method: "POST",
    headers,
    body,
    fetchTimeout: 20000,
    retryDelays: [1000, 3000, 5000, 10000]
  });

  const data = await handleData(response);

  if (isMutation(request) &amp;&amp; data.errors) {
    sink.error(data);
    sink.complete();

    return;
  }

  sink.next(data);
  sink.complete();
};

// Instead of returning a Promise that will resolve a single GraphQL response.
// We return an Observable that could fulfill many responses before it finishes.

const executeFunction = (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: ?UploadableMap
) =&gt; {
  return Observable.create(sink =&gt; {
    fetchFunction(request, variables, cacheConfig, uploadables, sink);
  });
};
</code></pre>

<p>This is an implementation you would need when working with <a href="https://github.com/facebook/relay/issues/2174">GraphQL Live Queries</a> (based on polling), as you
are going to resolve the same query more than once.</p>

<a name="Deferrable.Queries.Network"></a>
<h3>Deferrable Queries Network</h3>

<p>A common case for deferrable queries is to lazy load fragments. This lets you get request content above the page
fold first, and then request additional data after. A good example is loading a Post's content first and then
subsequently loading all comments of this post after the post has finished.</p>

<p>Without deferrable queries you could simulate this using the <a href="https://facebook.github.io/relay/docs/en/graphql-in-relay.html#directives">@include</a> directive in your Relay fragment
and a <a href="https://facebook.github.io/relay/docs/en/refetch-container.html">refetch container</a>. When the component mounts the refetch container changes the variable used on the
<code>@include</code> to true and it will request the rest of the data.</p>

<p>The problem with above approach is that you need to wait for the component to mount before you can start the next
request. This becomes a bigger problem as React does more work asynchronously.</p>

<!-- TODO: There are no docs for relay deferrable -->


<p>An ideal deferrable query will start as soon as the previous query has finished, rather than depending on your React
components render cycles. Relay provides a <a href="https://github.com/facebook/relay/issues/2194#issuecomment-383466255">directive</a> for this: <code>@relay(deferrable: true)</code>:</p>

<pre><code class="js">const PostFragment = createFragmentContainer(Post, {
  post: graphql`
    fragment Post_post on Post {
      title
      commentsCount
      ...CommentsList_post @relay(deferrable: true)
    }
  `
});
</code></pre>

<p>In the fragment above, Relay will first get the <code>title</code> and <code>commentsCount</code> from the Post, then afterwards Relay
will get the data for <code>CommentsList_post</code> fragment. Sending both through the observable.</p>

<p>Here is the implementation of an execute function to handle a batched request:</p>

<pre><code class="js">const executeFunction = (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: ?UploadableMap
) =&gt; {
  return Observable.create(sink =&gt; {
    if (request.kind === "Request") {
      cacheHandler(request, variables, cacheConfig, uploadables, sink, true);
    }

    if (request.kind === "BatchRequest") {
      batchRequestQuery(request, variables, cacheConfig, uploadables, sink);
    }
  });
};
</code></pre>

<p>This execute function now can handle 2 types of requests:</p>

<ul>
<li>a single GraphQL query <code>Request</code></li>
<li>or a <code>BatchRequest</code> that could have be many queries with inter-related data</li>
</ul>


<p>So, what does the <code>batchRequestQuery</code> function look like?</p>

<!-- TODO: Annotate ths code, I'm not 100% what it's doing myself -->


<pre><code class="js">// Get variables from the results that have already been sent
const getDeferrableVariables = (requests, request, variables: Variables) =&gt; {
  const { argumentDependencies } = request;

  if (argumentDependencies.length === 0) {
    return variables;
  }

  return argumentDependencies.reduce((acc, ad) =&gt; {
    const { response } = requests[ad.fromRequestName];

    const variable = get(response.data, ad.fromRequestPath);

    // TODO - handle ifList, ifNull
    // See: https://github.com/facebook/relay/issues/2194
    return {
      ...acc,
      [ad.name]: variable
    };
  }, {});
};

// Execute each of the requests, and call `sink.next()` as soon as it has the GraphQL
/// server response data.
//
// It will only close the Observable stream when all requests has been fulfilled.
const batchRequestQuery = async (
  request: RequestNode,
  variables: Variables,
  cacheConfig: CacheConfig,
  uploadables: ?UploadableMap,
  sink: Sink&lt;ExecutePayload&gt;
) =&gt; {
  const requests = {};

  for (const r of request.requests) {
    const v = getDeferrableVariables(requests, r, variables);

    const response = await cacheHandler(r, v, cacheConfig, uploadables, sink, false);

    requests[r.name] = response;
  }

  sink.complete();
};
</code></pre>

<a name="Relay.Modern.is.very.flexible"></a>
<h2>Relay Modern is very flexible</h2>

<p>Depending on your application needs, you can scale from a simpler Promise-based API for your custom network layer to
one that uses Observables to always resolves from cache data first and then resolves from the server.</p>

<p>Here are some production examples:</p>

<ul>
<li><p><a href="https://github.com/artsy/emission/blob/master/src/lib/relay/fetchQuery.ts">Artsy Emission</a>: Uses the Promise API, caches the results locally, and shares logic with native code in an
iOS app so that queries can be pre-cached before the JavaScript runtime has started.</p></li>
<li><p><a href="https://github.com/relay-tools/react-relay-network-modern">ReactRelayNetworkModern</a>: A network layer that uses the middleware pattern to separate responsibilities like
retrying, logging, caching and auth.</p></li>
<li><p><a href="https://github.com/facebook/relay/issues/2174#issuecomment-375274003">timobetina's example</a>: The simplest Observable network layer you can start with.</p></li>
</ul>


<!-- TODO: More, @sibelius do you have some good examples? -->


<a name="More.Resources"></a>
<h2>More Resources</h2>

<p>If you want to expand your understanding of GraphQL and Relay Modern, I have two great related resources:</p>

<ul>
<li><p>A boilerplate that uses dataloader to batch and cache requests to your database in a GraphQL API:
<a href="https://github.com/entria/graphql-dataloader-boilerplate">https://github.com/entria/graphql-dataloader-boilerplate</a></p></li>
<li><p>A simple boilerplate for working with Relay Modern and React Navigation:
<a href="https://github.com/entria/ReactNavigationRelayModern">https://github.com/entria/ReactNavigationRelayModern</a></p></li>
</ul>


<p>If you have questions about this or anything send me a DM on twitter <a href="https://twitter.com/sseraphini">https://twitter.com/sseraphini</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Is GraphQL The Future?]]></title>
    <link href="http://artsy.github.io/blog/2018/05/08/is-graphql-the-future/"/>
    <updated>2018-05-08T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/05/08/is-graphql-the-future</id>
    <content type="html"><![CDATA[<p>I have seen the future, and it looks a lot like GraphQL. Mark my words: in 5
years, newly minted full-stack app developers won‚Äôt be debating <em>RESTfulness</em>
anymore, because REST API design will be obsolete. By the end of this post, I
hope you'll see what I see in the promise of GraphQL as a new approach to
client-server interaction.</p>

<!-- more -->


<p>GraphQL is taking the full-stack world by storm. In case you‚Äôre not familiar,
GraphQL is a language-independent specification for client-server communication.
It lets you model the resources and processes provided by a server as a
<a href="https://en.wikipedia.org/wiki/Domain-specific_language">domain-specific language (DSL)</a>.
Clients can use it to send scripts written in your DSL to the server to process
and respond to as a batch.</p>

<p>That‚Äôs...different from how GraphQL‚Äôs own page describes it. GraphQL is better
known as a query language designed for clients to fetch exactly the data they
need. While this is sort of true, I would argue that GraphQL actually fails this
test in reality. It‚Äôs neither a query language, nor particularly graph-oriented.
I argue that it's <em>not</em> a query language because it comes with no native
concepts of operators and expressions that build up to queries. <em>You</em> build
whatever facilities for specifying and fulfilling queries on your own. Likewise,
if your data is a graph, it‚Äôs on you to expose that structure. But your requests
are, if anything, trees.</p>

<p>I‚Äôm not trying to be pedantic. I believe GraphQL succeeds at something subtler
and more important than literally being a graph query language. I‚Äôm writing this
piece because I kept running into difficulties approaching GraphQL from the
standpoints of REST, graph theory, or typical query languages. As I read blog
posts, StackOverflow Q&amp;As, issues on the GraphQL repo and the GraphQL spec
itself, I developed a much more nuanced understanding, which I outline below.</p>

<p>For brevity, the following assumes a intermediate familiarity with GraphQL,
including its type system, syntax, and server-side implementation. If you don‚Äôt
have this level of familiarity, I recommend going through any tutorial that
requires you to set up a GraphQL server, not just play with the query language
(which is how I ended up with a lot of misconceptions).
<a href="https://graphql.org/graphql-js/">The docs for the official JavaScript server library</a>
are a good option. I‚Äôm going to start with the basics, but only so I can put my
own spin on those concepts, not to really illustrate them with examples.</p>

<a name="A.tree.of.fetches"></a>
<h1>A tree of fetches</h1>

<p>Most applications are designed in the form of discrete pages, which are seeded
with some tiny chunk of data‚Äîsay, a key or slug for some domain object‚Äîand then
perform a cascade of contingent fetches to get the data needed to populate the
templates rendered to a user. This is the basis of designing applications driven
by URL-based routing and it has been a mainstay of the MVC approach to web
application architecture for the past decade.</p>

<blockquote><p><strong>Example:</strong> At Artsy, the seed of data for rendering an artwork page could be
the slug identifying some artwork. From this slug, we need a whole bunch more
data: the metadata of the artwork, information about the artist(s), sales data
if it‚Äôs available for purchase, information about the Artsy partner that owns
it, and so on. In classic REST, this data is aggregated by a cascade of dozens
of HTTP fetches to our backend API.</p></blockquote>

<p>I wasn‚Äôt in the room when GraphQL was invented, but it seems to me that the team
that built it made a particularly crucial insight:</p>

<blockquote><p>In most cases, all of this contingent fetching forms a tree, which is more or
less <em>fixed</em> for a given page.</p></blockquote>

<p>Data from early responses contain the keys for subsequent requests, but the
linkages between these requests are usually straightforward. So if it were
possible to factor all this disparate fetching into one spot and encode it into
one big ‚Äúfetching tree‚Äù data structure ahead of time, this tree could be sent to
the the server, and the server could fulfill all of the data requirements in one
shot. This cuts out a tremendous amount of wasteful chatter between client and
server. Even in today's broadband world, bandwidth and latency matter,
especially for mobile users.</p>

<a name="GraphQL.anatomy"></a>
<h1>GraphQL anatomy</h1>

<blockquote><p><strong>Editorial note</strong> I'm going to use the term "operation" pretty liberally
here, but I mean it in the conceptual sense, not in the sense of the GraphQL
spec, where it defines the semantics of an entire GraphQL request.</p></blockquote>

<p>A GraphQL request always starts with at least <em>one root API operation</em> and some
finite number of follow-ups. Idiomatically, these follow-ups are queries,
meaning that they just retrieve data, without changing the server state in
observable ways. GraphQL models API operations as <strong>fields</strong>. How a field works
in GraphQL depends on its <strong>type</strong>, which falls into one of two basic
categories:</p>

<ul>
<li><strong>Scalar</strong> types (<code>Int</code>, <code>Float</code>, <code>String</code>, <code>Boolean</code>, and <code>ID</code>, as well as
application-defined <code>enum</code> and <code>scalar</code> types) represent the individual pieces
of <em>data actually sent to the client</em>. Contrary how I think of the term scalar
in other contexts, the data can be arbitrarily complex. As far as the GraphQL
spec is concerned, scalars are just opaque blobs of data with validation and
serialization rules. As an operation, a scalar field is terminal data fetch,
with no follow-ups. They are the leaves of the request tree.</li>
<li><strong>Object</strong> types (<code>type</code>, <code>union</code> and <code>interface</code>) are collections of fields.
As an operation, an object-typed field is an intermediate operation that
serves as the junction point for follow-up operations. But, it doesn‚Äôt
directly return any data. They are the branches of the request tree.</li>
</ul>


<p>The entire model for a given API is known as its <strong>schema</strong>. Every schema has a
root query type, whose fields serve as the API‚Äôs entry points.</p>

<pre><code># The root query object type
type Query {
  artwork(id: ID): Artwork
  artist(name: String)
  # ‚Ä¶ a whole bunch more root fields
}

type Artwork {
  title: String
  artist: Artist
}

type Artist {
  name: String
}
</code></pre>

<p>A GraphQL query request begins by mentioning at least one of the fields of the
root query object. This represents an initial query. And if that field is an
object, <em>its</em> fields are used to specify any number of follow-up queries.
Critically, <em>any</em> field in the request tree can take arguments, allowing a
request to be parameterized at all depths.</p>

<p>Take this query, for example:</p>

<pre><code>{
  artwork(id: "andy-warhol-campbells-soup-i-black-bean") {
    title
    artist {
      name
    }
  }
}
</code></pre>

<p>Here, we tell the server to look up an <code>Artwork</code> by its slug, and tell us the
title. So far, this is just like REST. But we <em>also</em> tell it to find us the
<code>Artist</code> for us. Importantly, object fields <em>must</em> be followed up with further
queries, and scalar fields <em>cannot</em> be. With that in mind, it‚Äôs easy to see that
<code>artwork</code> and <code>artist</code> are object fields, while <code>title</code> and <code>name</code> are scalar
fields.</p>

<p>Also note that the fact that there‚Äôs also an <code>artist</code> root query field actually
has nothing to do with its presence under <code>Artwork</code>. There can be multiple paths
to reach the same GraphQL type. This is defined explicitly by the schema.</p>

<p>Usefully, the server‚Äôs response to a GraphQL request will directly mirror the
shape of the request itself. The result of the request above looks like:</p>

<pre><code>{
  "data": {
    "artwork": {
      "title": "Campbell's Soup I: Black Bean",
      "artist": {
        "name": "Andy Warhol"
      }
    }
  }
}
</code></pre>

<a name="GraphQL.as.a..meta-.scripting.language"></a>
<h1>GraphQL as a (meta-)scripting language</h1>

<p>Let‚Äôs dig a little deeper into the scripting language interpretation of GraphQL,
because this is the crux of how I think people should think of GraphQL. If I
were to guess, I think Facebook‚Ä¶</p>

<ul>
<li>‚Ä¶knows this is true. After all, much of the spec is devoted to
<a href="http://facebook.github.io/graphql/October2016/#sec-Execution">the execution model of GraphQL</a>.</li>
<li>‚Ä¶might have backed into this design. It‚Äôs well known that they think of their
data as a graph, so I suspect GraphQL might have begun literally as a "graph
query language", analogous to <a href="https://en.wikipedia.org/wiki/SQL">SQL</a> for
relational databases.</li>
<li>‚Ä¶thinks that this too difficult to explain, and thus, settled on the query
language paradigm.</li>
</ul>


<p>There are a couple reasons GraphQL might not look like a scripting language to
you. It didn‚Äôt to me, at first! After all, you don't write your request as list
of statements. It doesn‚Äôt have a concept of variables, other than parameters to
the whole document. There are no looping constructs or recursion. But I think a
closer look might shift your perspective.</p>

<a name="Control.flow"></a>
<h2>Control flow</h2>

<p>It‚Äôs true that a GraphQL request doesn‚Äôt follow the same vertical sequence of
steps model familiar to most programming languages. But sequencing <em>does</em> exist.
It‚Äôs just represented by calling nested fields of object types, terminating in a
scalar field. See this request:</p>

<pre><code>{
  step1(arg: ‚Äúsomething‚Äù) {
    step2 {
      step3(arg: "something else‚Äù) {
        outputScalar
      }
    }
  }
</code></pre>

<p>In a more traditional language, this would look more like:</p>

<pre><code>step1(‚Äúsomething‚Äù)
step2()
return step3(‚Äúsomething else‚Äù)
</code></pre>

<p>So, sequencing got a bit more verbose, but it <em>is</em> there.</p>

<p>Interestingly, GraphQL reserves vertical stacking for something that‚Äôs an
afterthought in most languages: <em>concurrency</em>. (Granted, there‚Äôs no way to
<a href="https://en.wikipedia.org/wiki/Synchronization_(computer_science)">synchronize</a>
concurrent paths of execution.) I‚Äôm not going to quote
<a href="https://facebook.github.io/graphql/October2016/">the spec</a>, but search it
yourself, and you can find the word ‚Äúparallel‚Äù in there several times. This
design is intentional.</p>

<a name="Variables"></a>
<h2>Variables</h2>

<p>One of the core aspects of programming is the ability to pass intermediate data
around. The most basic way languages accomplish this is with named variables.
Many languages allow variables to be reassigned; some don't. GraphQL doesn‚Äôt
have them at all! But that doesn‚Äôt mean data can‚Äôt be propagated.</p>

<p>GraphQL supports one kind of propagation, which is the propagation of context
down the sequence of resolvers. It happens implicitly and invisibly. Exactly
what data is propagated and what that means is up to you.</p>

<p>How does this work? Well, if you have worked on GraphQL server code, you know
that every field has a <strong>resolver</strong>.</p>

<ul>
<li>For scalar fields, the resolver is responsible for returning the actual data
that the client sees.</li>
<li>For object fields, the resolver instead returns a hidden chunk of data that is
forwarded along to the resolvers of the fields contained in the object. So
these resolvers get their parent object‚Äôs hidden data, the global context, and
any arguments, and they can use all of these values to produce their value.</li>
</ul>


<p>Often, we just resolve an object field to a domain object. Its scalar fields
might correspond to properties of that domain object and its object fields might
correspond to related objects. But the architecture is more powerful than this!
A deeply nested field can potentially be the result of the resolved values of
all its parents. It all depends on how you design your resolvers to work
together.</p>

<p>This pattern reminds me a bit of when <a href="https://api.jquery.com/">jQuery</a> first
clicked for me. A lot of details are propagated invisibly within your <code>jquery</code>
object as you chain method calls to refine your DOM selections.</p>

<a name="Looping.and.recursion"></a>
<h2>Looping and recursion</h2>

<p>GraphQL doesn‚Äôt have them, plain and simple. Consequently, the GraphQL DSLs you
design are not
<a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing-complete</a>--they will
always halt in a finite amount of steps. This is really important, because it
prevents clients from being able to send servers on errands that will never end.
Of course, the <em>implementations</em> of field resolvers on the server are free to do
whatever they want in full Turing-complete glory.</p>

<a name="Putting.it.together"></a>
<h2>Putting it together</h2>

<p>My point here is that the execution model of GraphQL is in many ways just like a
scripting language interpreter. The limitations of its model are strategic, to
keep the technology focused on client-server interaction. What's interesting is
that you as a developer provide nearly all of the definition of what operations
exist, what they mean, and how they compose. For this reason, I consider GraphQL
to be a <em>meta-scripting language</em>, or, in other words, a toolkit for building
scripting languages.</p>

<a name="The.post-REST.world"></a>
<h1>The post-REST world</h1>

<p>Subtly, this paradigm is a sharp step away from a whole body of knowledge that
models APIs as resources with fixed verbs, which we know as REST. It‚Äôs more
appropriate to think of GraphQL requests as a script of remote procedure calls
(RPC). From this perspective, the design of the schema is a lot less about data
modeling than it is a question of how you want your entire API to be traversed.
This encourages a verb-oriented mindset.</p>

<a name="Verb.orientation"></a>
<h2>Verb orientation</h2>

<p>Speaking of verbs, you can think of "fetch" as being the default verb in
GraphQL. You model other verbs as <strong>mutations</strong>. I delayed learning about
mutations, because I thought they must be way more complex than queries. Quite
the opposite! They all sit in one big, flat bucket at the root of your schema,
as the fields of the root <code>mutation</code> type. These fields have a type too, and if
it is an object type, then you can issue effectively any number of follow-up
queries after your mutation completes. Learning about mutations was when it
really dawned on me that <em>fields are just function calls</em>.</p>

<p>Mutations are a major break with REST. In GraphQL, your mutations are defined
under root mutation object that is separate from your root query object.
Therefore, you are immediately asked to accept that they don't represent verbs
on a resource, but verbs <em>on your entire service</em>. This eliminates one of REST‚Äôs
key weak points, namely that complex operations that touch multiple parts of an
application‚Äôs data model are difficult to model as a PUT, DELETE, POST, or PATCH
on a single resource. In my experience, this "impedance mismatch‚Äù between API
modeling and domain modeling has led to the worst aspects of my HTTP API
designs.</p>

<a name="REST.is.dead..Long.live.REST."></a>
<h2>REST is dead. Long live REST!</h2>

<p>It is borderline heresy in some circles to suggest that REST API design is dead.
But I‚Äôm saying it. Don‚Äôt get me wrong, REST is still a great paradigm for
serving static assets. It‚Äôs the <em>API</em> part I have an issue with.</p>

<p>Ironically, I think there‚Äôs a strong argument that a GraphQL request document
maps very nicely to the concept of a resource:</p>

<ul>
<li>It doesn‚Äôt change that often, and you could PUT it to store it, perhaps using
a hash of the request document to form the URL.</li>
<li>GraphQL queries map elegantly to GET operations on a stored query request
document‚Äôs URL.</li>
<li>GraphQL mutations map decently to POST operations to a stored mutation request
document‚Äôs URL.</li>
<li>The arguments of a GraphQL request map elegantly to HTTP query parameters.</li>
</ul>


<p>In other words, GraphQL is simply another formalization layer of HTTP-based API
design. Think of it as being akin to the way JSON representation changed the way
we think about client-server communication in full-stack apps. It‚Äôs not so much
that REST will cease to exist, but that it will fade to the background, as an
implementation detail of GraphQL application frameworks.</p>

<a name="GraphQL.is.not.your.data.model"></a>
<h1>GraphQL is not your data model</h1>

<p>Another realization I‚Äôve had in learning to apply GraphQL is that the schema is
<em>not</em> the actual data model, and therefore raw GraphQL responses cannot be
directly used by the client. You <em>could</em> choose to think of it this way, but
you‚Äôre likely to run into some conundrums:</p>

<ul>
<li><a href="https://github.com/facebook/graphql/issues/101">There is no free-form map data structure</a>.
There are only objects with fixed fields, scalars, and lists.</li>
<li>It is difficult to design abstractions over types.</li>
<li>The object tree you get in return from a query request is neither normalized
nor is it an object graph (multiple copies of the same object may be
returned).</li>
<li>Commonly used protocol patterns, like
<a href="https://facebook.github.io/relay/docs/graphql-connections.html">the connection pattern</a>,
require explicit modeling within your schema.</li>
<li>The limitations of GraphQL's type system make certain modeling techniques
difficult to directly model, such as
<a href="https://stackoverflow.com/questions/47933512/representing-enum-object-variant-type-in-graphql">singletons within unions</a>.</li>
<li>Recursive data types can‚Äôt be queried to undefined depth in their nested form.
Think of your comment board with nested replies.</li>
</ul>


<p>The upshot of this is that there likely needs to be some process of conversion
from your native data model on your server to your GraphQL API, and then again
from your client‚Äôs API consumption code to its internal data model.
<a href="https://facebook.github.io/relay/">Relay</a> and
<a href="https://www.apollographql.com/client">Apollo</a> serve this purpose. Their utility
wasn‚Äôt immediately clear to me when I naively imagined GraphQL to literally be a
system for reproducing a slice of server-side object graph. (Hmm, where might I
have gotten that impression from?)</p>

<p>A lot of discussion in the GraphQL space centers on data modeling‚Äîthe nouns.
There‚Äôs a lot of debate and worthwhile work to be done on that front, but one of
my primary reasons for writing this piece is to think about the verbs. What
happens when you think of GraphQL requests as not just verbs, but <em>chains</em> of
verbs? My inkling is that you start to be able to represent services in a much
more fluid way. Complex processes no longer have to be orchestrated by API
clients or hidden behind unwieldy black-box POST endpoints. Instead, clients can
compose processes from the easily inspectable building blocks that the server
provides via its GraphQL schema. That‚Äôs a whole different approach to API
design.</p>

<a name="So..where.to.now."></a>
<h1>So, where to now?</h1>

<p>I began by asserting that the future looks a lot <em>like</em> GraphQL. But I did not
say that GraphQL <em>is the future</em>. I hedge because there are a lot of unanswered
questions and some pain points within today‚Äôs GraphQL, even as it paints a
compelling picture of the future. I may write a follow-up piece bringing up some
of these gripes. At the moment, Facebook still largely controls the development
of the technology and it has been slow to evolve. Arguably, this is a good
thing, as the full-stack community continues to digest the basic concepts. But
I‚Äôm sure impatient folks will attempt forks or create parallel technologies. How
it all balances out is anybody‚Äôs guess.</p>

<p>Nonetheless, today‚Äôs GraphQL is already a tremendous leap forward from REST API
design. It much more directly models the sort of data traversals a client needs
to perform in order to do its job. I expect significant refinement within this
space over the next couple years. And after a couple more, the days before
GraphQL will be just another source of lore for grizzled vets like us.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Relay Mutations]]></title>
    <link href="http://artsy.github.io/blog/2017/04/26/Relay-Mutations/"/>
    <updated>2017-04-26T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/04/26/Relay-Mutations</id>
    <content type="html"><![CDATA[<blockquote><p>Hey there everyone, it took us two years to <a href="https://github.com/artsy/metaphysics/pull/583">make our</a> GraphQL implementation support any mutations. We opted to keep it read-only for quite a long time because we use GraphQL to consolidate multiple APIs, but as we start new projects as GraphQL + databases then understanding mutations becomes much more important.</p>

<p>Last month, I talked with the team at <a href="https://www.graph.cool/">Graph.cool</a> about having them talk through Relay mutations comprehensively as a guest post on the Artsy Engineering blog. So, I'm really excited to introduce this great post on the topic by <a href="http://twitter.com/nikolasburk">Nikolas Burk</a>.</p>

<p>-- Orta</p></blockquote>

<a name="The.Magic.behind.Relay.Mutations"></a>
<h1>The Magic behind Relay Mutations</h1>

<p><a href="https://facebook.github.io/relay/">Relay</a> is a powerful GraphQL client for React and React Native applications. It was open sourced by Facebook alongside GraphQL in 2015 and is a great tool for supporting you with managing your app's data layer.</p>

<p>In this post, we are going to explore how Relay mutations work by looking at a React Native app. The code can be found on <a href="https://github.com/graphcool-examples/react-native-relay-pokedex-example">GitHub</a>. Our sample application is a simple <em>Pokedex</em>, where users can manage their Pokemons.</p>

<p><img src="http://i.imgur.com/S21GfEo.png" alt="" /></p>

<blockquote><p>Note: We're going to assume a basic familiarity with GraphQL in this article. If you haven't heard of GraphQL before, the <a href="www.graphql.org">documentation</a> and the <a href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile/">GraphQL for iOS Developers</a> post are great places to start. If you're interested in learning more about Relay in general, head over to <a href="www.learnrelay.org">Learn Relay</a> for a comprehensive tutorial.</p></blockquote>

<!-- more -->


<p>If you want to run the example with your own GraphQL server, you can use <a href="https://www.graph.cool/graphql-up/">graphql-up</a> to quickly spin one up yourself from within your browser. Simply click the pink button and follow the instructions on the website.</p>

<p><a href="https://www.graph.cool/graphql-up/new?source=https://raw.githubusercontent.com/graphcool-examples/react-native-relay-pokedex-example/master/pokedex.schema"><img src="http://static.graph.cool/images/graphql-up.svg" alt="graphql-up" /></a></p>

<a name="Relay.-.A.brief.Overview"></a>
<h2>Relay - A brief Overview</h2>

<p>Relay is the most sophisticated GraphQL client available at the moment. Like GraphQL, it has been used and battle-tested internally by Facebook for many years before it was open sourced.</p>

<p>Relay surely isn't the easiest framework to learn - but when used correctly, it takes care of managing large parts of your app's data layer in a consistent and reliable manner! It therefore is particularly well-suited for complex applications with lots of data interdependencies and provides outstanding longterm developer productivity.</p>

<a name="Declarative.API.and.Colocation"></a>
<h3>Declarative API and Colocation</h3>

<p>With Relay, React components specify their data requirements in a declarative fashion, making use of GraphQL <em>fragments</em>.</p>

<blockquote><p>A <a href="https://learngraphql.com/basics/fragments">GraphQL fragment</a> is a selection of fields on a GraphQL type. You can use them to define <em>reusable sub-parts</em> of queries or mutations.</p></blockquote>

<p>Considering the <code>PokemonDetails</code> view above, we need to display the Pokemon's name and image. The fragment that represents these data requirements looks as follows:</p>

<pre><code>fragment PokemonDetails on Node {
  ... on Pokemon {
    id
    name
    url
  }
}
</code></pre>

<p>Note that the <code>id</code> is required so that Relay can identify the objects in the cache, so it's included in the payload as well (even if it's not displayed on the UI).</p>

<p>These fragments are kept in the same file as the React component, so UI and data requirements are <em>colocated</em>. Relay then uses a <a href="https://facebook.github.io/react/docs/higher-order-components.html">higher-order component</a> called <a href="https://facebook.github.io/relay/docs/guides-containers.html#content"><code>Relay.Container</code></a>, to wrap the component along with its data requirements. From this point, the developer doesn't have to worry about the data any more! It will be fetched behind the scenes and is made available to the component via its props.</p>

<a name="Build-time.Schema.Validation"></a>
<h3>Build-time Schema Validation</h3>

<p>Another great feature of Relay that ensures developer productivity is  <em>schema validation</em>. At build time, Relay checks your GraphQL queries, fragments and mutations to ensure their compatibility with the GraphQL API. It is thus able to catch any typos or other schema-related errors before you run (or even worse: deploy) your app, saving your users from unpleasant experiences. Note that the schema validation step requires a <a href="https://facebook.github.io/relay/docs/guides-babel-plugin.html">Babel Relay Plugin</a>.</p>

<a name="Mutations.in.Relay"></a>
<h2>Mutations in Relay</h2>

<a name="GraphQL.Recap"></a>
<h3>GraphQL Recap</h3>

<p>In GraphQL, a <em>mutation</em> is the only way to create, update or delete data on the server - they effectively are the GraphQL abstraction for <em>changing state</em> in your backend.</p>

<p>As an example, creating a new Pokemon in our sample app uses the following mutation:</p>

<pre><code>mutation CreatePokemon($name: String!, $url: String!) {
  createPokemon(input: {
    name: $name,
    url: $url
  }) {
    # payload of the mutation (will be returned by the server)
    pokemon {
      id 
    }
  }
}
</code></pre>

<p>Notice that mutations, similar to queries, also require a <em>payload</em> to be specified. This payload represents the information that we'd like to have returned from the server after the mutation was performed. In the above example, we're asking for the <code>id</code> of the new <code>pokemon</code>.</p>

<a name="The.Magic:.Declarative.Mutations....."></a>
<h3>The Magic: Declarative Mutations üîÆ</h3>

<p>Relay doesn't (yet) give the developer the ability to manually modify the data that it stores internally. Instead, with every change, it requires a declarative <em>description</em> of how the local cache should be updated after the change happened in the form of a <a href="https://facebook.github.io/relay/docs/guides-mutations.html#content">mutation</a> and then takes care of the update under the hood.</p>

<p>The description is provided by subclassing <code>Relay.Mutation</code> and implementing (at least) four methods that help Relay to properly update the local store:</p>

<ul>
<li><code>getMutation()</code>: the name of the mutation (from the GraphQL schema)</li>
<li><code>getVariables()</code>: the input variables for the mutation</li>
<li><code>getFatQuery()</code>: a GraphQL query that fetches all data that potentially was changed due to the mutation</li>
<li><code>getConfigs()</code>: a precise specification how the mutation should be incorporated into the cache</li>
</ul>


<p>In the following, we'll take a deeper look at the different kinds of mutations in our sample app, which are used for creating, updating and deleting Pokemons.</p>

<blockquote><p>Note: We're using the <a href="https://www.graph.cool/docs/reference/relay-api/overview-aizoong9ah">Graphcool Relay API</a> for this example. If you used <code>graphql-up</code> to create your own backend, you can explore the API by pasting the endpoint for the Relay API into the address bar of a browser.</p></blockquote>

<a name="Creating.a.new.Pokemon:..code.RANGE_ADD..code."></a>
<h3>Creating a new Pokemon: <code>RANGE_ADD</code></h3>

<p><img src="http://i.imgur.com/yskx5KU.png" alt="" /></p>

<p>Let's walk through the different methods and understand what information we have to provide so that Relay can successfully merge the newly created Pokemon into its store.</p>

<p>The first two methods, <code>getMutation()</code> and <code>getVariables()</code> are relatively obvious and can be retrieved directly from the documentation where the API is described.</p>

<p>The implementations look as follows:</p>

<pre><code class="js">getMutation() {
  return Relay.QL`mutation { createPokemon }`
}

getVariables() {
  return {
    name: this.props.name,
    url: this.props.url,
  }
}
</code></pre>

<p>Notice that the <code>props</code> of a <code>Relay.Mutation</code> are passed through its constructor. Here, we simply provide the <code>name</code> and the <code>url</code> of the Pokemon that is to be created.</p>

<p>Now, on to the interesting parts. In <code>getFatQuery()</code>, we need to specify the parts that might change due to the mutation. Here, we simply specify the <code>viewer</code>:</p>

<pre><code class="js">getFatQuery() {
  return Relay.QL`
    fragment on CreatePokemonPayload {
      viewer {
        allPokemons
      }
    }
  `
}
</code></pre>

<p>Notice that <em>every</em> subfield of <code>allPokemons</code> is also automatically included with this approach. In our example app, <code>allPokemons</code> is the only point we expect to change after our mutation is performed.</p>

<p>Finally, in <code>getConfigs()</code>, we need to specify the <a href="https://facebook.github.io/relay/docs/guides-mutations.html#mutator-configuration">mutator configurations</a>, telling Relay exactly how the new data should be incorporated into the cache. This is where the magic happens:</p>

<pre><code class="js">getConfigs() {
  return [{
    type: 'RANGE_ADD',
    parentName: 'viewer',
    parentID: this.props.viewerId,
    connectionName: 'allPokemons',
    edgeName: 'edge',
    rangeBehaviors: {
      '': 'append'
    }
  }]
}
</code></pre>

<p>We first express that we want to <em>add</em> the node using <code>RANGE_ADD</code> for the <code>type</code> (there are 5 different types in total).</p>

<p>Relay internally represents the stored data as a graph, so the remaining information expresses where exactly the new node should be hooked into the existing structure.</p>

<p>Let's consider the shape of the data before we move on:</p>

<pre><code>viewer {
  allPokemons {
    edges {
      node {
        id
        name
      }
    }
  }
}
</code></pre>

<p>Here we clearly see the direct connection between <code>viewer</code> and the Pokemons goes through <code>allPokemons</code> <em>connection</em>, so the <em>parent</em> of the new Pokemon is the <code>viewer</code>. The name of that connection is <code>allPokemons</code>, and lastly the <code>edgeName</code> is taken from the payload of the mutation.</p>

<p>The last piece, <code>rangeBehaviors</code>, specifies whether we want to <em>append</em> or <em>prepend</em> the new node.</p>

<p>Executing the mutation is as simple as calling <code>commitUpdate</code> on the <code>relay</code> prop that's injected to each component being wrapped with a <code>Relay.Container</code>. An instance of the mutation and the expected variables are passed as arguments to the constructor:</p>

<pre><code class="js">_sendCreatePokemonMutation = () =&gt; {
  const createPokemonMutation = new CreatePokemonMutation({
    viewerId: this.props.viewer.id,
    name: this.state.pokemonName,
    url: this.state.pokemonUrl,
  })
  this.props.relay.commitUpdate(createPokemonMutation)
}
</code></pre>

<a name="Updating.a.Pokemon:..code.FIELDS_CHANGE..code."></a>
<h3>Updating a Pokemon: <code>FIELDS_CHANGE</code></h3>

<p>Like with creating a Pokemon, <code>getMutation()</code> and <code>getVariables()</code> are trivial to implement and can be derived directly from the API documentation:</p>

<pre><code class="js">getMutation() {
  return Relay.QL`mutation { updatePokemon }`
}

getVariables() {
  return {
    id: this.props.id,
    name: this.props.name,
    url: this.props.url,
  }
}
</code></pre>

<p>In <code>getFatQuery()</code>, we only include the <code>pokemon</code> which includes the updated info this time, since that is the only part we expect to change after our mutation:</p>

<pre><code class="js">getFatQuery() {
  return Relay.QL`
    fragment on UpdatePokemonPayload {
      pokemon
    }
  `
}
</code></pre>

<p>Finally, <code>getConfigs()</code>, this time specifies a mutator configuration of type <code>FIELDS_CHANGE</code> since we're only updating properties on a single Pokemon:</p>

<pre><code class="js">getConfigs() {
  return [{
    type: 'FIELDS_CHANGE',
    fieldIDs: {
      pokemon: this.props.id,
    }
  }]
}
</code></pre>

<p>As sole additional piece of info, we declare the ID of the Pokemon that is being updated so that Relay has this information available when receiving the new Pokemon data.</p>

<a name="Deleting.a.Pokemon:..code.NODE_DELETE..code."></a>
<h3>Deleting a Pokemon: <code>NODE_DELETE</code></h3>

<p>As before, <code>getMutation()</code> and <code>getVariables()</code> are self-explanatory:</p>

<pre><code class="js">getMutation() {
  return Relay.QL`mutation { deletePokemon }`
}

getVariables() {
  return {
    id: this.props.id,
  }
}
</code></pre>

<p>Then, in <code>getFatQuery()</code>, we need to retrieve the <code>pokemon</code> from the mutation payload:</p>

<pre><code class="js">getFatQuery() {
  return Relay.QL`
    fragment on DeletePokemonPayload {
      pokemon
    }
  `
}
</code></pre>

<p>In <code>getConfigs()</code>, we're getting to know another mutator configuration type called <code>NODE_DELETE</code>. This one requires a <code>parentName</code> as well as a <code>connectionName</code>, both coming from the mutation payload and specifying where that node existed in Relay's data graph. Another requirement, that is specifically relevant for the implementation of a GraphQL server, is that the mutation payload of a deleting mutation always needs to return the <code>id</code> of the deleted node so that Relay can find that node in its store. Taking all of this together, our implementation of <code>getConfigs()</code> can be written like so:</p>

<pre><code class="js">getConfigs() {
  return [{
    type: 'NODE_DELETE',
    parentName: 'pokemon',
    connectionName: 'edge',
    deletedIDFieldName: 'deletedId'
  }]
}
</code></pre>

<a name="Wrapping.Up"></a>
<h2>Wrapping Up</h2>

<p>Relay has a lot of benefits that make it a very compelling framework to use for state management and interaction with GraphQL APIs. Its major strengths are a highly optimized cache, thoughtful UI integration as well as the declarative API for data fetching and mutations.</p>

<p>The initial version of Relay came with a notable learning curve due to lots of magic happening behind the scenes. However, Facebook recently released the first release candidates of <a href="https://github.com/facebook/relay/releases/">Relay v1.0.0</a> (<em>Relay Modern</em>) with the <a href="https://code.facebook.com/posts/1362748677097871">goal of making Relay generally more approachable</a>.</p>

<p>It's worth noting that Relay isn't the only available GraphQL client. Apollo Client is a great alternative which is a lot easier to get started with. <a href="https://www.graph.cool/docs/tutorials/relay-vs-apollo-iechu0shia/">For a detailed comparison please refer to this article.</a></p>

<p>If you want to learn more about GraphQL and want to stay up-to-date with the latest news of the GraphQL community, subscribe to <a href="https://graphqlweekly.com/">GraphQL Weekly</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Improving Page Speed with GraphQL]]></title>
    <link href="http://artsy.github.io/blog/2016/11/02/improving-page-speed-with-graphql/"/>
    <updated>2016-11-02T14:21:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/11/02/improving-page-speed-with-graphql</id>
    <content type="html"><![CDATA[<p>This past year, our team started using a GraphQL orchestration layer that connects various APIs with multiple front-end apps including <a href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile">iOS</a>. It also handles caching and extracts some business logic out of our client apps. This helped us not only to be more consistent with the way we fetch data across apps, but also improved developer happiness and even bridged teams by having our web and iOS developers work with the same API layer. This got me thinking what other problems GraphQL could solve at Artsy.</p>

<p>I work on the Publishing Team at Artsy, and we've recently been focused on page speed as a KPI. With so many ways of measuring speed, it's a daunting task but for this post, I'll focus on the way we handled things on the server-side and how integrating GraphQL on our API improved page speed.</p>

<!-- more -->


<a name="Prior.to.GraphQL"></a>
<h2>Prior to GraphQL</h2>

<p>In our publishing CMS called <a href="http://github.com/artsy/positron">Positron</a>, we serve a separate API, database, and front-end from the rest of the Artsy stack. We're also responsible for the delivery and presentation of the content itself. Over the past year we've focused a lot on how the content appears, and now we've opened up time to focus on speed since in the land of content, every second counts.</p>

<p>Before we went ahead with adding a GraphQL-based endpoint to Positron, I spent about a week and refactoring our current codebase. We refactored our router code to make less fetches, made better use of caching, and moved some below-the-fold rendering into the client side. These are important steps towards a faster page, but it doesn't push our technology in a direction that lets us reimagine things.</p>

<a name="Speed.Issues"></a>
<h2>Speed Issues</h2>

<p>We split the speed problem in two: <code>Server Response Time</code> (server-side) and <code>Document Interactive Time</code> (client-side). We currently use Google Analytics to track these <a href="https://support.google.com/analytics/answer/2383341?hl=en">metrics</a>. There are some inaccuracies with GA such as small sampling, geographic noise (countries with different download speeds), and timeouts being counted as zero, but for our initial testing this will suffice for relative measuring.</p>

<a name="Enter.GraphQL.and.JoiQL"></a>
<h2>Enter GraphQL and JoiQL</h2>

<p>Our very own <a href="https://twitter.com/craigspaeth">Craig Spaeth</a> recently started working on a project called <a href="https://github.com/muraljs/mural">Mural</a>. It's a framework for React and GraphQL. One library that came out of this project is called <a href="http://github.com/muraljs/joiql">JoiQL</a>. It's a The main purpose of JoiQL is to convert <a href="http://github.com/hapijs/joi">Joi</a> schemas into GraphQL schemas.</p>

<p>We already use Joi in Positron so creating a GraphQL-based endpoint was trivial with JoiQL. Note that while JoiQL is currently used in production, it's still a beta project! Below is an example of how the JoiQL setup works.</p>

<pre><code class="javascript">const joiql = require('../')
const { object, string, number, array, date } = require('joi')
const app = require('express')()
const graphqlHTTP = require('express-graphql')

// Given a Joi schema:
const Article = object({
  title: string(),
  body: string(),
  published_at: date()
}).meta({
  args: { id: number().required() }
})

// Define api with JoiQL like this:
const api = joiql({
  query: {
    article: Article
  }
})

// Resolve the request using a Koa 2 style middleware pattern:
api.use((ctx, next) =&gt; {
  return new Promise (resolve, reject) -&gt;
    // Method that fetches an article based on the query
    findArticle(ctx.req.query.article.args), (err, results) -&gt;
      ctx.res.article = results.article
      next()
      resolve()
})

// Finally, mount our schema to express:
app.use('/graphql', graphqlHTTP({
  schema: api.schema,
  graphiql: true
}))
app.listen(3000, () =&gt; console.log('listening on 3000'))
</code></pre>

<p>You can see how simple it becomes to convert apps that already use Joi with JoiQL. Joi provides a nice API for building GraphQL schemas with minimal boilerplate and we also get a nice Koa 2 style middleware pattern that lets us hook into a downstream/upstream flow. This downstream/upstream flow could be useful later on if we were to get really granular with measuring speed. For instance, if we decide to track the speed of the whole lifecycle of a request, we could do something like this:</p>

<pre><code class="javascript">api.use((ctx, next) =&gt; {
  startTIme = Date.now()
  next()
  console.log(Date.now() - startTime)
}

api.use((ctx, next) =&gt; {
  // fetch content here
  next() #we get bumped back up after this
})
</code></pre>

<a name="Results"></a>
<h2>Results</h2>

<p>The two features of GraphQL that have been helpful for reducing page speed are:
1. Reduced payload because you only request the data you need
2. Multiple fetches can be coalesced into a single request</p>

<p>Not surprisingly, decreased payload and coalesced requests are the same two features <a href="http://twitter.com/orta">Orta</a> describes in part of his post on the killer features of <a href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile">GraphQL for Mobile</a>.</p>

<a name="Reduced.Payload"></a>
<h3>Reduced Payload</h3>

<p>Reduced payload turned out to be one of the biggest factors in reducing speed. Just after October 27 we switched over to using GraphQL on our <a href="http://m.artsy.net/articles">mobile articles landing page</a>.</p>

<p></div></div><a href='/images/2016-11-02-improving-page-speed-with-graphql/download_time.png'><img src="/images/2016-11-02-improving-page-speed-with-graphql/download_time.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>Since we were previously getting back collection of articles with all of its content, rendering a simple page with a list of articles meant the payload size was unnecessarily huge. Now, we only request a few things like the title and image without having to do any extra work. This is especially important for mobile devices where we encounter slow network speeds!</p>

<a name="Multiple.fetches"></a>
<h3>Multiple fetches</h3>

<p>Although we haven't made use of this in production yet, I anticipate that the ability to coalesce requests will be significant. For example, to render an article page, there are up to five fetches that can be requested by our front-end app with a normal REST API. Now, we can combine the requests to a single fetch, which moves the responsibility of coalescing requests from aggregating slow HTTP requests to fanning out fast database queries. If we aggregate the request and cache the response using a client like <a href="https://github.com/kadirahq/lokka">Lokka</a>, our future looks bright.</p>

<a name="What.s.next."></a>
<h2>What's next?</h2>

<p>Besides making use of this new endpoint on all the things, I think the next big win with GraphQL is to add <a href="http://graphql.org/learn/queries/#mutations">mutations</a>. By adding support for mutations, we can modify our data with GraphQL just as simply as we can query it.</p>

<p>We currently use a combination of Backbone and React to edit articles on our front-end CMS. After we move our CMS's data platform to GraphQL, we can move away from frameworks like Backbone and towards managing state containers like Redux which are made to work with GraphQL. Features like revision history and undo events would feel natural with state containers like Redux and a joy for our editors!</p>

<p>In the context of speed, some other topics I look forward to exploring are optimizing expensive database queries and client-side asset compression.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GraphQL for iOS Developers]]></title>
    <link href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile/"/>
    <updated>2016-06-19T12:09:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/06/19/graphql-for-mobile</id>
    <content type="html"><![CDATA[<p>GraphQL is something you may have heard in passing, usually from the web team. It's a Facebook API technology, that describes itself as a <em>A Data Query Language and Runtime</em>. GraphQL is a <a href="http://facebook.github.io/graphql/">spec</a>, and there are <a href="https://github.com/chentsulin/awesome-graphql#libraries">multiple implementations</a> of it. As mobile engineers, we can consider it an API, where the front-end team have as much control as the backend.</p>

<p>This blog post covers our usage of GraphQL, and what I've learned in the last 3 months of using it in <a href="https://github.com/artsy/eigen/">Eigen</a>.</p>

<!-- more -->


<a name="So.what.is.GraphQL"></a>
<h3>So what is GraphQL</h3>

<p>You can get the full explanation on <a href="http://graphql.org">the GraphQL website</a>. Though, I found running through <a href="https://learngraphql.com">Learn GraphQL</a> site to really hammer down how it works. Reading the <a href="https://facebook.github.io/react/blog/2015/05/01/graphql-introduction.html">introduction blog post</a> can be useful too.</p>

<p>We use GraphQL as an API middle-layer. It acts as an intermediate layer between multiple front-end clients and multiple back-end APIs. This means it can easily coalesce many API calls into a single request, this can be a <em>massive</em> user experience improvement when you have a screen that requires information from varied sources before you can present anything to a user.</p>

<p><img src="/images/2016-06-19-graphql-for-iOS-devs/graphQL.svg" width=100%></p>

<p>As a client, you <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Networking/ARRouter.m#L1011">send</a> a "<a href="http://graphql.org/docs/getting-started/#queries">JSON-shaped query</a>" structure, which is hierarchical and easy to read:</p>

<pre><code class="json">{
  artwork(id: "kimber-berry-as-close-to-magic-as-you-can-get") {
    id
    additional_information

    is_price_hidden
    is_inquireable
  }
}
</code></pre>

<blockquote><p>This will search for a <a href="https://www.artsy.net/artwork/kimber-berry-as-close-to-magic-as-you-can-get">specific artwork</a>, sending back the Artwork's <code>id</code>, <code>additional_information</code>, <code>is_price_hidden</code> and <code>is_inquireable</code>.</p></blockquote>

<p>It's important to note here, the data being sent <em>back</em> is only what you ask for. This is not defined on the server as a <em>short</em> or <em>embedded</em> version of a model, but the specific data the client requested. When bandwidth and speed is crucial, this is the other way in which GraphQL improves the app-user experience.</p>

<p>That's the two killer features:</p>

<ol>
<li>Coalesce Multiple Network Requests. Reducing the amount of network requests that need to be made.</li>
<li>Only Send The Data You Want. Only sending the data you are interested in.</li>
</ol>


<p>With mobile apps you're working with unreliable, slow networks with high bandwidth costs. Optimising towards less networking with richer data means your app is more resiliant to things outside of your control.</p>

<p>This is in stark contrast to existing API concepts, like <a href="http://stateless.co/hal_specification.html">HAL</a> and <a href="http://jsonapi.org">JSON-API</a> - both of which are optimised for caching, and rely on "one model, one request" types of API access. E.g. a list of Artworks would actually contain a list of hrefs instead of the model data, and you have to fetch each model as a separate request.</p>

<a name="Using.GraphQL"></a>
<h3>Using GraphQL</h3>

<p>Artsy's GraphQL server is (unsurprisingly) open-source, it's at <a href="https://github.com/artsy/metaphysics">artsy/metaphysics</a>. However, it's not publicly accessible, (<a href="https://github.com/artsy/metaphysics/issues/279">yet?</a>). One of the coolest things about developing against a GraphQL server is GraphiQL - an IDE for exploring your API. I can't show you ours, but I can send you to <a href="http://clayallsopp.com">Clay Allsop's</a> <a href="https://www.graphqlhub.com">GraphQLHub</a>:</p>

<p><a href="https://www.graphqlhub.com/playground?query=%23%20Hit%20the%20Play%20button%20above!%0A%23%20Hit%20%22Docs%22%20on%20the%20right%20to%20explore%20the%20API%0A%0A%7B%0A%20%20graphQLHub%0A%20%09reddit%20%7B%0A%20%20%20%20user(username%3A%20%22orta%22)%20%7B%0A%20%20%20%20%20%20username%0A%20%20%20%20%20%20commentKarma%0A%20%20%20%20%20%20createdISO%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20subreddit(name%3A%20%22swift%22)%7B%0A%20%20%20%20%20%20newListings(limit%3A%202)%20%7B%0A%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20comments%20%7B%0A%20%20%20%20%20%20%20%20%20%20body%0A%20%20%20%20%20%20%20%20%20%20author%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20username%0A%20%20%20%20%20%20%20%20%20%20%09commentKarma%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D">Here</a> ( I strongly recommend pausing to open that link in a new window. Press cmd + enter to see the results. We also have an example of refactoring that request <a href="https://www.graphqlhub.com/playground?query=%23%20Hit%20the%20Play%20button%20above!%0A%23%20Hit%20%22Docs%22%20on%20the%20right%20to%20explore%20the%20API%0A%0A%7B%0A%20%20graphQLHub%0A%20%09reddit%20%7B%0A%20%20%20%20user(username%3A%20%22orta%22)%20%7B%0A%09%09%09...userFields%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20subreddit(name%3A%20%22swift%22)%20%7B%0A%20%20%20%20%20%20newListings(limit%3A%202)%20%7B%0A%20%20%20%20%20%20%20%20title%0A%20%20%20%20%20%20%20%20comments%20%7B%0A%20%20%20%20%20%20%20%20%20%20body%0A%20%20%20%20%20%20%20%20%20%20author%20%7B%20%0A%09%09%09%20%20%20%20%20%20...userFields%0A%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%7D%0A%7D%0A%0Afragment%20userFields%20on%20RedditUser%20%7B%0A%20%20username%0A%20%20commentKarma%0A%20%20createdISO%0A%7D">here</a>. )</p>

<p>GraphQL comes with a playground for the API! It's amazing! Clay called it the <a href="https://medium.com/the-graphqlhub/graphiql-graphql-s-killer-app-9896242b2125#.6ht6374bq">"Killer App" of GraphQL</a> - I'm inclined to concur. I've never had API docs this useful. This is built on top of the schema/docs/type reflection APIs inside the GraphQL spec.</p>

<p></article>
<a href='/images/2016-06-19-graphql-for-iOS-devs/graphiql.png' style="">
  <img src="/images/2016-06-19-graphql-for-iOS-devs/graphiql.png" alt="" style="width:100%;">
</a>
<article class="post">
</p>

<a name="How.GraphQL.Changed.How.We.Write.Native.Code"></a>
<h3>How GraphQL Changed How We Write Native Code</h3>

<a name="View.Models"></a>
<h4>View Models</h4>

<p>Our GraphQL server is owned by the <a href="http://artsy.github.io/blog/2016/03/28/artsy-engineering-organization-stack/">web-practice</a> and the mobile practice also help out occasionally. This ownership distinction is important, an API like this would normally be handled by our platform team.</p>

<p>Because of Metaphysics' ownership as a "front-end" product, it can contain additional information that is specific to front-end needs. For example, in our first example of a request to our GraphQL server we requested <code>id</code>, <code>additional_information</code>, <code>is_price_hidden</code> and <code>is_inquireable</code> - only two of these items come from the database. Both is <code>is_price_hidden</code> and <code>is_inquireable</code> are derived from the API results on the server.</p>

<p>This is <em>awesome</em>, because before a <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Views/Artwork/ARArtworkActionsView.m#L310-L362">lot of this logic</a> existed in a <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Views/Artwork/ARArtworkActionsView.m#L108-L109">Google Doc</a> which needed to be re-implemented in 3-4 clients. On the native side we would find we were out-of-date mid-release cycle and needed to rush to catch up.</p>

<p>So, what does this mean for view models? It lessens the need for them. If you can move a lot of your derived data to the server - this handles the logic that goes in a view model for you. Now it is provided server-side, and is consistent across platforms.</p>

<p>We've not stopped writing view models, but now discussions on them includes "should this move to Metaphysics?".</p>

<a name="React.Native"></a>
<h4>React Native</h4>

<p>We've already <a href="https://twitter.com/orta/status/734880605322776576">shipped one full view controller</a> in <a href="https://facebook.github.io/react-native/">React Native</a> for our flagship app, <a href="https://github.com/artsy/eigen/">Eigen</a>. The advantages that came from GraphQL were a big part of the discussion around using React Native.</p>

<p>There will be longer articles on the "why" and "how" we choose to work this way. However, the key thing that we're excited about in using React Native is Relay. Using Relay, our <a href="https://github.com/artsy/emission/tree/2ac6e9fc0f85ca81483bcbd6c841841104f07833/lib/components/artist">views</a> can declare a fragment of the GraphQL query that each respective <a href="https://github.com/artsy/emission/blob/2ac6e9fc0f85ca81483bcbd6c841841104f07833/lib/components/artist/biography.js#L60-L69">view needs</a>.</p>

<p>So, in our Artist View Controller, the Biography "View" (<a href="https://facebook.github.io/react-native/docs/native-components-ios.html">component</a>) declares "when I am in the view hierarchy, you need to grab a <code>bio</code>, and <code>blurb</code>"</p>

<pre><code class="js">export default Relay.createContainer(Biography, {
  fragments: {
    artist: () =&gt; Relay.QL`
      fragment on Artist {
        bio
        blurb
      }
    `,
  }
});
</code></pre>

<p>Once your views are declaring what data they need, and are acting on that data - you see less of a need to use models.</p>

<hr />

<p>GraphQL is having a massive impact in the way that we write our apps. It means we can make much faster mobile apps, as the network is our critical path. Faster apps means happier users, happier users means happier developers. I want to be happy. So I'm thankful that the <a href="https://github.com/artsy/metaphysics/graphs/contributors">Web practice</a> gave GraphQL a try, and <a href="https://github.com/artsy/metaphysics/pull/243">welcome'd</a> <a href="https://github.com/artsy/metaphysics/pull/313">us</a> <a href="https://github.com/artsy/metaphysics/pull/226">to</a> <a href="https://github.com/artsy/metaphysics/pull/302">the</a> <a href="https://github.com/artsy/metaphysics/issues/2">party</a>.</p>
]]></content>
  </entry>
  
</feed>
