<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: engineering | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/engineering/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2024-05-17T14:49:02+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A Year in Review: 2021]]></title>
    <link href="https://artsy.github.io/blog/2022/01/06/a-year-in-review-2021/"/>
    <updated>2022-01-06T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2022/01/06/a-year-in-review-2021</id>
    <content type="html"><![CDATA[<p>Ufff, 2021 was a tough year. It was the second year of the Covid-19 pandemic. We tried our best to support each
other through these challenging times and in that spirit, we feel like it‚Äôs important not to lose sight of our
accomplishments. As we say goodbye to 2021 and hello to 2022, here are some Artsy Engineering wins from this past year.</p>

<p>What did you ship in 2021? We would love to hear about it and celebrate with you!</p>

<!-- more -->

<ul>
  <li>Recorded and released 42 episodes of the <a href="https://www.buzzsprout.com/1781859">Artsy Engineering Radio</a></li>
  <li>Onboarded 23 engineers in Berlin, Germany</li>
  <li>Leveraged our investment in React Native to launch the <a href="https://play.google.com/store/apps/details?id=net.artsy.app">Artsy Android App</a></li>
  <li>We <a href="https://github.com/pulls?q=is%3Apr+user%3Aartsy+created%3A%3E%3D2021-01-01+-created%3A%3E%3D2022-01-01">opened</a> 13,368 pull requests! 12,054 were <a href="https://github.com/pulls?q=is%3Apr+user%3Aartsy+created%3A%3E%3D2021-01-01+-created%3A%3E%3D2022-01-01+is%3Amerged+merged%3A%3C%3D2021-12-31">merged</a> and 1,050 were <a href="https://github.com/pulls?q=is%3Apr+user%3Aartsy+created%3A%3E%3D2021-01-01+-created%3A%3E%3D2022-01-01+is%3Aclosed+is%3Aunmerged">closed</a>. (note: includes contributions in private repositories)</li>
  <li>Responded to and resolved 29 incidents</li>
  <li>Collaborated with <a href="https://www.itechart.com">iTechArt</a> engineers on impactful projects</li>
  <li>Migrated more repositories to deploy continuously</li>
  <li>Significantly improved <a href="https://web.dev/vitals">Core Web Vitals</a> across our web surfaces</li>
  <li>Answered a bunch of questions in our #dev-help Slack channel to help <a href="https://youtu.be/3XscuivvUzI">get each other unstuck</a>!</li>
  <li>After many false starts, we finally agreed to pull the trigger on a full auction bidding engine rewrite</li>
  <li>More stable end-to-end automated testing tooling (codenamed ‚Äúintegrity‚Äù)</li>
  <li>Worked with <a href="https://www.applause.com">Applause</a> to help us with external QA for our mobile apps</li>
  <li>Bootstrapped a new data engineering team</li>
  <li>Launched our a new recommendation model (codenamed ‚Äúaffinity score‚Äù)</li>
  <li>Developed an in-house auction results pipeline</li>
  <li>Launched improvements to our recommendations (New Works for You) for the first time in a while!</li>
  <li>Launched integrations with <a href="https://arta.io">Arta</a> (shipping), <a href="https://www.avalara.com">Avalara</a> (tax compliance), <a href="https://algolia.com">Algolia</a> (search), <a href="https://www.adjust.com">Adjust</a> (analytics), <a href="https://www.braze.com">Braze</a> (marketing), and <a href="https://postie.com">Postie</a> (marketing).</li>
  <li>Moved 38+ of <a href="https://github.com/artsy/force">Force</a> (artsy.net) apps to a new and improved V2 setup</li>
  <li>Rebuilt our design system <a href="https://github.com/artsy/palette">Palette</a>, updated its documentation, and migrated many web and mobile surfaces to the new look</li>
  <li>Rebuilt our artwork inquiry flow! Finally!</li>
  <li>Migrated to a new marketing email service provider without incident (described as a project ‚Äúi wouldn‚Äôt wish on my worst enemy‚Äù)</li>
  <li>Added Make Offer support for artwork inquiries</li>
  <li>Hired our first agile coach!</li>
  <li>Tech leads are taking more ownership over the success of their teams</li>
  <li>Moved a bunch of projects off of Heroku and onto our Kubernetes infrastructure</li>
  <li>Invested in an improved turn-key set-up for new folks</li>
  <li>Integrated our API with more third-party art management systems like <a href="https://www.artbase.com">ArtBase</a> and <a href="https://www.applause.com">Artsystems</a></li>
  <li>Spun up a trial integration with <a href="https://www.split.io">Split</a> (experimentation and feature flagging vendor)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Strategies For Small, Focused Pull Requests]]></title>
    <link href="https://artsy.github.io/blog/2021/03/09/strategies-for-small-focused-pull-requests/"/>
    <updated>2021-03-09T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2021/03/09/strategies-for-small-focused-pull-requests</id>
    <content type="html"><![CDATA[<p>A common suggestion for improving pull requests (PRs) is to ‚Äúmake your PR small and focused‚Äù. I myself gave this suggestion in <a href="https://artsy.github.io/blog/2020/08/11/improve-pull-requests-by-including-valuable-context/">a recent article on this very blog about including context in PRs</a>.</p>

<p>Like most internet advice, this can feel like the <a href="https://knowyourmeme.com/memes/how-to-draw-an-owl">‚Äúdraw the rest of the owl‚Äù</a> meme. Even if we‚Äôre in agreement that I <em>should</em> make a PR smaller‚Ä¶<strong><em>how</em></strong> do I do it? How do I avoid a big PR when there‚Äôs a lot of cross-cutting changes to make? How do I create small, focused units of work when I‚Äôm building a large feature? How can I overcome my perfectionism and submit a PR that feels incomplete to me because the edges aren‚Äôt all polished?</p>

<!-- more -->

<h2 id="what-is-small-and-focused">What is ‚Äúsmall and focused‚Äù?</h2>

<p>Not all small PRs are focused. I might sneak five unrelated one-line changes into a PR. While it feels like that will enable me to move quickly, it also runs the risk of four unrelated changes being held up in review because the other is controversial.</p>

<p>Not all focused PRs are small. I might put an entire feature in one PR, and while it is focused, it‚Äôs still going to be difficult for you to review the large amount of changes thoroughly.</p>

<p>To make our PR reviewers‚Äô jobs easier, we‚Äôre looking for the intersection of small <em>and</em> focused. Changes that are cohesive and without distractions. Code that accomplishes one small thing.</p>

<p>Note that the recommendation for ‚Äúsmall and focused‚Äù PRs does <strong>not</strong> include the word ‚Äúcomplete‚Äù. I‚Äôm a perfectionist and I like my work to be very polished before it‚Äôs done, but when we‚Äôre iterating quickly the polish can come in a follow-up PR. This is the biggest challenge I‚Äôve had as an Artsy engineer ‚Äî finding the balance between polish and iteration. Artsy‚Äôs core values include <a href="https://github.com/artsy/README/blob/ccfbba13ead7cb6586d2d9bf088e5180907be07b/culture/what-is-artsy.md#impact-over-perfection">Impact Over Perfection</a> but my personal values include ‚Äúmake things <em>real good</em>‚Äù and it can be hard for me to navigate that tension.</p>

<h3 id="integrating-code-a-little-at-a-time">Integrating code a little at a time</h3>

<p>A caveat: the recommendations in this article assume you can integrate code a little bit at a time. I‚Äôve worked on teams and projects where we used very long-lived branches for features or even epic ‚Äî I know those environments exist. This article is probably not the one that will convince you to move to <a href="https://trunkbaseddevelopment.com/">trunk-based development</a>; it also might be less useful without trunk-based development.</p>

<p>Having said that, even with long-lived feature branches you can introduce code <em>into those branches</em> a little bit at a time. PRs can be opened against <em>any</em> branch, not just <code class="language-plaintext highlighter-rouge">main</code>.</p>

<p>A couple strategies we use at Artsy for integrating code a little bit at a time:</p>

<ul>
  <li><strong><a href="https://trunkbaseddevelopment.com/feature-flags/">Feature toggles</a></strong>. <a href="https://artsy.github.io/blog/2020/12/31/echo-supporting-old-app-versions/">Ash wrote about Echo</a>, a service for toggling features on mobile devices, but we have additional ways for enabling/disabling features at the system <em>or</em> user level. When we introduce new code we can hide it behind a feature flag until we‚Äôre ready for everyone to see it.</li>
  <li><strong>‚ÄúHidden‚Äù routes</strong>. Often when we redesign or modernize an existing route on Artsy.net we‚Äôll create a <em>second</em> similar route. We hide the in-progress page behind that new route and don‚Äôt share it until it‚Äôs ready. ü§´</li>
</ul>

<p>Armed with tools for integrating code incrementally, here are some strategies for reducing the size and scope of a PR. I‚Äôm not suggesting you use these strategies universally, but if you think you‚Äôre headed toward a very large PR, these are some things to try.</p>

<h2 id="start-with-small-scope--slice-your-stories-small">Start with small scope ‚Äî slice your stories small</h2>

<p>One of the most valuable lessons I learned as a consultant with a company focused on agile development is that you can almost always slice a story smaller. You can do this by sacrificing quality, but you can also (and probably should) do it by cutting scope. We can ship a new screen for our app sooner if we focus on building the most absolutely critical features first, and follow up with the valuable-but-not-critical features later.</p>

<p>There are many ways to break a story smaller, and all of them enable you to integrate code sooner in the form of smaller PRs:</p>

<ul>
  <li>Separate CRUD (Create, Read, Update, Delete) operations and ship them one at a time</li>
  <li>Separate by user role</li>
  <li>Separate individual edge cases</li>
  <li>Separate a simplified experience from an enhanced version</li>
</ul>

<p>Think of these smaller scoped features as self-contained vertical slices of functionality. As each one is released, users can take advantage of them, and your team can start building the next slice.</p>

<h2 id="pr-by-architectural-layer">PR by architectural layer</h2>

<p>Rather than building an entire feature end-to-end before creating a pull request, consider integrating one layer at a time. Embrace the boundaries between the front and back ends of your code ‚Äî submit a PR to introduce changes to the API, and once it‚Äôs merged follow up with another PR to introduce changes to the UI.</p>

<p>Depending on the architecture of your system, you might already be forced to this. At Artsy, our <a href="https://github.com/artsy/force">web app lives in one repo</a>, our <a href="https://github.com/artsy/metaphysics">GraphQL endpoint lives in another</a>, and many services are separated into repositories behind that. We <em>must</em> integrate our features one layer at a time. Here‚Äôs an example where <a href="https://artsy.github.io/author/matt/">Matt</a> <a href="https://github.com/artsy/metaphysics/pull/2819/files">added a field to our API</a> in one PR, and <a href="https://github.com/artsy/force/pull/6613">propagated it to the UI</a> in a separate PR. Even if you don‚Äôt have a repository boundary between your API and your UI, splitting PRs at this logical boundary can help make them more digestible.</p>

<p>The suggestion to PR by architectural layer is not in conflict with slicing stories small ‚Äî in fact, these two strategies complement each other nicely. A PR that contains multiple features but only one layer is probably large enough to be difficult to review; so is a PR that contains one feature end-to-end. A PR containing one layer of one feature can be easier to review.</p>

<h2 id="build-a-walking-skeleton">Build a walking skeleton</h2>

<p>A <a href="walking-skeleton">walking skeleton</a> is a bare-bones, stripped down implementation of your feature from end-to-end. It connects the UI all the way to the data source. Very little of the feature is presented, but what is there is fully functional.</p>

<p>Start a new feature with a walking skeleton PR to demonstrate connectivity of the pieces involved. It won‚Äôt do very much ‚Äî maybe it only displays one field ‚Äî but that‚Äôs okay because no one‚Äôs going to see it yet. The important thing is that the moving pieces are all connected ‚Äî the database, the API, the UI.</p>

<p>Once a walking skeleton PR is merged, you can start filling in the skeleton. Each new sub-feature can be its own PR.</p>

<p>This is a great approach if your team is looking to swarm on a feature. If we all work on our own sub-features without first merging a walking skeleton, we‚Äôre likely to face some intense merge conflict headaches when we realize we‚Äôve all connected the full stack in slightly different ways. Starting with a walking skeleton removes a lot of those merge conflicts, because we‚Äôre mostly bolting fields on to existing infrastructure along the way.</p>

<p><a href="https://github.com/artsy/relay-workshop/pull/1">This PR</a> is an example of a walking skeleton. My goal was to stand up an app that connected <a href="https://reactjs.org/">React</a>, <a href="https://relay.dev/">Relay</a>, and <a href="https://www.typescriptlang.org/">TypeScript</a>. <a href="https://github.com/artsy/relay-workshop/pull/1/files#diff-26ad4b834941d9b19ebf9db8082bd202aaf72ea0ddea85f5a8a0cb3c729cc6f2R25">The actual app doesn‚Äôt display very much</a> ‚Äî just enough to prove that the pieces were all working.</p>

<h2 id="separate-riskycontroversial-work-from-routine-work">Separate risky/controversial work from routine work</h2>

<p>It‚Äôs not always possible to identify ahead of time which work will prompt more discussion during review, but sometimes it‚Äôs obvious. Novel work that takes thoughtful consideration of multiple approaches is much more likely to invite feedback than work that follows existing patterns.</p>

<p>Routine implementation can be a noisy distraction in a PR that also contains a unique function that you really want reviewers to see. You should point out the unique bits in the PR body if they‚Äôre combined, but you also might consider separating the less-interesting implementation into its own PR.</p>

<p>The worst review you can get on a PR that contains both novel and routine work is ‚ÄúLGTM!‚Äù (looks good to me). It likely means the reviewer couldn‚Äôt separate the signal from the noise and overlooked the bits that required more thought and effort.</p>

<h2 id="separate-infrastructural-work-from-implementations">Separate infrastructural work from implementations</h2>

<p>A <a href="https://en.wikipedia.org/wiki/T-shaped_skills">t-shaped person</a> is someone with a lot of shallow experience in many areas, and deep expertise in one or a few areas. Their skills are wide at the base, and tall and narrow in their area of focus.</p>

<p>Code can have a similar shape. Infrastructural work tends to be wide and shallow ‚Äî it touches a lot of places in your code, but it doesn‚Äôt go deep in any of them. Implementation work tends to be the opposite ‚Äî it doesn‚Äôt affect the entire app, but it goes very deep for one feature.</p>

<p>We probably review infrastructural changes differently than we review implementation changes:</p>

<ul>
  <li>
    <p>Infrastructural work deserves scrutiny for the abstractions it introduces and how it might affect performance or future implementations. These kinds of changes introduce new patterns to the codebase and we want to make sure they‚Äôre useful and usable patterns.</p>
  </li>
  <li>
    <p>An individual implementation gets more scrutiny on user-facing details. It‚Äôs probably combining <em>existing</em> patterns, so we‚Äôll spend less time looking at abstractions. We‚Äôll spend more time confirming it works for our users.</p>
  </li>
</ul>

<p>When a large PR combines wide, shallow, abstract work with deep, narrow, concrete work, it requires the reviewer to shift between two different mindsets. You might consider breaking your PR into two: one containing the wide infrastructural work, and one containing the deep implementation work. This allows reviewers to focus on abstractions in one PR and user-facing details in the other.</p>

<p>Some examples of infrastructural changes that could be separated from implementation work:</p>

<ul>
  <li>We introduced a seam to the code in order to make room for our implementation.</li>
  <li>We updated a dependency to take advantage of a new feature.</li>
  <li>We refactored before we started our implementation.</li>
</ul>

<h2 id="separating-an-already-large-pr">Separating an already-large PR</h2>

<p>It‚Äôs natural for PRs to grow large. <a href="https://thedecisionlab.com/biases/optimism-bias/">Optimism bias</a> diminishes our ability to estimate work often resulting in more code changes than we expected. A feature seems like it won‚Äôt take much work until you get deeper and find complexity in places you hadn‚Äôt considered. There‚Äôs a lot of uncertainty when you start working on a feature and we‚Äôd need to model the entire problem to completion to know what the PR was going to look like before we started. A PR seems like it will be small until suddenly‚Ä¶it isn‚Äôt anymore.</p>

<p>This is what usually prevents developers from separating PRs ‚Äî by the time you recognize the PRs could be de-tangled, it seems like a lot of effort to de-tangle them.</p>

<p>When you‚Äôve got a PR/branch that contains multiple lines of work and you want to separate them, <a href="https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase"><code class="language-plaintext highlighter-rouge">git rebase</code></a> is your best friend. Rebasing enables you to rename, reorder, combine, and separate commits. Use <code class="language-plaintext highlighter-rouge">git rebase</code> to group your commits into one set for each branch you want to extract, and submit a PR for each smaller set of changes.</p>

<p>Good commit hygiene makes it easier to rebase commits. Commit small units of work so that they can be re-ordered and grouped, and apply clear messages to each commit in case you need to move it. While you might not <em>always</em> separate/rebase PR branches, you‚Äôll appreciate small commits with clear messages when you do.</p>

<h2 id="small-prs-start-long-before-the-work-starts">Small PRs start long before the work starts</h2>

<p>The size of a pull request can be influenced long before the PR is opened. Slice features small in your product backlog; make small commits along the way; combine small commits into small pull requests. Among other benefits, a focus on breaking work into small parts will make it easier to review your changes.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Improve Pull Requests By Including Valuable Context]]></title>
    <link href="https://artsy.github.io/blog/2020/08/11/improve-pull-requests-by-including-valuable-context/"/>
    <updated>2020-08-11T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/08/11/improve-pull-requests-by-including-valuable-context</id>
    <content type="html"><![CDATA[<p>Code review is an engineering process that has benefited greatly from a move toward asynchronous communication.
Long ago, engineering teams would sit in a room with code on a projector to review changes together. üò± For many
teams this led to batching code reviews or even skipping them altogether. üò±üò±</p>

<p>Today, most engineering teams use incredible tools like GitHub or GitLab to review changes through Pull Requests
(PRs). The greatest advantage of PRs is that the review can happen when it‚Äôs convenient for the reviewer:
asynchronously. Asynchronous communication isn‚Äôt all sunshine and unicorns, though. Notably, it lacks the ability
to course-correct when context is misunderstood.</p>

<!-- more -->

<p>When you‚Äôre in a synchronous conversation with someone, it doesn‚Äôt take much time for them to let you know you‚Äôve
forgotten to include context. Their brow furrows. They look confused. You notice this and quickly add the missing
context to keep the conversation moving forward. It takes a lot longer to identify missing context when
communicating asynchronously. The non-verbal cues are missing.</p>

<p>Worse, lack of context when <em>reviewing code</em> asynchronously has a reverb effect. I create my PR when it‚Äôs
convenient for me, you ask a clarifying question when it‚Äôs convenient for you, I respond when it‚Äôs convenient for
me, etc. Suddenly my PR has been open for three days and we haven‚Äôt yet made it to a common understanding of why
I‚Äôve made these changes.</p>

<p>It‚Äôs extremely important to include all available context when drafting a PR. It saves incredible amounts of time
by cutting out slow round-trip conversations to clarify.</p>

<p>I‚Äôm personally proud of and impressed by the job we do at Artsy in including context in our PRs. We start early, by
giving our engineers
<a href="https://github.com/artsy/README/blob/master/playbooks/engineer-workflow.md#pull-requests">some reading about how we work with PRs during their onboarding</a>.</p>

<p>But beyond that our engineers lead by example. This article presents a handful of examples from Artsy repositories
demonstrating how you can add context to your PRs to avoid unnecessary clarifying conversation.</p>

<h2 id="explain-your-reasoning">Explain Your Reasoning</h2>

<p>You‚Äôve been thinking a lot about the problem you‚Äôre solving - probably significantly more than your reviewers.
You‚Äôll save everyone time by describing the problem and sharing how you‚Äôre thinking about it.</p>

<h3 id="define-the-problem-and-solution">Define the problem and solution</h3>

<p>Why does this PR exist? Explain the problem it solves and describe your solution, as
<a href="https://github.com/sweir27">Sarah</a> does <a href="https://github.com/artsy/force/pull/3095">in this PR</a>. For bonus points,
include alternative approaches you considered.</p>

<p>As you are writing up the problem and solution, you might find that you‚Äôve missed on the scope of your PR. Are
there <em>many</em> problems this PR is solving? Maybe this should be broken into smaller PRs. Is it hard to describe the
problem because it requires multiple other PRs? Maybe those should be consolidated into one cohesive set of
changes.</p>

<h3 id="explain-interesting-lines-of-code">Explain interesting lines of code</h3>

<p>The reviewers aren‚Äôt the only ones who can comment on lines of code.
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378228269">Give them</a> some
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378230196">additional information</a> about
<a href="https://github.com/artsy/emission/pull/2085#discussion_r378231974">why a particular line was written</a>, as
<a href="https://github.com/ds300">David</a> does <a href="https://github.com/artsy/emission/pull/2085">in this PR</a>. Maybe you want
feedback focused on that line or maybe the line has side-effects and implications that aren‚Äôt obvious.</p>

<h3 id="give-a-guided-tour-of-the-changes">Give a guided tour of the changes</h3>

<p><a href="https://github.com/dblandin">Devon</a> takes the idea of adding context to individual lines to the next level
<a href="https://github.com/artsy/reaction/pull/2774#pullrequestreview-288095754">in this PR</a>. He takes advantage of
markdown to give us a virtual tour of the changes, at each stop providing helpful information and a link to the
next change. It‚Äôs like he‚Äôs sitting next to you!</p>

<h2 id="show-your-work">Show Your Work</h2>

<p>If your PR contains work that is beyond trivial, show your reviewers how you thought about the problem. Demonstrate
the effects of the changes. Give them confidence that you‚Äôve worked through this problem thoroughly, and you‚Äôve
brought receipts.</p>

<h3 id="make-small-self-contained-commits">Make small, self-contained commits</h3>

<p>A good PR starts with good commits. Good commits are small, self-contained, and leave the codebase always in a
working state. With good commits, reviewers can see exactly how you worked through the problem you were solving.
<a href="https://github.com/artsy/convection/pull/645">Here‚Äôs a PR</a> from <a href="https://github.com/jonallured">Jon</a> that
demonstrates the use of small, self-contained commits to describe his approach to refactoring code before fixing a
bug.</p>

<p><em>Bonus tip</em>: it can be easier to review PRs with many small commits via the
<a href="https://github.com/artsy/convection/pull/645/commits"><em>Commits</em></a> tab instead of the
<a href="https://github.com/artsy/convection/pull/645/files"><em>Files changed</em></a> tab.</p>

<h3 id="demonstrate-the-results">Demonstrate the results</h3>

<p>Pictures are a worth a thousand words. Animated gifs are worth a thousand pictures (uhhhh, in file size too üò¨). An
animated gif showing the outcome of your PR gives reviewers a demo, and confidence that you‚Äôve verified your
changes.</p>

<p><a href="https://github.com/artsy/force/pull/5817">Here‚Äôs a PR</a> from <a href="https://github.com/ashleyjelks">Ashley</a> that includes
animated gifs of the changes she‚Äôs made. The effects of the changes might not be obvious by looking only at the
code, but seeing them in action makes it clear.</p>

<h3 id="document-the-unseen">Document the unseen</h3>

<p>Sometimes a PR‚Äôs changes have effects outside of the UI. There are still ways to give reviewers proof that the
changes have the desired effects.</p>

<p><a href="https://github.com/artsy/eigen/pull/3206">Here‚Äôs a PR</a> from <a href="https://github.com/yuki24">Yuki</a> that not only
demonstrates what‚Äôs happening in the UI, but also assures me that the back-end data is getting updated properly
through a Rails console.</p>

<p><a href="https://github.com/xtina-starr">Christina</a> authored <a href="https://github.com/artsy/reaction/pull/3441">this PR</a> which
shows the UI changes in addition to some output from her browser console, demonstrating that analytics tracking
calls are firing correctly.</p>

<h3 id="share-your-progress">Share your progress</h3>

<p>One mistake many engineers make with non-trivial pull requests is to wait to open them until they‚Äôre ‚Äúdone‚Äù. If
there are changes you‚Äôd like to get people‚Äôs eyes on quickly, open a WIP PR before the work is done: mark it as a
draft in GitHub, or put <code class="language-plaintext highlighter-rouge">WIP</code> in the title. Extra work up front avoids rework by starting early discussions about
your approach.</p>

<p>Let reviewers know in the body that your work isn‚Äôt complete. As you continue your work, use a <code class="language-plaintext highlighter-rouge">TODO:</code> list in the
body to illustrate your progress, as in <a href="https://github.com/artsy/palette/pull/464">this PR</a> from
<a href="https://github.com/sepans">Sepand</a>.</p>

<p>Is this PR part of a larger scope of work? Is there followup work that will need to be done after it‚Äôs merged? Are
there PRs in other systems that need to merge in a specific sequence? Any migration details or timing that should
be known before merging? Call these details out to avoid another round-trip conversation.</p>

<h2 id="spread-knowledge">Spread knowledge</h2>

<p>Pull requests should not be one-sided - they aren‚Äôt just about collecting feedback from the reviewer. They‚Äôre also
an opportunity to spread knowledge from the author.</p>

<h3 id="share-your-learnings">Share your learnings</h3>

<p>Maybe you learned some things about the system you‚Äôre working with, or you learned a new feature of the language.
Share this new information with your team. <a href="https://github.com/anandaroop">Roop</a> shares some findings about
disabled tests <a href="https://github.com/artsy/metaphysics/pull/2130">in this PR</a>.</p>

<p>We introduced a new state management library shortly before <a href="https://github.com/pepopowitz">I</a> opened
<a href="https://github.com/artsy/eigen/pull/3526">this PR</a>, and I had to do some reading about how to add types to
something. I <a href="https://github.com/artsy/eigen/pull/3526#discussion_r451161406">shared my learnings with the team</a>.</p>

<h3 id="share-development-tips">Share development tips</h3>

<p>Did you learn a new technique while building this feature? Share it with your team!</p>

<p>In <a href="https://github.com/artsy/reaction/pull/3279#discussion_r395461329">this PR</a>,
<a href="https://github.com/damassi">Chris</a> shared with us his technique for grabbing fixture data from his locally running
environment.</p>

<hr />

<p>When your team embraces the pull request process, you reap rewards that extend far beyond the lines of code.
Providing context up-front shortens the feedback loop and surfaces important discussions sooner, allowing you to
ship changes more quickly. Sharing knowledge in PRs grows individuals and spreads expertise across your team. Every
PR becomes an artifact for retracing history. You can look back and see not only <em>which</em> decisions were made, but
<em>why</em> they were made.</p>

<p>If you‚Äôd like to know more about how we work with pull requests at Artsy, take a look at our
<a href="https://github.com/artsy/README/blob/master/playbooks/engineer-workflow.md#pull-requests">‚ÄúEngineer workflow‚Äù playbook</a>,
or poke around <a href="https://github.com/artsy">our GitHub repositories</a>. Check out
<a href="https://github.com/artsy/artsy.github.io/pull/619">the PR that created this article</a>. And if you‚Äôve got examples
of great PRs to share with the rest of us, leave a comment!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[From engineering to product management, and back again]]></title>
    <link href="https://artsy.github.io/blog/2020/07/23/from-engineering-to-product-management-and-back-again/"/>
    <updated>2020-07-23T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/07/23/from-engineering-to-product-management-and-back-again</id>
    <content type="html"><![CDATA[<p>A year and a half ago I decided to become a product manager after 5 years as a software engineer. This past June,
however, I decided to switch back into engineering.</p>

<p>What happened, and what did I learn?</p>

<!-- more -->

<h1 id="why-i-became-a-product-manager">Why I became a product manager</h1>

<p>When I started at Artsy, I hadn‚Äôt planned on becoming a product manager. As I onboarded and worked on projects like
building Artsy‚Äôs ecommerce backend <a href="https://www.github.com/artsy/exchange">Exchange</a>, I found myself wanting to be
involved in the ‚Äúwhat‚Äù and ‚Äúwhy‚Äù of our product and not just the ‚Äúhow.‚Äù <a href="https://willdoenlen.com">I‚Äôm an artist</a>,
and so art and the art market are special topics for me. I felt like I would have more impact as a product manager,
and I definitely wanted to have greater impact on the art world.</p>

<p>My previous job had me doing a blend of product management and engineering work, and so I had already had a taste
of PMing. I spoke with our VP of Product at the time and she agreed to let me try it out. And just like that, in
January 2019 I became the product manager for the Auctions team.</p>

<h1 id="becoming-a-product-manager">Becoming a product manager</h1>

<p>Product management is a surprisingly difficult job to define. Everyone agrees on one thing: product managers lead
the product development process. However, what product development actually entails differs from company to company
because of differences in resources, culture and priorities. In practice, product managers may find themselves
doing a lot of things that on the surface have nothing to do with product development.</p>

<p>Product management can be distilled down into two tasks:</p>

<ol>
  <li>Ensuring that the right feature / product is being built for your users, and</li>
  <li>Doing whatever it takes to make (1) happen.</li>
</ol>

<p>A product manager‚Äôs sole job is to do whatever it takes to make sure your users are getting the right product.
That‚Äôll almost certainly involve talking to users to understand their needs, analyzing product usage data and
working with your team and stakeholders to create the next great feature, but there‚Äôs nothing in those two tasks
that says you need to do any of that. You can do this job any way you‚Äôd like as long as you get results. If I knew
that I could have built a better product for my users by pogo sticking across the Brooklyn Bridge then you would
have found me out there pogo sticking all day, every day.</p>

<p>All that to say, the job is highly ambiguous by design. <strong>Any problem could be your problem</strong>, and it‚Äôs up to you
to judge whether or not that‚Äôs the best use of your time for your users.</p>

<h2 id="redefining-work">Redefining work</h2>

<p>Compared to engineering, this ambiguity was a huge shift for me. As an engineer, my thinking was previously limited
to our systems and our codebase, and I largely thought about <em>how</em> to use them to build products. The ‚Äúhow‚Äù was now
largely abstracted away from me. It took me a long time to get out of that mindset, largely because I was
uncomfortable with how ambiguous PMing was.</p>

<p>There are a few reasons why the ambiguity was uncomfortable. The first was that the actual output of a product
manager didn‚Äôt <em>feel</em> like work. As an engineer, you can write code and instantly see the results of your work.
There‚Äôs a clear pipeline of progress, from initial commit to opening a pull request and deploying your code.</p>

<p>As a product manager, though, your output is much more amorphous. You might spend your time reading up on user
feedback, or you might make docs or comment on other docs. You might spend your whole day in meetings talking about
the same thing over and over again with different groups of people. You might get interrupted repeatedly throughout
the day with questions and problems. Days would fly by and I would have no idea what I did even though I was busy
all day. I just couldn‚Äôt get that feeling of progress.</p>

<p>I worked through that by keeping a detailed journal. For the first three or four months I recorded what I was doing
every hour of every day. That practice gradually transformed into a more manageable daily journal as I got used to
the work style. No one ever saw those notes ‚Äì it was just so I could keep track of what I was doing, what I was
thinking about and feel some accomplishment by writing things down. It helped bridge the gap, and it‚Äôs a practice I
still maintain.</p>

<p>Another thing that helped me with the ‚Äúfeeling‚Äù of work was reading the perspectives of other managers. Andrew
Grove‚Äôs <em>High Output Management</em> was especially useful. Somewhere along the line I read the phrase ‚Äúthe meeting
<em>is</em> the work,‚Äù and it clicked for me. A core output of my job was to communicate with others (more on that later).
As an engineer, it‚Äôs counterintuitive. The more time you spend in a meeting, the less time you spend writing code.
Product managers need quiet thinking time too, but a significant portion of the job is working with others.
Meetings are how the work gets done. That framing helped me feel more productive.</p>

<p>Compounding the problem of not knowing what work ‚Äúfelt‚Äù like was not really even knowing what my work was. Here‚Äôs a
great journal entry from my second or third week as a PM:</p>

<blockquote>
  <p>What I don‚Äôt have clarity on:</p>

  <ul>
    <li>Am I taking on too much for the first quarter?</li>
    <li>How do I narrow down the work that I want to do next?</li>
    <li>How do I organize everything?</li>
    <li>What am I supposed to be doing?</li>
  </ul>
</blockquote>

<p>It felt as existential as it looked!</p>

<p>Before I understood that part of my job was to systemtically remove any and every roadblock getting in the way of
shipping a great product, I tended to focus my energies solely on going through the product development cycle. I
could prioritize and propose a feature, but if something wasn‚Äôt possible it just wasn‚Äôt possible. As my
understanding evolved, though, I began to see that a lot of what wasn‚Äôt possible actually <em>was</em> possible. It just
depended on me creating change.</p>

<p>Knowing that felt both enormously empowering and terrifying. If I was unclear before on what my job was, I felt
even less clear now that any problem could be my problem. But I got used to it, and over time and with coaching
from my manager I was able to suss out what not only <em>could</em> be my problem but what <em>should</em> be my problem. There
are some things nobody can change, but there‚Äôs a surprising amount a single person can do. In the end, I think this
expansive view of work is the right framing for not only product management but really any job.</p>

<h2 id="from-data-paralyzed-to-data-informed">From data paralyzed to data informed</h2>

<p>I studied a hard science in school and have always valued rigorous, quantitative reasoning. That kind of reasoning
is valuable in science and engineering, but when faced with the fuzzy world of business it can only take you so
far. The data you might want to make a decision frequently doesn‚Äôt exist, and even if you can get it you probably
don‚Äôt have the time to get it. I found myself initially in loops of analysis paralysis, struggling to find a
rigorous justification for why we should build what we were building.</p>

<p>I found my way out of that loop by focusing on finding the best possible <em>outcome</em>. Instead of getting caught up
trying to maximize my quantitative understanding of an opportunity, I focused on getting just enough information to
understand the relative upside and downside profiles of the opportunities in front of me. I used a rule of thumb
that 70% confidence is usually good enough to make a call. I didn‚Äôt always know what the exact impact of a feature
would be, but I knew enough to know that whatever we were doing had the highest impact out of anything on the
table. That allowed me to make decisions with confidence.</p>

<p>With that frame of mind, my quantitative skills turned into a huge asset instead of a hindrance. I feel confident
navigating Artsy‚Äôs database and running my own SQL queries, which helped me work alongside our Data team to analyze
performance and potential impact for a new feature. And when that work was impossible, I was able to take the data
we had and still make an informed decision with it.</p>

<h2 id="learning-to-focus-on-users">Learning to focus on users</h2>

<p>That style of thinking didn‚Äôt just extend to <em>why</em> we should build a feature, but also <em>what</em> we should build. When
considering a feature, I found myself jumping immediately to how the feature would work on a systems level rather
than what the user experience should be. That was a double-edged sword. While it made discussions with the
engineers on my team seamless, I sometimes would rule out features in my head because I knew they ‚Äúweren‚Äôt
possible.‚Äù Of course, that did an injustice to both our users and the engineers on my team. Our users deserve the
best experience on Artsy, even if it feels impossible to me. And the engineers on my team could really find a
creative solution for just about anything I threw at them.</p>

<p>Similar to my data paralysis, part of the problem here was that creating a great user experience was fuzzy for me,
and I subconsciously rejected fuzzy things because they didn‚Äôt align with my version of rigorous knowledge. It was
easier for me think about systems than it was to think about creating a truly delightful user experience, and so I
thought about systems.</p>

<p>That changed as I really dug into user needs. I cultivated user empathy to an entirely new level by immersing
myself in user feedback and user research. I began to really <em>feel</em> that the choices we made impacted the
livelihoods and passions of collectors, institutions and artists. And that helped snap me out of it: our users
needed a better product, not better systems, and so I began to focus much more on how to make a better product.</p>

<p>To understand how to build a better product, I spent a lot of time examining other products to understand what made
them compelling. How did a product meet users‚Äô needs? How did it delight them? Where did it fall short? What would
I do to improve it? Doing this over and over again sharpened my product sense and made it easier to think through
how we could build a better experience for Artsy‚Äôs users.</p>

<h2 id="influence-and-communication">Influence and communication</h2>

<p>Influence is the currency of product managers. Good product managers work to expand their influence within an
organization so that they can quickly mobilize the organization towards the right goals. Since product managers
don‚Äôt make anything themselves, a product manager that nobody listens to simply can‚Äôt be effective.</p>

<p>The interpersonal skills I had built up and practiced as a software engineer didn‚Äôt directly translate to the
skills I needed to build influence. As a baseline, engineering communication requires precision and clarity of
thought. Since you‚Äôre typically talking with other engineers, you have shared language and set of tools to help get
your point across. For example, if you can‚Äôt succinctly express your idea in words you can just write that thought
out in code and other engineers will get it.</p>

<p>Product managers work with a lot of different kinds of people: engineers, designers, marketers, sales people,
operations, executives, users, enterprise customers, vendors‚Ä¶ the list goes on and on. Each person has a
different perspective, both from their organizational role and their own life experiences. You have to meet them
wherever they are, so your communication style needs to be highly adaptive.</p>

<p>Good communication feels seamless but is typically accompanied by a lot of planning and foresight. There was a lot
I needed to learn to be an effective communicator and, in turn, an effective leader. How to write a good document,
how to run a meeting, how to craft a compelling story, how to be just the right amount of direct, how to be just
the right amount of concise‚Ä¶ and, as a fairly verbal person how to draw good diagrams and pictures to communicate
my ideas. There‚Äôs no shortcut to improving these skills. Getting better is a matter of practice and feedback.</p>

<h2 id="learning-to-say-no">Learning to say no</h2>

<p>One of the most difficult things for me to learn was how and when to say ‚Äúno.‚Äù As an engineer, I prided myself on
having a can-do attitude and making seemingly impossible things happen. As a product manager, though, I have to
make sure that we‚Äôre always building the right thing for our users. Since my job is to make sure we‚Äôre doing that,
I usually have conviction that we‚Äôre currently doing the right thing. That means that, on average, when someone
requests product resources or proposes a new feature, I have to say no.</p>

<p>I like to be helpful, and so I was terrible at saying no at first. I wanted to help anyone and everyone who came to
me because, like when I was an engineer, I wanted solve everyone‚Äôs problems. But as I focused more and more on user
needs, it became clear what we should be working on to have the best impact on our users. That gave me the
conviction I needed to start saying no.</p>

<p>That still didn‚Äôt make it easier to <em>say</em> no. Prioritization decisions can have a big impact on other teams, and
it‚Äôs hard to see your coworkers feel disappointed when something they want won‚Äôt be prioritized. Learning how to
say no kindly and empathetically is an art form. But in general, it‚Äôs best done by clearly communicating priorities
and correctly setting expectations in the first place so that people don‚Äôt come with requests that won‚Äôt get
fulfilled. Doing that involves educating your coworkers on how the product prioritization process works,
socializing your product roadmap and spending lots of time to answer questions. It also may involve looping
stakeholders into the prioritization process so that their voices are clearly heard and they feel ownership over
the roadmap. It‚Äôs much easier to get things done when everyone is in alignment from the beginning.</p>

<h1 id="coming-back-to-engineering">Coming back to engineering</h1>

<p>After the first six months of working as a product manager I felt like I had gained my ‚Äúproduct legs.‚Äù I had
launched some successful features, had weathered major organizational change and had a clear idea of what our users
needed and what the future ought to look like. Over the next year I continued to hone my skills and expand my scope
as a product manager. Overall, things were going well.</p>

<p>I never stopped coding, though. I did small projects here and there, both inside and outside of work, but I never
really had the time to do anything big. After a year of being out of engineering I started to get an itch to build
and do technical work. I even had a few dreams where I was coding! I have dreams about all sorts of weird things
and don‚Äôt dwell on them, but something about my surreal dream edition of Visual Studio Code stuck with me.</p>

<p>I reflected on this more and looked through my personal journal to remember my prior experiences as an engineer,
when I‚Äôve felt happy and why I wanted to transition into product management. One thing I realized is that, as an
engineer, I didn‚Äôt always feel empowered. I felt like my role was just to code. But having worked as a product
manager, I knew that it didn‚Äôt have to be that way. I worked with engineers who had solid product skillsets and saw
how empowering and useful it could be. Being actively involved in coding and defining the right user experience
felt exciting to me.</p>

<p>I also reflected on what kind of work I wanted to have and how I wanted to spend my time. In general, my favorite
days at work have been when I do a blend of people / business work and creative technical work. I enjoyed the
strategic and people-focused work of product management but I missed making things and technical problem solving.
While I did get to exercise technical thinking as a product manager it was rarely a good use of my time to go deep.
I realized I could achive that balance better as an empowered engineer rather than as a product manager.</p>

<p>After a lot of thought, I decided that my longer term career direction made more sense as an engineering leader
rather than as a product leader. Fortunately, Artsy‚Äôs leadership agreed to let me transition back into engineering,
and at the beginning of June I was re-minted as a software engineer.</p>

<h2 id="onboarding-the-second-time">Onboarding the second time</h2>

<p>At this point, I‚Äôm six weeks back into engineering and my experience feels very different than before. I‚Äôve spent
most of my time ramping up and onboarding for the second time. Relearning our stack has been both a humbling and
rewarding experience. I‚Äôve forgotten a lot of the details of the frameworks we use, but this time instead of racing
to get through tickets I‚Äôve decided to really slow down and take the time to read the docs and do tutorials to make
sure I fully understand what‚Äôs going on. While it comes at the expense of speed in the short-term, it‚Äôll make me a
stronger engineer down the road, and I know that tradeoff is worth it. I also can‚Äôt speak highly enough of my
fellow engineers, who have been incredibly supportive while I learn.</p>

<h2 id="provide-value-not-code">Provide value, not code</h2>

<p>I‚Äôve also found my perspective is very different than before. While previously I would have seen my role as writing
great code, now I see my role as leveraging technology to provide value to users. What‚Äôs the difference? In the
former, I‚Äôm doing a <em>task</em> while in the latter I‚Äôm driving <em>outcomes</em>. It feels much more empowering as a mental
model for what I should do as an engineer. It‚Äôs also helped me shed any hint of perfectionism I had before since
writing ‚Äúperfect‚Äù code or building the ‚Äúperfect‚Äù system usually isn‚Äôt relevant to providing value to our users.</p>

<h2 id="developer-experience-is-a-product">Developer experience is a product</h2>

<p>Working as a product manager really taught me the value of engineering, which is frequently the bottleneck in
delivering value to your users. Creating the right strategy and vision for a product is critical work, but none of
that work matters if you can‚Äôt quickly get it to market. The faster you can move the more quickly you can create
the ideal product your users want, which in turn dictates how successful your product will be. Gains in engineering
efficiency snowball into massive benefits for users over time.</p>

<p>That‚Äôs led me to start seeing our developer experience as part of our product. It‚Äôs much more than just our
toolchain ‚Äì it‚Äôs the end-to-end cycle of working with a designer and product manager to understand product
requirements to building the feature to shipping it and monitoring in production. What does the ideal process look
like? Where are our bottlenecks? What investments will result in the best outcome for our users? These are
questions I‚Äôm asking myself as I ramp up, and I‚Äôm excited to dig into this more.</p>

<h1 id="should-you-be-a-product-manager">Should you be a product manager?</h1>

<p>If you‚Äôre an engineer wondering whether to make the jump to product management, my advice is to try it out. Product
management and engineering are complementary skillsets that build off of each other. Knowing how to do one role
absolutely helps with the other. You may find that you love being a product manager and continue on that track, or
you may discover instead that you love being an engineer empowered with a product skillset. In either case, it‚Äôll
turn out great.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kubernetes and Hokusai]]></title>
    <link href="https://artsy.github.io/blog/2019/10/18/kubernetes-and-hokusai/"/>
    <updated>2019-10-18T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/10/18/kubernetes-and-hokusai</id>
    <content type="html"><![CDATA[<p>When I joined Artsy Engineering a few months ago, I had roughly zero knowledge of Kubernetes. I‚Äôd heard the term
thrown around a few times, but had no idea how it worked or what it was used for.</p>

<p>Kubernetes is still a bit of a mystery to me, but I‚Äôm able to do a lot of Kubernetes operations quickly and easily
thanks to an open-source tool developed at Artsy: <a href="https://github.com/artsy/hokusai">Hokusai</a>.</p>

<p>In this post, I‚Äôll give some background on <a href="https://kubernetes.io">Kubernetes</a>, a brief history of Hokusai, a
description of its functionality, and some pointers for how to get started using it.</p>

<!-- more -->

<h1 id="what-is-kubernetes">What is Kubernetes?</h1>

<p>On a high level, Kubernetes is a tool designed to <em>orchestrate containers at scale.</em></p>

<p>Let‚Äôs break that down a bit. First, some helpful vocab:</p>

<p><strong>Container</strong>: Effectively code + all necessary dependencies for an application. A
<a href="https://www.docker.com/resources/what-container">‚Äústandardized unit of software‚Äù</a>.</p>

<p><strong>Pods</strong>: A group of one or more containers. One container per pod is the most common use case.</p>

<p><strong>Deployment</strong>: A Kubernetes component (read: program) that provides declarative updates to pods and manages their
lifecycles (i.e. creating new pods when new code is rolled out, rolling back to an earlier state, scaling up to
more pods, etc.).</p>

<p><strong>Node</strong>: A physical or virtual machine that runs a pod or pods.</p>

<p><strong>Cluster</strong>: A node or group of nodes.</p>

<p><strong>Container orchestration</strong>: A systemized approach to managing containers. Allows for things like auto-scaling,
easy rollouts and rollbacks, and automation of container downtime (i.e. something goes wrong in your process and
causes your app to crash; a new container gets spun up immediately so that your app doesn‚Äôt go down).</p>

<p>Sources: <a href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/">Kubernetes docs</a>,
<a href="https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html">Infoworld</a>,
<a href="https://www.docker.com/resources/what-container">Docker docs</a></p>

<p>Kubernetes, in a general sense, allows you to configure the containers in which your application will run. With a
properly configured Kubernetes cluster, this makes it easy to scale applications up or down as needed to deal with
traffic patters, maintain a zero-downtime deployment, and more. Very cool.</p>

<p>To sum up the structure of applications running on Kubernetes: clusters contain nodes which contain pods (which are
managed by deployments) which contain containers. This can be tricky to wrap your head around without
experimentation and personal experience‚ÄîHokusai aims to simplify the ways in which a developer can interact with
applications running on Kubernetes.</p>

<h1 id="what-is-hokusai">What is Hokusai?</h1>

<p>When Artsy‚Äôs Engineering team was contemplating a move to Kubernetes from Heroku, we had beef with a few things.</p>

<p>For one, we wanted to be able to do a few core things simply and easily using the command line. While Kubernetes
has a robust API and CLI tooling using <a href="https://kubernetes.io/docs/reference/kubectl/overview/">kubectl</a>, it‚Äôs also
very complex. We wanted to be able to quickly and easily do the things we were used to doing with Heroku; we
preferred <code class="language-plaintext highlighter-rouge">heroku logs</code> to <code class="language-plaintext highlighter-rouge">kubectl logs [POD]</code> (where we would have to either look up or know the specific pod
name we wanted, even though pods are being spun up and taken down all the time).</p>

<p><a href="https://helm.sh">Helm</a>, the de-facto package manager for Kubernetes, also didn‚Äôt quite fit our needs. Helm is
great for big, complex implementations with Kubernetes, and it‚Äôs very useful for managing releases. Artsy
Engineering wanted something that didn‚Äôt involve quite as many complex charts, and we‚Äôre not as concerned as some
orgs with versioned releases since our focus is mostly on web apps.</p>

<p>Basically, we wanted our commands to be application-level instead of pod- or node-level. We wanted a little more
abstraction than was offered by <code class="language-plaintext highlighter-rouge">kubectl</code>, and a little less than Helm.</p>

<p>And there was the issue of review apps. Review apps are basically standalone versions of an application that fall
completely outside a normal production pipeline. They allow you to test big or scary changes in functionality
without even putting them on a staging instance (which could affect other developers‚Äô work or be deployed
accidentally).</p>

<p>Kubernetes doesn‚Äôt support review apps out of the box. There are some add-ons that offer them, but at the time
Artsy was looking to switch, I don‚Äôt think they existed or were widespread.</p>

<p>Thus was born Hokusai: a tool that makes interacting with applications deployed on Kubernetes from the command line
simple. Need logs? <code class="language-plaintext highlighter-rouge">hokusai production logs</code>. Need to run a rake task? <code class="language-plaintext highlighter-rouge">hokusai staging run 'rake db:migrate'</code>. Or
want to set up a review app? There are a
<a href="https://github.com/artsy/hokusai/blob/master/docs/Review_Apps.md">few steps involved</a>, but you can have a
fully-featured copy of your app up and running in a few minutes.</p>

<p>The end of this post has a larger cheatsheet for handy Hokusai commands, but for now, let‚Äôs talk about how you can
use it yourself.</p>

<h1 id="how-can-i-set-up-hokusai-with-my-project">How can I set up Hokusai with my project?</h1>

<p>I should begin by noting that Hokusai is developed to work with AWS‚Äîif your application is running on a different
provider, you might have to hold off on Hokusai for now :( (or
<a href="https://github.com/artsy/hokusai">open a PR in Hokusai</a> yourself!) We do aim to support more clouds in the future,
and Hokusai mostly interacts directly with Kubernetes or Docker APIs.</p>

<p>Installing hokusai is super easy! You can see full instructions in the README on
<a href="https://github.com/artsy/hokusai">GitHub</a>, but if you‚Äôre already set up with Python, pip, Docker, Docker Compose,
and Git, you can do a quick install of Hokusai packed by <a href="https://www.pyinstaller.org/">PyInstaller</a> with Homebrew:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ brew tap artsy/formulas
$ brew install hokusai
</code></pre></div></div>

<p>There‚Äôs more robust directions
<a href="https://github.com/artsy/hokusai/blob/master/docs/Getting_Started.md">in the Hokusai repo</a>, but the very short
version is that <code class="language-plaintext highlighter-rouge">hokusai setup</code> handles most of the basics (creation of a Dockerfile, a config folder, and a few
other bits and bobs). From there, you can customize according to the needs of your project. It‚Äôs also possible to
write boilerplate templates to share with developers in your organization‚Äîyou can see Artsy‚Äôs
<a href="https://github.com/artsy/artsy-hokusai-templates">here</a>.</p>

<p>You should also check out Ash‚Äôs <a href="https://artsy.github.io/blog/2018/01/24/kubernetes-and-hokusai/">great post</a> on
setting up a new Hokusai project‚Äîhe runs through the process of setting up a new Rails application with Hokusai in
an easy-to-follow way that also details small hitches he ran into along the way.</p>

<h1 id="whats-next-for-hokusai">What‚Äôs next for Hokusai?</h1>

<p>As Hokusai has grown and changed over the years (the GH repo was created in November 2016!), a few things have
changed.</p>

<p>For one, it‚Äôs been increasingly used in coordination with CircleCI. Hokusai has made it really easy to standardize
a lot of application configuration across Artsy‚Äôs applications. We have
<a href="https://github.com/artsy/orbs/blob/master/src/hokusai">CircleCI orbs</a> set up for Hokusai specifically, which
standardize the way Hokusai is invoked in our CI, among other things. Given how helpful it‚Äôs been to have a single
source of CircleCI config for many of our apps, we‚Äôre pondering the idea of a central source for Kubernetes Hokusai
config. In other words, we‚Äôd like to have a ‚Äúbaseline‚Äù for things like deployments‚Äîsomething that could be
overriden as necessary in specific projects but would make spinning up new projects easy. This would effectively
allow Hokusai to support functionality similar to Helm‚Äôs <a href="https://helm.sh/docs/chart_template_guide/">templates</a>,
but in a way that can be consumed across project repos.</p>

<h1 id="hokusai-and-beyond">Hokusai and beyond</h1>

<p>Personally, Hokusai has been very useful to me as a kind of ‚Äútraining wheels‚Äù for Kubernetes. To be able to quickly
and easily start interacting with Kubernetes, even as a complete Kubernetes noob, was very empowering and helped me
be less intimidated by it. As I‚Äôve spent more time interacting with Hokusai, I‚Äôve started to understand what‚Äôs
going on behind the scenes, and I‚Äôve found myself poking around in the Kubernetes docs more than once. I‚Äôm excited
to keep learning more about Kubernetes and to start contributing to Hokusai!</p>

<p>Hokusai significantly lowers the barriers to interacting with Kubernetes apps and centralizes the complexity
inherent in doing so. It‚Äôs been invaluable in transitioning our engineering team to working with Kubernetes. If you
or your organization are in the midst of a similar transition‚Äîor if you have a sharp divide in Kubernetes knowledge
and comfort within your team‚Äîwe suggest giving it a try! Our issues are open for bug reports and feature requests,
and we certainly welcome PRs with improvements.</p>

<h2 id="appendix-a-useful-hokusai-commands">Appendix A: Useful Hokusai commands</h2>

<p>These are the commands I find myself using on a regular basis. If you‚Äôre playing around with Hokusai, you can also
run most commands with <code class="language-plaintext highlighter-rouge">--help</code> to get more information on their usage.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">hokusai [production|staging] env get</code>: Print all of the environment variables from your application‚Äôs pod</li>
  <li><code class="language-plaintext highlighter-rouge">hokusai [production|staging] env set "ENV=value"</code>: Set an environment variable on your application‚Äôs pod</li>
  <li><code class="language-plaintext highlighter-rouge">hokusai [production|staging] run 'rake db:migrate'</code>: run a Rails migration</li>
  <li><code class="language-plaintext highlighter-rouge">hokusai [production|staging] run 'bundle exec rails c' --tty</code>: Open a Rails console for your app (I have this
one aliased to <code class="language-plaintext highlighter-rouge">hokusai-[production|staging]-console</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">hokusai [production|staging] refresh</code>: Refresh the application‚Äôs deployment by recreating its containers</li>
  <li><code class="language-plaintext highlighter-rouge">hokusai build</code>: Build your application‚Äôs Docker image as defined in a <code class="language-plaintext highlighter-rouge">hokusai/build.yml</code> file</li>
  <li><code class="language-plaintext highlighter-rouge">hokusai test</code>: Boot a test environment and run a test suite as defined in <code class="language-plaintext highlighter-rouge">hokusai/test.yml</code></li>
  <li><code class="language-plaintext highlighter-rouge">hokusai pipeline gitcompare --org-name [org]</code>: Spits out a URL for a git comparison between production and
staging images</li>
  <li><code class="language-plaintext highlighter-rouge">hokusai pipeline gitlog</code>: Print a git log for commits between the image deployed on production and the image on
staging. Handy if you need to get the SHA of a staged commit quickly, e.g. for rollback purposes (?)</li>
</ul>
]]></content>
  </entry>
  
</feed>
