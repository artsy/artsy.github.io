<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Versioning | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/versioning/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2024-05-17T14:49:02+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simplifying Model-Level JSON Versioning with Mongoid-Cached-Json]]></title>
    <link href="https://artsy.github.io/blog/2012/03/23/simplifying-model-level-json-versioning-with-mongoid-cached-json/"/>
    <updated>2012-03-23T09:14:00+00:00</updated>
    <id>https://artsy.github.io/blog/2012/03/23/simplifying-model-level-json-versioning-with-mongoid-cached-json</id>
    <content type="html"><![CDATA[<p>Did you know that Netflix has hundreds of API versions, one for each device? Daniel Jacobson’s <a href="http://www.slideshare.net/danieljacobson/techniques-for-scaling-the-netflix-api-qcon-sf">Techniques for Scaling the Netflix API</a> at QConSF 2011 explained why they chose this model. And while we don’t all build distributed services that supply custom-tailored data to thousands of heterogeneous TVs and set-top boxes, we do have to pay close attention to API versioning from day one.</p>

<p>Versioning is hard. Your data models evolve, but you must maintain backward-compatibility for your public interfaces. While many strategies exist to deal with this problem, we’d like to propose one that requires very little programming effort and that is more declarative in nature.</p>

<p>At Artsy we use <a href="http://github.com/intridea/grape">Grape</a> and implement the “path” versioning strategy from the <a href="http://github.com/intridea/grape/tree/frontier">frontier</a> branch. Our initial v1 API is consumed by our own website and services and lives at <a href="https://artsyapi.com/api/v1">https://artsyapi.com/api/v1</a>. We’ve also prototyped v2 and by the time v1 is frozen, it should already be in production.</p>

<p>Grape takes care of version-based routing and has a system that lets you split version-based presentation of a model from the model implementation. I find that separation forcefully induced by unnecessary implementation complexity around wanting to return different JSON depending on the API version requested. What if implementing versioning in <code class="language-plaintext highlighter-rouge">as_json</code> were super simple?</p>

<p>Consider a Person model returned from a v1 API.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">API</span> <span class="o">&lt;</span> <span class="no">Grape</span><span class="o">::</span><span class="no">API</span>
  <span class="n">prefix</span> <span class="ss">:api</span>
  <span class="n">version</span> <span class="ss">:v1</span>
  <span class="n">namespace</span> <span class="ss">:person</span>
    <span class="n">get</span> <span class="s2">":id"</span>
      <span class="no">Person</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:id</span><span class="p">]).</span><span class="nf">as_json</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>

  <span class="n">field</span> <span class="ss">:name</span>

  <span class="k">def</span> <span class="nf">as_json</span>
    <span class="p">{</span>
      <span class="ss">name: </span><span class="nb">name</span>
    <span class="p">}</span>
  <span class="k">end</span>

<span class="k">end</span>
</code></pre></div></div>

<p>In v2 the model split <code class="language-plaintext highlighter-rouge">:name</code> into a <code class="language-plaintext highlighter-rouge">:first</code> and <code class="language-plaintext highlighter-rouge">:last</code> name and in v3 <code class="language-plaintext highlighter-rouge">:name</code> has finally been deprecated. A version v3 Person model would look as follows.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>

  <span class="n">field</span> <span class="ss">:first</span>
  <span class="n">field</span> <span class="ss">:last</span>

  <span class="k">def</span> <span class="nf">as_json</span>
    <span class="p">{</span>
      <span class="ss">first: </span><span class="n">first</span><span class="p">,</span>
      <span class="ss">last: </span><span class="n">last</span>
    <span class="p">}</span>
  <span class="k">end</span>

<span class="k">end</span>
</code></pre></div></div>

<p>How can we combine these two implementations and write <code class="language-plaintext highlighter-rouge">Person.find(params[:id]).as_json({ :version =&gt; ? })</code>?</p>

<p>In <a href="http://github.com/dblock/mongoid-cached-json">mongoid-cached-json</a> we’ve introduced a declarative way of versioning JSON. Here’s the code for Person v3.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Person</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">Document</span>
  <span class="kp">include</span> <span class="no">Mongoid</span><span class="o">::</span><span class="no">CachedJson</span>

  <span class="n">field</span> <span class="ss">:first</span>
  <span class="n">field</span> <span class="ss">:last</span>

  <span class="k">def</span> <span class="nf">name</span>
    <span class="p">[</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span> <span class="p">].</span><span class="nf">join</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">json_fields</span> <span class="p">\</span>
    <span class="ss">name: </span><span class="p">{</span> <span class="ss">:versions</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:v1</span><span class="p">,</span> <span class="ss">:v2</span> <span class="p">]</span> <span class="p">},</span>
    <span class="ss">first: </span><span class="p">{</span> <span class="ss">:versions</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:v2</span><span class="p">,</span> <span class="ss">:v3</span> <span class="p">]</span> <span class="p">},</span>
    <span class="ss">last: </span><span class="p">{</span> <span class="ss">:versions</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="ss">:v2</span><span class="p">,</span> <span class="ss">:v3</span> <span class="p">]</span> <span class="p">}</span>

<span class="k">end</span>
</code></pre></div></div>

<p>With the <a href="http://github.com/dblock/mongoid-cached-json">mongoid-cached-json</a> gem you also get caching that respects JSON versioning, for free. Read about it <a href="http://artsy.github.com/blog/2012/02/20/caching-model-json-with-mongoid-cached-json/">here</a>.</p>
]]></content>
  </entry>
  
</feed>
