<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: force | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/force/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2018-12-16T10:16:31+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A History of Artsy's Web Frontend]]></title>
    <link href="http://artsy.github.io/blog/2018/10/04/artsy-frontend-history/"/>
    <updated>2018-10-04T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2018/10/04/artsy-frontend-history</id>
    <content type="html"><![CDATA[<p>As Artsy Engineering grows in 2018, we have so many newcomers looking for context: they want to understand the
systems they'll be working in day-to-day. Awesome! But it's not enough to understand the systems themselves, it's
often helpful to understand the <em>history</em> of how we ended up where we are.</p>

<p>Frontend web development has changed a <em>lot</em> during Artsy's existence, and it continues to advance at a blistering
pace. It's easy to get caught up in the churn of frameworks and languages and tools, so I want to use this post as
an opportunity to contextualize each transition that Artsy's web presence has made over the past seven years. We've
changed technologies, but we've tried to do so with care and attention. Documenting these decisions is important
(and is ideally done <a href="https://ashfurrow.com/blog/contemporaneous-blogging/">contemporaneously</a>), but even with the best documentation, <a href="https://github.com/artsy/artsy.github.io/pull/489#discussion_r221301472">sometimes our own documentation
is unclear to us</a>.</p>

<p>In an effort to help contextualize our web frontend (which is <a href="https://github.com/artsy/force">open source</a>), this blog post will document
the major transitions that Artsy's web presence has made over the past seven years. Let's begin!</p>

<!-- more -->


<a name="Backbone...CoffeeScript"></a>
<h2>Backbone + CoffeeScript</h2>

<p>Artsy as you know it today began as a standard Rails application. We ran <code>git init</code> in January 2011, which coupled
our backend API to our web frontend, but since our frontend was just a fancy user interface for our API, this
worked for over two years. The web app itself was a kind of simplified MVC – controller logic lived inside the
views and models dealt with backend communication and notifying the view of state changes. For CSS, we used the
SASS CSS preprocessor. The Rails backend served initial pages that were then populated with follow-up API calls
made on the client-side. At a <em>very</em> high level, this isn't <em>that</em> different from what we do today with React.</p>

<p>Our site was built with a framework called <a href="http://backbonejs.org">Backbone</a>, which was really well-suited for our needs at the time.
From their documentation:</p>

<blockquote><p>Philosophically, Backbone is an attempt to discover the minimal set of data-structuring (models and collections)
and user interface (views and URLs) primitives that are generally useful when building web applications with
JavaScript. In an ecosystem where overarching, decides-everything-for-you frameworks are commonplace, and many
libraries require your site to be reorganized to suit their look, feel, and default behavior — Backbone should
continue to be a tool that gives you the <em>freedom</em> to design the full experience of your web application.</p></blockquote>

<p>As an outsider to the web at that time, I can't comment too heavily on Backbone. It seems like the freedom
(emphasis theirs) that they describe is a freedom from tangled jQuery code everywhere. I think our definition of
freedom on the web frontend has evolved since then, but that's just my feeling.</p>

<p>The other key component to our web frontend was <a href="https://coffeescript.org">CoffeeScript</a>. According to its documentation, "CoffeeScript is
a little language that compiles into JavaScript", which was pretty important at the time. JavaScript in 2011 was
very different from JavaScript today. The CoffeeScript docs also state that "JavaScript has always had a gorgeous
heart", which I'm not sure I'd agree with to be honest, but the CoffeeScript project really shows how a handful of
engineers working to improve something they care about can change an entire industry. While I don't think
contemporary JavaScript would have gotten as good as it has without CoffeeScript, it's a bit anachronistic to see
it used today.</p>

<p>Our goal as a (very small!) engineering team at the time was to keep our moving parts to a minimum.
Rails+SASS+CoffeeScript+Backbone helped us achieve that goal, and we couldn't have gotten this far without the help
of those projects.</p>

<a name="Ezel..amp..Friends"></a>
<h2>Ezel &amp; Friends</h2>

<p>In November 2013, we split our web frontend from the API backend. You can read
<a href="2013_review">all the details in this blog post</a>, but the story is summarized nicely as "moving from a single
monolithic application to modular Backbone apps that run in Node and the browser and consume our external API."
This move from monolith to modular systems continues to influence day-to-day work on the Artsy Engineering team.</p>

<p>We had already started moving away from a typical Rails app by moving our API to <a href="https://github.com/ruby-grape/grape">Grape</a> in order to support an
iOS application. The monolith also had some clear drawbacks including severe page load times, maintaining
duplicated backend and frontend UI templates, slow test suites, and poor developer productivity. We took the
project of building our mobile web frontend, m.artsy.net (still known as "martsy" internally) as an opportunity to
address these problems.</p>

<p>We built our new site with <a href="https://github.com/ruby-grape/grape">Node.js</a> since it allowed us to share and consolidate our server/client rendering
code. We split out areas of concern into separate "apps", with their own bundled CSS/JS to help page load times. We
server-side rendered above-the-fold content and used client-side JS to load the rest, which helped SEO and user
experience. We took a <a href="http://getbem.com/introduction/">BEM</a>-like approach to our CSS, which helped developer productivity. Our technical
decisions were driven primarily by our desire to create great user experiences.</p>

<p>And because we are an open source by default organization, we collected these approaches into an open source
project called <a href="https://github.com/artsy/ezel">Ezel</a>. While our main app used this Ezel approach, other new web apps – CMS systems for our
partners, auction-management systems for our admins, etc – were built on new internal tools to share assets and
code across the apps. We experimented a lot; we got pretty good at sharing resources across codebases. Most of our
web projects started on Heroku before moving to heavier-duty deployments as needed. Our frontend mindset at the
time (2015) was focused on getting to a stable, predictable stack. However... we started experimenting with React
around the same time.</p>

<p>CoffeeScript and Backbone were still working for us, and we still use them in production in many systems. However,
the state of the art in web development moved on. When I joined the auctions team and helped maintain one of our
CoffeeScript+Backbone apps, I was <em>very</em> confused about how data flowed from one part of the app to another, across
languages, with a lot of magic happening. I think that's typical in these kinds of apps – "convention over
configuration" is a good mantra <em>if</em> you can expect that incoming engineers are familiar with the conventions.
That's just not the case anymore.</p>

<p>By 2016, we had <a href="http://artsy.github.io/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react/">experimented with React</a> and followed up with <a href="http://artsy.github.io/blog/2016/08/09/the-tech-behind-live-auction-integration/">another app built with the
technology</a>. React (and Redux) were very well-suited for our realtime auction bidding UI, and would later
prove helpful in our <a href="https://github.com/artsy/positron">editorial CMS</a>. These experiences helped prove the technology was ready for
production use <em>and</em> convinced us that React was great at reducing the complexities of building user interfaces
(the realtime nature of our auctions product was particularly well-suited for Redux's state management; it was our
first from-scratch React app).</p>

<p>When the Artsy business require us to make changes to how we build software, like splitting up our monolith, we try
to take full advantage of those changes to improve how we work, which means evaluating new tools. Adopting Node.js
and Ezel wouldn't make sense today, but at the time, they helped us scale up Artsy's business without the same
scaling up of our engineering resources. Ezel helped us do more with less, which is still an important criteria we
use for evaluating new tools.</p>

<a name="React"></a>
<h2>React</h2>

<p>By 2017, the divisions between our mobile frontend and web frontend teams had been totally dissolved (as they
should – the division between mobile and web developers is a false dichotomy). Our <a href="http://artsy.github.io/blog/2017/04/14/artsy-technology-stack-2017/">2017 tech stack
post</a> discusses this in depth, but our goal was really to unify the paradigm that frontend engineers
at Artsy use to build user interfaces, whether that's on mobile or web. React and React Native were our answer to
that challenge.</p>

<p>On the web side of things, however, Artsy had another challenge. Sure, React is great, and sure, it's how we want
to build user interfaces, but how do we get there? We're not fans of large rewriting projects, so we opted for what
we call an "incremental revolution" approach. We built a library called <a href="https://github.com/artsy/stitch">Stitch</a> that would let us mount React
components inside our existing app. Using this approach, we could migrate to React component-by-component. We've
been using Stitch in production for over a year and have been very happy with its approach; you can read more
details of integrating it into our main frontend app <a href="http://artsy.github.io/blog/2017/09/05/Modernizing-Force/">in this blog post</a>.</p>

<p>Today, principal React work takes place in <a href="https://github.com/artsy/reaction">a shared components repo</a>. We share these components across
several of our web apps using Stitch. We have been pretty pleased with the results! But our dive into React is only
just beginning. The community is moving quickly to figure out what best practices make sense in the React paradigm,
and we're a part of that. We are evaluating technologies like <a href="https://www.styled-components.com">styled-components</a> and <a href="https://jxnblk.com/styled-system/">styled-system</a> to create
a universal design system within Artsy. The area is under very active development, so I'll save details for a
future blog post.</p>

<p>I can't go too much further without talking about GraphQL. v1 of our API (REST) is still in use around much of
Artsy and, despite the best efforts of some of our engineers, v2 of our API (<a href="http://stateless.co/hal_specification.html">HAL</a>) hasn't gained significant
internal use yet. Instead, we found ourselves building a <a href="https://graphql.org">GraphQL</a> server to orchestrate API calls to our
existing APIs. This confers many benefits, which I describe from a mobile perspective in some detail <a href="https://ashfurrow.com/blog/the-spirit-of-moya/">here</a>.
The key thing to understand about our GraphQL server, <a href="https://github.com/artsy/metaphysics/">which is open source</a>, is that it is under the
stewardship of our frontend engineers, not our platform engineers. That's not to say that our platform team isn't
involved with its development – in fact, they've been key to scaling it up – but Artsy frontend engineers created
the server to help us build better UIs, and while the technology is still very new, we continue to see it pay
dividends.</p>

<p>Okay so remember earlier when I said that we dissolved our mobile team? Well, I was on that team and it wasn't like
our mobile engineers all learned how Artsy does web – we brought our culture and tools with us and, together with
our web colleagues, have built an integrated engineering team that's greater than the sum of its parts. One thing
that was important to mobile engineers was type safety, so we had to have a conversation about JavaScript.</p>

<p>On its own, JavaScript can't guarantee type safety. We investigated two options: <a href="http://www.typescriptlang.org">TypeScript</a> and <a href="https://flow.org">Flow</a>. <a href="http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/">This
blog post</a> goes into detail about our decision, but tl;dr we chose TypeScript. We have been building (and
helping to build) tools <a href="https://github.com/relay-tools/relay-compiler-language-typescript">relay-compiler-language-typescript</a> to take full advantage of interoperability
between TypeScript types and GraphQL types through <a href="https://facebook.github.io/relay/">Relay</a>, as well as using Babel 7 to migrate existing projects
to TypeScript incrementally, which you can read about in more detail <a href="https://artsy.github.io/blog/2017/11/27/Babel-7-and-TypeScript/">here</a>. It's all very exciting – you
can read more on how Relay and GraphQL interoperate <a href="http://artsy.github.io/blog/2018/07/25/Relay-Networking-Deep-Dive/">in this blog post</a>.</p>

<p>We started building software in React not because it was trendy, but because it helped our engineering team deliver
more value to the business. It's been a huge success, but not without its costs. We've tried to mitigate those
costs by using tools like Stitch to migrate apps to React incrementally, and through spreading knowledge of how our
stack through internal knowledge-sharing like <a href="http://artsy.github.io/series/javascriptures/">JavaScriptures</a>. While the transition to React has had its costs,
<em>not</em> moving would also be costly, too.</p>

<hr />

<p>Since I joined Artsy, I've seen us continually investing in tooling that helps us build better software. The
results of this culture-of-continuous-improvement speak for themselves: with fewer than 30 engineers total, we
support a growing company with a suite of software built for many canvasses <em>and</em> we have an outsized impact on the
software industry relative to our size. Our frontend web stack is just one facet of our evolving technology –
there's lots of exciting stuff on the backend, too (<a href="https://github.com/artsy/hokusai">for example...</a>). Through my research for this blog
post, I learned a lot about what drives technological decisions on our team. From humble beginnings as a Rails app,
to CoffeeScript and Bootstrap, to React and GraphQL, Artsy Engineering has evolved our frontend software to achieve
a quality worthy of art – both from the user's perspective and from the developer's. I'm very excited about what's
coming next, and I can't wait to share it with you. Have a great day!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Modernizing Force]]></title>
    <link href="http://artsy.github.io/blog/2017/09/05/Modernizing-Force/"/>
    <updated>2017-09-05T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/09/05/Modernizing-Force</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/artsy/force">Force</a> is Artsy's main website, <a href="https://www.artsy.net">artsy.net</a>. In the three years since it was <a href="http://artsy.github.io/blog/2014/09/05/we-open-sourced-our-isomorphic-javascript-website/">open-sourced</a>, it has provided a solid foundation to build features on top of without a lot of the costs associated with growth. It is an early example of Isomorphic ("universal") JavaScript, built on top of Express, Backbone, CoffeeScript, Stylus and Jade. It is also highly modular, adopting patterns laid down by its parent project,  <a href="https://github.com/artsy/ezel">Ezel</a>.</p>

<p>When first developed these technologies made a lot of sense; CoffeeScript fixed many of the problems with JavaScript pre-ES6, and Jade / Stylus made working with HTML / CSS much more elegant. As time progressed and new technologies became a thing these solutions starting feeling more burdensome to continue building features with and many of our developers longed to start using next-generation tools like React.</p>

<!-- more -->


<p>Looking at output from <code>cloc</code>, the question is "But how?"</p>

<pre><code class="js">[artsy/force] $ cloc desktop mobile

--------------------------------------------------------
Language                     files                  code
--------------------------------------------------------
CoffeeScript                  1828                 81569
CSS                              9                 76632
Stylus                         577                 32324
JavaScript                     274                 18310
JSON                            30                  6145
Markdown                        41                  1097
HTML                             3                    25
XML                              3                    24
--------------------------------------------------------
SUM:                          2765                216126
--------------------------------------------------------
</code></pre>

<p>216k+ LOC, spread across multiple languages and formats. Given finite resources and a small team rebuilds can be difficult to execute, and so we had to figure out a way to marry the old with the new while also maintaining backwards compatibility / interoperability. Out of this exercise came a few patterns, libraries and projects that I would like to describe in an effort to help those caught in similar situations.</p>

<a name="Step.1:.Get.Your.House..aka.Compiler..in.Order"></a>
<h2>Step 1: Get Your House (aka Compiler) in Order</h2>

<p><a href="https://babeljs.io/">Babel</a> has been around for a while, but lately their team has been putting effort into making it as easy as possible to use. By dropping a <a href="https://github.com/artsy/force/blob/master/.babelrc">.babelrc</a> file into the root of your project, server and client-side JavaScript can share the same configuration, including <a href="https://github.com/tleunen/babel-plugin-module-resolver">module resolution</a> (aka, no more <code>../../../</code>).</p>

<p>A simplified example:</p>

<pre><code class="json">// .babelrc

{
  "presets": ["es2015", "react", "stage-3"],
  "plugins": [
    ["module-resolver", {
      "root": ["./"]
    }]
  ]
}
</code></pre>

<pre><code class="js">// index.js

require('coffee-script/register')
require('babel-core/register')

// Start the app
require('./boot')
</code></pre>

<p>On the client, we use <a href="http://browserify.org/">Browserify</a> with <a href="https://github.com/substack/coffeeify">Coffeeify</a> and <a href="https://github.com/babel/babelify">Babelify</a>:</p>

<pre><code class="json">// package.json

{
  "scripts": {
    "assets": "browserify -t babelify -t coffeeify -o bundle.js",
    "start": "yarn assets &amp;&amp; node index.js"
  }
}
</code></pre>

<p>And then boot it up:
<code>sh
$ yarn start
</code></p>

<p>By adding just a few lines, our existing CoffeeScript pipeline was augmented to support modern JavaScript on both the server and the client, with code that can be shared between.</p>

<a name="Step.2:.Tune-up.Iteration.Time"></a>
<h2>Step 2: Tune-up Iteration Time</h2>

<p><a name="iteration-time"></a></p>

<p>A question that every developer should ask of their stack is:</p>

<blockquote><p>"How long does it take for me to make a change and see that change reflected in a running process?"</p></blockquote>

<p>Does your code take one second to compile, or ten? When writing a back-end service, does your server <a href="https://github.com/remy/nodemon">automatically restart</a> after you make a change, or do you need to <code>ctrl+c</code> (stop it) and then restart manually?</p>

<p>For those of us working in Force, the bottleneck typically involved making changes to back-end code. Due to how we organize our sub-apps, client-side code compilation -- after the server heats up -- is pretty much instant, but that heat-up time can often take a while depending on which app we're working on. So even with a "restart on code change" setup that listens for updates it still felt terribly slow, and this iteration time would often discourage developers from touching certain areas of the codebase. We needed something better!</p>

<p>Enter Webpack and React, which helped popularize the concept of HMR, or "Hot Module Replacement".</p>

<p>From the Webpack docs:</p>

<blockquote><p>"Hot Module Replacement (HMR) exchanges, adds, or removes modules while an application is running, without a full reload."</p></blockquote>

<p>That's more like it! But is there anything similar for the server given we don't use Webpack? This was the question <a href="https://github.com/alloy">@alloy</a>, one of our Engineering Leads, asked himself while researching various setups that ultimately led to <a href="https://github.com/artsy/reaction">Reaction</a>, and for which he found an answer to in Glen Mailer's excellent <a href="https://github.com/glenjamin/ultimate-hot-reloading-example">ultimate-hot-reloading-example</a>. Digging into the code, <a href="https://github.com/glenjamin/ultimate-hot-reloading-example/blob/master/server.js#L38-L45">this little snippet</a> jumped out:</p>

<pre><code class="js">watcher.on('ready', function() {
  watcher.on('all', function() {
    console.log("Clearing /server/ module cache from server");
    Object.keys(require.cache).forEach(function(id) {
      if (/[\/\\]server[\/\\]/.test(id)) delete require.cache[id];
    });
  });
});
</code></pre>

<p>The code seemed simple enough -- on change, iterate through Node.js's internal require cache, look for the changed module, and clear it out. When the module is <code>require</code>'d at a later point it will be like it was required for the first time, effectively hot-swapping out the code.</p>

<p>With this knowledge we wrapped a modified version of this snippet into <a href="https://github.com/artsy/express-reloadable">@artsy/express-reloadable</a>, a small utility package meant to be used with Express.</p>

<p>Here's a full example:</p>

<pre><code class="js">import express from 'express'
import { createReloadable, isDevelopment } from '@artsy/express-reloadable'

const app = express()

if (isDevelopment) {

  // Pass in app and current `require` context
  const reloadAndMount = createReloadable(app, require)

  // Note that if you need to mount an app at a particular root (`/api`), pass
  // in `mountPoint` as an option.
  app.use('/api', reloadAndMount(path.resolve(__dirname, 'api'), {
    mountPoint: '/api'
  }))

  // Otherwise, just pass in the path to the express app and everything is taken care of
  reloadAndMount(path.resolve(__dirname, 'client'))
} else {
  app.use('/api', require('./api')
  app.use(require('./client')
}

app.listen(3000, () =&gt; {
  console.log(`Listening on port 3000`)
})
</code></pre>

<p>In Force, we mounted this library <a href="https://github.com/artsy/force/blob/master/lib/setup.js#L205">at the root</a>, allowing us to make changes anywhere within our numerous sub-apps and with a fresh page reload instantly see those changes reflected without a restart. This approach also works great with API servers, as this implementation from Artsy's <a href="https://github.com/artsy/positron/blob/master/boot.js#L34">editorial app Positron</a> shows. Like magic, it "just works". Why isn't this trick more widely used and known?</p>

<a name="Step.3:.The.View.Layer..or:.How.I.Stopped.Worrying.and.Learned.to.Love.Legacy.UI"></a>
<h2>Step 3: The View Layer, or: How I Stopped Worrying and Learned to Love Legacy UI</h2>

<p>This one was a bit tricky to solve, but ultimately ended up being fairly straightforward and conceptually simple. In Force, we've got dozens of apps built on top of hundreds of components supported by thousands of tests stretched across desktop and mobile. From the perspective of sheer code volume these things aren't going anywhere any time soon. On top of that, our view templates are built using Jade (now known as <a href="https://pugjs.org">Pug</a>), which supports an interesting form of inheritance known as <a href="https://pugjs.org/language/inheritance.html">blocks</a>. What this means in practice is our UI has been extended in a variety of complex ways making alternative view engines difficult on the surface to interpolate.</p>

<p>What to do? It's 2017 and the era of handlebars templates bound to Backbone MVC views is over. We want <a href="https://facebook.github.io/react/">React</a>! We want <a href="https://www.styled-components.com/">Styled Components</a>! And when those tools are surpassed by the Next Big Thing we want that too! But we also want our existing CoffeeScript and Jade and old-school <code>Backbone.View</code>s as well.</p>

<p>Thinking through this problem, <a href="https://github.com/artsy/stitch">@artsy/stitch</a> was born.</p>

<p>Stitch helps your Template and Component dependencies peacefully co-exist. You feed it a layout and some data and out pops a string of compiled html that can be passed down to the client. "Blocks" can be added that represent portions of UI, injected by key. It aims for maximum flexibility: templating engines supported by <a href="https://github.com/tj/consolidate.js">consolidate</a> can be installed and custom rendering engines <a href="https://github.com/artsy/stitch#custom-renderers">can be swapped out or extended</a>. With very little setup it unlocks UI configurations that have been lost to time.</p>

<p>A basic example:</p>

<p>
```html</p>

<div>
  {{title}}
</div>


<pre><code>
</code></pre>

<p>const html = await renderLayout({
  layout: 'templates/layout.handlebars',
  data: {
    title: 'Hello!'
  }
})</p>

<p>console.log(html)</p>

<p>// => Outputs:
/*</p>

<div>
  Hello!
</div>


<p>*/
```</p>

<p>By adding "blocks" you can begin assembling (or adapting to) more complex layouts. Blocks represent either a path to a template or a component (with "component" meaning a React or <a href="https://preactjs.com">React-like</a> function / class component):</p>

<p>
```html
// templates/layout.handlebars</p>

<p><html>
  <head>
    <title>
      {{title}}
    </title>
  </head>
  <body
    {{{body}}}
  </body>
</html>
```
</p>

<pre><code class="js">// index.js

const html = await renderLayout({
  layout: 'templates/layout.handlebars',
  data: {
    title: 'Hello World!',
  },
  blocks: {
    body: (props) =&gt; {
      return (
        &lt;h1&gt;
          {props.title}
        &lt;/h1&gt;
      )
    }
  }
})

console.log(html)

// =&gt; Outputs:
/*
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;
      Hello World!
    &lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
*/
</code></pre>

<p>In Force, we're using this pattern to incrementally migrate portions of our app over to React, by taking existing block-based Jade layouts and injecting <code>ReactDOM.renderToString</code> output into them, and then rendering the layout into an HTML string that is passed down from the server and rehydrated on the client, isomorphically.</p>

<p>Our existing Backbone views take advantage of the <code>templates</code> key:</p>

<pre><code class="js">// server.js

import LoginApp from 'apps/login/LoginApp'
import { Provider } from 'react-redux'
import { StaticRouter } from 'react-router'

const html = await renderLayout({
  layout: 'templates/layout.handlebars',
  data: {
    title: 'Login / Sign-up',
  },
  templates: {
    login: 'templates/login.jade'
  },
  blocks: {
    app: (props) =&gt; (
      &lt;Provider store={store}&gt;
        &lt;StaticRouter&gt;
          &lt;LoginApp {...props} /&gt;
        &lt;/StaticRouter&gt;
      &lt;/Provider&gt;
    )
  }
})

res.send(html)
</code></pre>

<p>Similar to blocks, templates located in this object are pre-compiled and available to your components as <code>props.templates</code>.</p>

<p>Once the html has been sent over the wire, we mount it like so:</p>

<pre><code class="js">// client.js

import LoginApp from 'apps/login/LoginApp'

React.render(
  &lt;LoginApp {...window.__BOOTSTRAP__} /&gt; // Data passed down from `data` key
)
</code></pre>

<pre><code class="js">// apps/login/LoginApp.js

import React from 'react'
import Login from 'apps/login/Login'

export default function LoginApp (props) {
  const {
    templates: {
      login
    }
  } = props

  return (
    &lt;Login
      template={login}
    /&gt;
  )
}
</code></pre>

<p>During the server-side render phase existing template code will be rendered with the component, and once the component is mounted on the client <code>componentDidMount</code> will fire and the Backbone view instantiated:</p>

<p>
```js
// apps/login/Login.js</p>

<p>import React, { Component } from 'react'
import LoginBackboneView from 'apps/login/views/LoginView'</p>

<p>export default class Login extends Component {
  componentDidMount () {
    this.loginView = new LoginBackboneView()
    this.loginView.render()
  }</p>

<p>  componentWillUnmount () {
    this.loginView.remove()
  }</p>

<p>  render () {
    return (
      <div>
        <div dangerouslySetInnerHtml={{
          __html: this.props.template
        }}>
      </div>
    )
  }
}
```
</p>

<p>All of the possibilities that Stitch provides are too numerous to go over here, but check out the <a href="https://github.com/artsy/stitch#usage">documentation</a> and <a href="https://github.com/artsy/stitch/tree/master/examples">example apps</a> for more complete usage. While new, this pattern has worked quite well for us and has allowed Force to evolve alongside existing code with very little friction.</p>

<a name="Moving.Forward"></a>
<h2>Moving Forward</h2>

<p>A common thread that connects <a href="https://github.com/artsy/force">Force</a> to <a href="https://github.com/artsy/eigen">Eigen</a> (Artsy's mobile app) is an understanding that while grand re-writes will gladly remove technical debt, technical debt is not our issue. A lot of the patterns we've laid down within our apps still work for us, and many of our implementations remain sufficient to the task. What we needed was an environment where <em>incremental revolution</em> was possible, where old ideas could merge with new and evolve. In terms of Eigen, we felt the best way forward was the adoption of <a href="https://facebook.github.io/react-native/">React Native</a> -- and <a href="https://github.com/artsy/emission">Emission</a> was born. Likewise, for our web and web-based mobile apps, <a href="https://github.com/artsy/reaction">Reaction</a> is serving a similar role. Both of these projects are built with <a href="https://www.typescriptlang.org/">TypeScript</a>, and both rely heavily on functionality that our <a href="http://graphql.org/">GraphQL</a> interface <a href="https://github.com/artsy/metaphysics">Metaphysics</a> provides. But crucially, these projects <em>augment</em> our existing infrastructure; they don't replace it. They fit in with existing ideas, tools and processes that have facilitated Artsy's growth, including highly-specific domain knowledge that our engineers have built up over time.</p>

<p>In conclusion, I hope this post has provided a bit of a window into some of our processes here at Artsy for those facing similar challenges. If you want to take a deeper dive, check out the links below:</p>

<ul>
<li><a href="https://github.com/artsy/express-reloadable">express-reloadable</a></li>
<li><a href="https://github.com/artsy/stitch">stitch</a></li>
<li><a href="https://github.com/artsy/reaction">reaction</a></li>
<li><a href="https://github.com/artsy/emission">emission</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Artsy's Technology Stack, 2017]]></title>
    <link href="http://artsy.github.io/blog/2017/04/14/artsy-technology-stack-2017/"/>
    <updated>2017-04-14T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/04/14/artsy-technology-stack-2017</id>
    <content type="html"><![CDATA[<a name="History"></a>
<h1>History</h1>

<p>Artsy was <a href="http://www.nytimes.com/2012/10/09/arts/design/artsy-is-mapping-the-world-of-art-on-the-web.html">launched in 2012 as the "Art Genome Project"</a> and grew exponentially ever since.</p>

<p>By 2014 we had 230,000 works of art from 600 museums and institutions and launched our first business, a subscription service for commercial galleries, bringing over 80,000 works for sale and partnerships with 37 art fairs and a handful of benefit auctions. That year collectors from 82 countries inquired on over $5.5B of art.</p>

<p>By 2015 we doubled our "for sale" inventory and aggregated 4,000 of the world's leading galleries and 60 art fairs. We also launched two new businesses: commercial auctions and online media.</p>

<p>Finally, in 2016 we, again, doubled our paid gallery network size to become the largest gallery network in the world and grew to become the most-read online art publication as our highly engaging editorial traffic ballooned 320%. We also launched a platform to bid in live auctions and a consignments service with all major auction houses.</p>

<a name="The.Artsy.Business.in.2017"></a>
<h1>The Artsy Business in 2017</h1>

<p>Artsy in 2017 is a very wide platform and it can be challenging to characterize simply. But when you boil it down to its essence, Artsy offers information and a marketplace. Our written content and fair coverage keep people informed about the art world, and the Art Genome powers our tools for exploration. Through our partnerships with the major player in the art market, galleries and auction houses, we offer our users a unified platform for buying and selling art.</p>

<p>Internally we consider Artsy to have three businesses: <em>Auctions</em>, <em>Content</em> and <em>Listings</em>.</p>

<ul>
<li><p><em>Auctions</em>: Auction houses and charities use Artsy as a sales channel for a commission because collectors want to discover and buy art in a single, central platform that excels at surfacing the art they want from a global market.</p></li>
<li><p><em>Content</em>: Brands pay Artsy to reach the first art audience at scale by enabling evergreen content online and for offline engagement during art world events.</p></li>
<li><p><em>Listings</em>: Galleries, Fairs and Institutions subscribe to Artsy for a fee because we bring a very large audience of art collectors and enthusiasts to their virtual doors.</p></li>
</ul>


<p>The Artsy team is now 166 employees across three offices in New York, Berlin and London. The Engineering organization is now 28 engineers, including 4 leads, 3 directors and a CTO. In this post, we'd like to comprehensively cover what, and how we make the technical and human sides of Artsy businesses work.</p>

<!-- more -->




<center>
 <img src="/images/tech-2017/businesses.svg" style="width:100%;">
</center>


<a name="Organizational.Structures"></a>
<h1>Organizational Structures</h1>

<p>In 2016, we <a href="/blog/2016/03/28/artsy-engineering-organization-stack">updated the Engineering organization</a> to be oriented around product verticals for businesses. We used to focus more on practices to group engineers working with the same technologies across product teams to facilitate knowledge sharing and avoid redundant efforts.</p>

<p>Since then, web and mobile "practices" have largely been subsumed into the separate product teams. Mobile's increasing reliance on React Native has aligned nicely with web tooling. It no longer made sense to keep the teams separate, so where product teams used to have 2 separate sub-teams of engineers, they've now merged into 1.</p>

<p>The Platform "practice" has remained as a way to coordinate and share work among product teams, as well as monitor and upgrade Artsy's platform over time. Most platform engineers operate from within product teams, while a few focusing on data and infrastructure form a core, dedicated Platform team.</p>

<center>
 <img src="/images/tech-2017/engineering-teams.svg" style="width:100%;">
</center>


<a name="Artsy.Technology.Infrastructure.2017.-.Splitting.the.Monolith"></a>
<h1>Artsy Technology Infrastructure 2017 - Splitting the Monolith</h1>

<p></article>
<a href='/images/tech-2017/artsy-stack.svg' style="">
  <img src="/images/tech-2017/artsy-stack.svg" alt="The Artsy Tech Stack 2017" style="width:100%;">
</a>
<article class="post">
</p>

<a name="User.Facing"></a>
<h2>User Facing</h2>

<p>A lot of the user-facing focus is on being able to present interfaces with a quality worthy of art.</p>

<p>What you see today when you go to <a href="https://artsy.net">www.artsy.net</a> is a website built with <a href="https://github.com/artsy/ezel">Ezel.js</a>, which is a boilerplate for <a href="http://backbonejs.org">Backbone</a> projects running on <a href="https://nodejs.org">Node</a> and using <a href="http://expressjs.com">Express</a> and <a href="http://browserify.org">Browserify</a>. We used to have separate projects for mobile and desktop web, but they <a href="https://github.com/artsy/force/pull/890">are now merged</a>. The combined app is hosted on <a href="http://heroku.com">Heroku</a> and uses <a href="http://redis.io">Redis</a> for caching. Assets, including artwork images, are served from <a href="http://aws.amazon.com/s3">Amazon S3</a> via the <a href="http://aws.amazon.com/cloudfront">CloudFront CDN</a>. This <a href="https://github.com/artsy/force">code is open-source</a>.</p>

<p>What you see today when you open the <a href="https://itunes.apple.com/us/app/artsy-collect-and-bid-on-fine-art-design/id703796080?mt=8">Artsy iOS app</a> is a mix of Objective-C, Swift and React Native. Objective-C and Swift continue to provide a lot of over-arching cross-View Controller code. While individual representations of Artsy resources tend to be built in React Native. All of our React Native code uses Relay to handle API integration. This <a href="https://github.com/artsy/eigen">code is open-source</a>.</p>

<p>You can also find Artsy on <a href="http://alexa.artsy.net">Alexa</a> and <a href="http://assistant.artsy.net">Google Home</a>, which are both open-source Node.js applications. There is also an open-source <a href="https://github.com/artsy/emergence/">Apple TV</a> app built in Swift.</p>

<p>Our core API serves the public facets of our product, many of our own internal applications, and even <a href="https://developers.artsy.net">some of your own projects</a>. It's built with <a href="https://www.ruby-lang.org/en">Ruby</a>, <a href="http://rack.github.io">Rack</a>, <a href="http://rubyonrails.org">Rails</a>, and <a href="https://github.com/intridea/grape">Grape</a> serving primarily JSON. The API is hosted on <a href="http://aws.amazon.com/opsworks">AWS OpsWorks</a> and retrieves data from several <a href="http://www.mongodb.com">MongoDB</a> databases hosted with <a href="https://www.compose.io">Compose</a>. It also uses <a href="http://memcached.org">Memcached</a> for caching and <a href="https://redis.io">Redis</a> for background queues with <a href="https://github.com/mperham/sidekiq/">Sidekiq</a>. It runs background jobs with <a href="https://github.com/collectiveidea/delayed_job">delayed_job</a>. We used to employ <a href="http://lucene.apache.org/solr">Apache Solr</a> and even <a href="https://www.google.com/cse">Google Custom Search</a> for the many search functions, but have since consolidated on <a href="https://www.elastic.co">Elasticsearch</a>.</p>

<p>Most modern code for both the website and the iOS app use an orchestration layer which is powered by <a href="http://graphql.org">GraphQL</a> to streamline their data fetching and reduce front-end complexity. Our GraphQL server is an <a href="http://expressjs.com">Express</a> app, using <a href="https://github.com/graphql/express-graphql">express-graphql</a> to provide a single API end-point. The API does not access our data directly, but forwards requests to the core API or other services. We have been migrating shared display logic into the GraphQL server, to make it easier to build consistent clients. This <a href="https://github.com/artsy/metaphysics">code is open-source</a>.</p>

<p>Consistently, our front-end code <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/">has moved towards</a> using React across all platforms along with introducing stricter JavaScript languages like TypeScript over CoffeeScript in order to provide better tooling.</p>

<p>We continue to have a <a href="https://developers.artsy.net">public HAL+JSON API</a> for external developers. This API is in active use for contemporary production services inside Artsy and the <a href="https://github.com/artsy/doppler">website is open-source</a>, too.</p>

<center>
 <img src="/images/tech-2017/languages.svg" style="width:100%;">
</center>


<a name="Partner-Facing"></a>
<h2>Partner-Facing</h2>

<p>The vast customer-facing business is powered by a Content Management System (CMS) for gallery and institutional partners. This CMS lets them upload and manage gallery shows, fair booths, create artists, and edit artwork metadata. All CMS components talk to our core API. We also have a number of CMS-like internal applications to manage partners, auctions, art genomes, configuring fairs or performing recurrent billing (we use Stripe for storing and charging credit cards and ACH) with invoicing.</p>

<p>CMS applications are based on stable, mature technologies like <a href="http://rubyonrails.org">Rails</a>, <a href="http://getbootstrap.com">Bootstrap</a>, <a href="https://github.com/turbolinks/turbolinks">Turbolinks</a> and <a href="http://coffeescript.org">CoffeeScript</a>, and gradually adopts modern client-side technologies like <a href="https://facebook.github.io/react">React</a> and <a href="http://browserify.org">Browserify</a>. They share a lot of common infrastructure.</p>

<p>We have a generic image-processing service in-house, which uses <a href="http://rubyonrails.org">Rails</a>, <a href="https://github.com/mperham/sidekiq/">Sidekiq</a>, <a href="https://redis.io">Redis</a>, and <a href="https://github.com/rmagick/rmagick">RMagick</a> with <a href="http://www.imagemagick.org/script/index.php">ImageMagick</a>. It receives image processing requests from many Artsy applications and generates thumbnails, tiles and watermarks images on S3.</p>

<a name="Collector-Facing"></a>
<h2>Collector-Facing</h2>

<p>Collectors inquire on artworks and engage in conversations with partners. For this purpose we have built a generic messaging system that manages communications between different parties. It receives messages via API or e-mail, finds or creates a conversation based on the recipients and forwards them to the proper addresses in that conversation. Its doesn't assume anything about the contents of the messages, which makes it a generic system for any type of conversation. The conversations surface to our partners via CMS.</p>

<a name="Running.Auctions"></a>
<h2>Running Auctions</h2>

<p>The Auctions business began with doing the occasional benefit auctions for charities. Most of these auctions are online-only, timed sales. The initial version of our auction systems came together before we began our move to microservices, and so it is baked into our core API. Last year, we launched a live auction integration product to allow users to bid on works at commercial sales at the actual auction house sale rooms. The real-time requirements of this system required a rethinking of how we process our bids.</p>

<p>The core API for a commercial auction is a Scala micro-service that uses <a href="http://akka.io">Akka</a> for distributed computing. It stores information in an append-only storage engine, based on Akka Persistence, with a small library we developed called <a href="https://github.com/artsy/atomic-store">atomic-store</a>. Communication with external clients can either be done via a REST API, or via WebSockets. People visiting a Live Auction on the web are interacting with a <a href="https://medium.com/@mjackson/universal-javascript-4761051b7ae9#.ev1yd3juy">universal</a> <a href="https://facebook.github.io/react">React</a>+<a href="http://redux.js.org">Redux</a> JavaScript app, served from an <a href="http://expressjs.com">Express</a> server. Bidders visiting a Live Auction on iOS are interacting with a Swift application built with <a href="https://github.com/JensRavens/Interstellar">Interstellar</a>, <a href="https://github.com/daltoniam/starscream">Starscream</a> and <a href="https://github.com/SwiftyJSON/SwiftyJSON">SwiftyJSON</a>.</p>

<p>A more detailed overview of the Auctions stack can be found in <a href="/blog/2016/08/09/the-tech-behind-live-auction-integration">The Tech Behind Live Auction Integration</a>.</p>

<a name="Publishing"></a>
<h2>Publishing</h2>

<p>Our in-house editorial team and partners use an <a href="https://github.com/artsy/positron">open-source</a> platform called "Writer" (which we've built) to publish rich content across the web. Writer is split in two parts: the editorial-focused CMS and a JSON API that stores and distributes content separately from the rest of Artsy's stack.</p>

<p>Writer's frontend is built with <a href="https://github.com/artsy/ezel">Ezel.js</a>, which is a boilerplate for <a href="http://backbonejs.org">Backbone</a> projects running on <a href="https://nodejs.org">Node</a> and using <a href="http://expressjs.com">Express</a> and <a href="http://browserify.org">Browserify</a>. We also heavily use <a href="https://facebook.github.io/react">React</a> and write in <a href="http://coffeescript.org">CoffeeScript</a>. Writer's backend exposes <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>-based and <a href="http://graphql.org">GraphQL</a> APIs that are consumed by our applications.</p>

<p>You can see Writer being put to work when you see articles on <a href="https://www.artsy.net">www.artsy.net</a>, Facebook Instant Articles, Google AMP, RSS, Apple News, and email. We handle the distribution and display in all of these channels. We also support brand sponsorship deals and produce front-end heavy projects such as <a href="https://www.artsy.net/2016-year-in-art">Year in Art 2016</a>, and <a href="https://www.artsy.net/article/artsy-editorial-2015-the-year-in-art">Year in Art 2015</a>.</p>

<a name="Data.Pipeline"></a>
<h2>Data Pipeline</h2>

<p>Data generally flows from consumer applications and services into <a href="https://aws.amazon.com/redshift">AWS RedShift</a>. We use a set of <a href="https://github.com/ruby/rake">rake</a> tasks run on <a href="https://wiki.jenkins-ci.org/display/JENKINS/Build+Flow+Plugin">Jenkins</a> to move data from our several MongoDB and PostgreSQL databases to Redshift via <a href="https://aws.amazon.com/s3">S3</a>. These rake tasks shell out to <a href="https://www.postgresql.org/docs/9.3/static/sql-copy.html">psql</a> or <a href="https://docs.mongodb.com/manual/reference/program/mongoexport">mongo-export</a> to generate CSV files for a list of services and upload them to an S3 bucket, then load those CSV files plus others found in that bucket (placed there by other services) into Redshift. If a <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html">Redshift copy</a> fails due to data changes we sample the CSV and generate a working schema from its contents.</p>

<p>We also store application usage data provided by <a href="https://segment.com/warehouses">Segment Warehouses</a> as well as data from vendors such as <a href="https://www.salesforce.com">Salesforce</a> and <a href="http://www.sailthru.com">Sailthru</a>.</p>

<p>For production data processing (such as recommendations), large-scale machine learning or even simpler parallel processing such as generating website sitemaps, we have our own Hadoop cluster configured and managed by <a href="https://www.cloudera.com/products/product-components/cloudera-manager.html">Cloudera Manager</a> and running on EC2. We leverage <a href="http://spark.apache.org">Apache Spark</a> and <a href="https://www.cloudera.com/products/open-source/apache-hadoop.html">Hadoop</a> with some <a href="http://oozie.apache.org">Ooozie</a> workflow scheduling. The same data pipeline that writes data to S3 also pumps data to HDFS with either Ruby code or <a href="http://sqoop.apache.org">Sqoop</a> and is read by Spark jobs written in Scala using <a href="https://hive.apache.org">Hive</a>. Spark has improved performance and capacity tenfold over our older in-house systems and we will be moving all lengthy processing implemented in Ruby to this system gradually.</p>

<a name="Analytics"></a>
<h2>Analytics</h2>

<p>For general data access and dashboards we rely on <a href="https://looker.com">Looker</a>. This system empowers all non-engineers to access all of our data. At the time of writing, there are 50 users running 3,500 queries a day against Redshift via Looker. We've found it expedient to pre-compute common denormalized views, and to create our own session rollups from raw pageviews and events for the additional flexibility it gives us in understanding user behavior.</p>

<p>For more in-depth work, we use <a href="https://ipython.org/notebook.html">Jupyter Notebooks</a> to connect to our Redshift cluster and by default import <a href="http://pandas.pydata.org">pandas</a>, <a href="http://scikit-learn.org/stable">sci-kit learn</a>, and <a href="http://matplotlib.org/api/pyplot_api.html">pyplot</a> for data analysis.</p>

<a name="Search"></a>
<h2>Search</h2>

<p>We completed our full migration from <a href="http://lucene.apache.org/solr">Solr</a> to <a href="https://www.elastic.co">Elasticsearch</a> in the last 18 months, and now use Elasticsearch across all front-ends. This ranges from our artwork filter interfaces through to our real-time artwork similarity features. Elasticsearch gives us high availability clustering features out of the box and easy horizontal scaling on demand.</p>

<a name="Platform.Services"></a>
<h2>Platform Services</h2>

<p>As Artsy's business has grown more complex, so has the data and concepts handled by its core API. We've begun supporting certain product areas with separate, dedicated API services, and even extracting existing API domains into separate services when practical. These services tend to expose simple <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>-ful HTTP APIs, maintain separate data sources, and even do their own <a href="/blog/2016/10/26/jwt-artsy-journey">authentication</a>. This has certain advantages:</p>

<ul>
<li>Each system can be deployed and scaled independently.</li>
<li>Each chooses the best-suited languages and technologies for its purpose.</li>
<li>Code bases remain more focused and developers' cognitive overhead is minimized.</li>
</ul>


<p>Balancing these out are some very real disadvantages:</p>

<ul>
<li>Development must sometimes touch multiple systems.</li>
<li>Some data is copied between services. These can become out-of-sync, though we always try to have a single <em>authoritative</em> source in such cases.</li>
<li>Deploys must be coordinated.</li>
</ul>


<p>At our size and complexity, a single code base is simply impractical. So, we've tried to be consistent in the coding, deployment, monitoring, and logging practices of these services. The more repeatable and disciplined our process, the less overhead is introduced by additional systems.</p>

<p>We've also explored alternate communication patterns, so systems aren't as dependent on each other's APIs. Recently we've begun publishing a stream of data events from our core systems that other systems can consume. Other systems can simply subscribe to the notifications they care about, so the source system doesn't need to be concerned about integrating with one more destination. After experimenting with <a href="https://kafka.apache.org">Kafka</a> but finding it hard to manage, we switched to <a href="https://www.rabbitmq.com">RabbitMQ</a> for this purpose. To provide consistency when publishing events we have <a href="https://github.com/artsy/artsy-eventservice">our own gem</a>.</p>

<a name="Operations"></a>
<h2>Operations</h2>

<p>All our recent AWS infrastructure is configured in code using <a href="https://www.terraform.io">Terraform</a>. This approach has allowed us to quickly replicate entire deployments along with their dependencies and has increased visibility into the state of our infrastructure across our teams. We started developing an open source <a href="https://www.docker.com">Docker</a> workflow toolkit named <a href="https://github.com/artsy/hokusai">Hokusai</a> in order to manage a containerized workflow, CI and deployment to <a href="https://kubernetes.io">Kubernetes</a>. Our Kubernetes clusters are managed using <a href="https://github.com/kubernetes/kops">Kops</a> and similarly provisioned using Terraform. This new workflow is reducing our dependence on Heroku, giving us more flexibility in our deployments and a more efficient use of server resources.</p>

<a name="Closing.Remarks"></a>
<h2>Closing Remarks</h2>

<p>Like any attempts at mapping something as large as the daily work for a thirty-ish person engineering team, <a href="https://en.wikipedia.org/wiki/Map%E2%80%93territory_relation">the map is not the territory</a>. However, the exploration is worth the time it takes to keep notes for reading again in the next two years.</p>

<p>If you're interested in helping us make this an even longer post in two more years, or <em>more interestingly</em> shorter - we nearly always have a <a href="https://www.artsy.net/jobs">position open for engineers</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploration: Front-end JavaScript at Artsy in 2017]]></title>
    <link href="http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/"/>
    <updated>2017-02-05T12:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017</id>
    <content type="html"><![CDATA[<center>
 <img src="/images/js2017/js.svg" style="width:300px;">
</center>


<p>The Artsy web team have been early adopters of node, and for the last 4 years the stable stack for the Artsy website has been predominantly been Node + CoffeeScript + Express + Backbone. In 2016 the mobile team <a href="/blog/2016/08/15/React-Native-at-Artsy/">announced</a> that it had moved to React Native, matching the web team as using JavaScript as the tools of their trade.</p>

<p>Historically we have always had two separate dev teams for building Artsy.net and the corresponding iOS app, we call them (Art) Collector Web, and Collector Mobile. By the end of 2016 we decided to merge the teams. The merger has given way to a whole plethora of ideas about what contemporary JavaScript looks like and we've been experimenting with finding common, natural patterns between web and native.</p>

<p>This post tries to encapsulate what we consider to be our consolidated stack for web/native Artsy in 2017.</p>

<p><strong>TLDR:</strong> <a href="#TypeScript">TypeScript</a>, <a href="#GraphQL">GraphQL</a>, <a href="#React...React.Native">React/React Native</a>, <a href="#Relay">Relay</a>, <a href="#Yarn">Yarn</a>, <a href="#Jest">Jest</a>, and <a href="#Visual.Studio.Code">Visual Studio Code</a>.</p>

<!-- more -->


<a name="Overview"></a>
<h2>Overview</h2>

<p>Our web stack has been <a href="/blog/2013/11/30/rendering-on-the-server-and-client-in-node-dot-js/">ezel.js</a> since 2013, and continues to be a mature and well thought out technology. Since then, there has been explorations on a successor to that framework using React and GraphQL with <a href="https://github.com/muraljs/mural">muraljs</a>. However, since the merger, a lot more of our focus has been on trying to find something that feels similar on both React and React Native.</p>

<center>
 <img src="/images/js2017/ts.svg" style="width:300px;">
</center>


<a name="TypeScript"></a>
<h2>TypeScript</h2>

<p><a href="http://www.typescriptlang.org">TypeScript</a> and <a href="https://flowtype.org/">Flow</a> really moved JavaScript forwards in the last few years. They both tackle the essential problems of "how can I trust my code does what I think", "how can I be sure of this change" and "how can I build better tools for JavaScript" in different ways.</p>

<p>Yes, the title of this section is TypeScript and yet I instantly include Flow. I don't think you can, or should talk about TypeScript without understanding it's relationship to Flow.</p>

<p>Both <a href="http://www.typescriptlang.org/play/#src=function%20addNumbers(first%3A%20number%2C%20second%3A%20number)%20%7B%0D%0A%09return%20first%20%2B%20second%0D%0A%7D%0D%0A%0D%0AaddNumbers(1%2C%202)%0D%0A">TypeScript</a> and <a href="https://flowtype.org/docs/five-simple-examples.html#adding-type-annotations">Flow</a> provide a structure for applying Types to JavaScript.</p>

<p>Both <a href="http://www.typescriptlang.org/play/#src=var%20one%20%3D%201%0D%0A%0D%0Aone%20%3D%20%22%22%0D%0A">TypeScript</a> and <a href="https://flowtype.org/docs/classes.html#type-annotations-vs-inference">Flow</a> will infer typing metadata from untyped data.</p>

<p>Both <a href="https://www.npmjs.com/%7Etypes">TypeScript</a> and <a href="https://github.com/flowtype/flow-typed">Flow</a> have systems for applying types to node modules.</p>

<p>We initially went with Flow, as Flow is a <a href="https://discuss.reactjs.org/t/if-typescript-is-so-great-how-come-all-notable-reactjs-projects-use-babel/4887">considerably easier sell</a> to others, as it integrates inside existing JavaScript projects with less issues. Flow acts as a separate tool to a babel-based JavaScript project, whereas TypeScript is a full on replacement for that tooling.</p>

<p><em>Why bother though?</em> JavaScript has existed for decades without type annotations, and everyone seems to have got on pretty well. One of the key features that a typing system gives you is top-notch tooling. An editor can use the type interfaces to provide auto-completion, inline documentation and inline warning/errors as you work. Type systems will help catch errors before you have even pressed save.</p>

<p></article>
<a href='/images/js2017/types.png' style="">
  <img src="/images/js2017/types.png" alt="The Artsy Tech Stack 2017" style="width:100%;">
</a>
<article class="post">
</p>

<p>What works really well for typed JavaScript is that you can easily opt out of it when you need to. Then you're back to normal "do whatever you want" JavaScript land, no problem.</p>

<p>We moved from Flow simply because TypeScript had better integration with <a href="https://code.visualstudio.com">Visual Studio Code</a> (VS Code). For a few months I devoted time to improving the Flow integration in VS Code, and tried learning OCaml to help out on the <a href="https://github.com/facebook/flow">Flow tool</a> itself. In the end though, when we compared to how solid VS Code felt with TypeScript - we decided it was worth converting our projects.</p>

<p>Both TypeScript and Flow provide nearly every Type structure found inside Objective-C and Swift, so teaching the rest of the team how they work is easy from our native experiences.</p>

<p><a name="TypeScript-Extension"></a>One particularly interesting part of TypeScript that we are keeping our eyes on is this <a href="https://github.com/Microsoft/TypeScript/issues/6508">language extensibility issue</a>, if it turns out well, we will be looking into integrating the other technologies mentioned here into TypeScript itself.</p>

<center>
 <img src="/images/js2017/graphql.svg" style="width:300px;">
</center>


<a name="GraphQL"></a>
<h2>GraphQL</h2>

<p>GraphQL is a way to handle API requests. I consider it the successor to REST when working with front-end clients. A big claim, yeah. So, what is it?</p>

<p>Officially <a href="https://github.com/facebook/graphql">GraphQL is a specification</a>. A server can conform to the GraphQL spec, and then clients can make queries against it. Think of it a bit like how SQL is a standardized way of doing database queries across multiple databases types.</p>

<p>As a client, you <a href="https://github.com/artsy/eigen/blob/dac7c80b66b600f9a45aaae6095544fe420f0bbc/Artsy/Networking/ARRouter.m#L1011">send</a> a "<a href="http://graphql.org/docs/getting-started/#queries">JSON-shaped query</a>" structure, which is hierarchical and easy to read:</p>

<pre><code class="json">{
  artwork(id: "kimber-berry-as-close-to-magic-as-you-can-get") {
    id
    additional_information

    is_price_hidden
    is_inquireable
  }
}
</code></pre>

<blockquote><p>This will search for a <a href="https://www.artsy.net/artwork/kimber-berry-as-close-to-magic-as-you-can-get">specific artwork</a>, with the response JSON as the Artwork's <code>id</code>, <code>additional_information</code>, <code>is_price_hidden</code> and <code>is_inquireable</code>.</p></blockquote>

<p>It's important to note here, the data being sent <em>back</em> is specifically  what you ask for. This is not defined on the server as a <em>short</em> or <em>embedded</em> version of a model, but the specific data the client requested. When bandwidth and speed is crucial, this is the other way in which GraphQL vastly improves an app-user's experience.</p>

<p>This is in stark contrast to other successors to REST APIs, the hypermedia APIs, like <a href="http://stateless.co/hal_specification.html">HAL</a> and <a href="http://jsonapi.org">JSON-API</a> - both of which are optimised for caching, and rely on "one model, one request" types of API access. E.g. a list of Artworks would actually contain a list of hrefs instead of the model data, and you have to fetch each model in a separate request.</p>

<p>Hypermedia APIs have a really useful space in cross-server communications, but are extremely wasteful of the most precious resource for a front-end device - bandwidth. <a href="latency">Latency matters considerably</a>, on mobile where bandwidth is spotty, and attention spans are short you need to do everything possible to show more than a loading spinner.</p>

<p>I have previously explored our usage of GraphQL from the perspective of a native developer <a href="/blog/2016/06/19/graphql-for-mobile/">in 2016</a>. So I'll leave that post to describe our implementation of a GraphQL server.</p>

<p>One exciting movement in the space of GraphQL is <a href="https://githubengineering.com/the-github-graphql-api/">GitHub moving to GraphQL</a> for their new APIs.</p>

<center>
 <img src="/images/react-native/artsy_react_logo.svg" style="width:300px;">
</center>


<a name="React...React.Native"></a>
<h2>React / React Native</h2>

<p>React is a Facebook project which offers a uni-direction Component model that <em>can</em> replace MVC in a front-end application. React was built out of a desire to abstract away a web page's true view hierarchy (called the DOM) so that they could make changes to the view in memory and then React would handle finding the differences between view states.</p>

<p>You create a set of Components to encapsulate each part of the state of the page. React makes it easy to make components that are functional in the <a href="https://en.wikipedia.org/wiki/functional_reactive_programming">Functional Reactive Programming</a> sense. They act like a function which takes some specially declared state and it is rendered into HTML.</p>

<p>A component optionally uses a language called <a href="#jsx">JSX</a> to visualise how each component's child components are set up, here's an example of a React component using JSX <a href="https://github.com/artsy/emission/blob/c558323e4276699925b4edb3d448812005ae6b5d/lib/components/home/search_bar.js">from Emission, our React Native library</a>:</p>

<pre><code class="js">export default class SearchBar extends React.Component {
  render() {
    return (
      &lt;TouchableWithoutFeedback onPress={this.handleTap.bind(this)}&gt;
        &lt;View style={styles.container}&gt;
          &lt;Image style={styles.searchIcon} source={require('../../../images/SearchButton.png')}/&gt;
          &lt;Text style={styles.text}&gt;Search for artists and artworks...&lt;/Text&gt;
        &lt;/View&gt;
      &lt;/TouchableWithoutFeedback&gt;
    )
  }

  handleTap() {
    Switchboard.presentModalViewController(this, '/search')
  }
}
</code></pre>

<p>By providing a well encapsulated Component model, you can aggressively reduce the amount of redundant code you need to build an application. By not initially writing to the DOM, React can decide what has changed between user actions and that means you have to juggle significantly less state.</p>

<p>We can then build on React via React-Native to allow the same style of code to exist inside the mobile sphere, where typically you have had unique languages and tooling.</p>

<p>React Native is an implementation of React where instead of having React's virtual DOM map to a web page's DOM, it creates a native view hierarchy. In the case of iOS that is a <code>UIView</code> hierarchy, and in Android, a <code>View</code> hierarchy.</p>

<p>If you'd like to find out why the iOS team moved to React Native, check our <a href="/series/react-native-at-artsy/">series of posts on React Native</a>.</p>

<center>
 <img src="/images/js2017/relay.svg" style="width:300px;">
</center>


<a name="Relay"></a>
<h2>Relay</h2>

<p>Any front-end client has a lot of work to do on every page:</p>

<ul>
<li>Fetching all the data for a view hierarchy.</li>
<li>Managing asynchronous state transitions and coordinating concurrent requests.</li>
<li>Managing errors.</li>
<li>Retrying failed requests.</li>
<li>Updating the local cache after receiving new results/changes the server objects responses.</li>
<li>Optimistically updating the UI while waiting for the server to respond to mutations.</li>
</ul>


<p>This is typically handled in a per-page basis, for example the API details, and state management between a Gene page, and an Artist page are different. In part because they have different data-models, but also that they have different correlated data. However, they do share a lot of the common responsibilities mentioned above. In our native side, we struggled to find abstractions that would work across multiple pages. Relay fixes this, and does it in a shockingly elegant way.</p>

<p>Relay is a framework for building data-driven React apps which relies on a deep connection to GraphQL. You wrap your React components inside a Relay container, which handles the networking and setting the state for your component.</p>

<pre><code class="js">// This is a normal React component, taken directly from our app
// It will optionally show a description if one exists on a gene.

class Biography extends React.Component {
  render() {
    const gene = this.props.gene
    if (!gene.description) { return null }

    return (
      &lt;View&gt;
        &lt;SerifText style={styles.blurb} numberOfLines={0}&gt;{gene.description}&lt;/SerifText&gt;
      &lt;/View&gt;
    )
  }
}

// Take the above component `Biography`, and wrap it with a Relay Container.
// Then provide what parts of a GraphQL request the `Biography` needs

export default Relay.createContainer(Biography, {
  fragments: {
    gene: () =&gt; Relay.QL`
      fragment on Gene {
        description
      }
    `,
  }
})

// When the `Biography` component is rendered, the component is given props of 
// `gene` with a `description` by the Relay container. 
</code></pre>

<p>Relay handles this by having each component in your view hierarchy exposing the fragments of a GraphQL query. There is a pre-render stage where all of your components fragments are brought together to make a single API request. So in the case of the Gene, it may look something like:</p>

<pre><code class="json">{
  gene(id: "the-fantastic") {
    // could have come from the root component's fragment
    id
    name 

    // came from the above Header fragment
    description 

    // could have come from a RelatedArtists component's fragment
    trending_artists {
      name
      href
    }
  }
}
</code></pre>

<p>The data is first looked up inside Relay's local cache, and then any un-cached items are requested from the network. The results of the query is then moved into the component via it's props. Relay will only provide the specific data each component has requested. So the <code>Header</code> component would get nothing for <code>this.props.gene.name</code>. This data-masking is a great way of ensuring the connection between component and API.</p>

<p>I'd strongly recommend taking the dive into both the <a href="https://facebook.github.io/relay/docs/thinking-in-graphql.html">Thinking with GraphQL</a> and then <a href="https://facebook.github.io/relay/docs/thinking-in-relay.html">Thinking with Relay</a> tutorials to learn more. Finally, <a href="https://www.learnrelay.org">Learn Relay</a> and <a href="https://sgwilym.github.io/relay-visual-learners/">Relay for Visual Learners</a> are great tutorials to help you get comfortable with the concepts.</p>

<center>
 <img src="/images/js2017/yarn.svg" style="width:300px;">
</center>


<a name="Yarn"></a>
<h2>Yarn</h2>

<p>I have a lot of respect for NPM, their scale is <a href="http://blog.npmjs.org/post/143451680695/how-many-npm-users-are-there">through the roof</a>. They built out the foundations for a massive, thriving community. They did a great job. Like a lot of the JavaScript ecosystem, their tooling allows you to get away with a lot of things. You can have the same dependency inside the app with multiple versions, or apps with a dependency tree that is different each time you run <code>npm install</code>.</p>

<p>We have multiple engineers who have worked on a dependency manager for half a decade, having indeterminate builds in JavaScript was something that worried us greatly. Luckily, there is <a href="https://yarnpkg.com">Yarn</a>.</p>

<p>Yarn is a Facebook project that replaces the NPM <a href="https://en.wikipedia.org/wiki/Command-line_interface">cli</a> client. It's very new, so unlike NPM it does not have to worry about backwards compatibility. It is what I'd imagine a fresh re-write of the NPM cli would look like.</p>

<p>Yarn is significantly faster, has a determinate process for setting up projects and uses a lockfile by default to ensure everyone using the project gets the exact same dependency tree. It uses NPM as a server, and so you get the same node modules as with the NPM cli.</p>

<p>Sometimes Yarn gives you pleasant surprises too, my favourite being that <code>yarn [x]</code> will check to see if that is a local command that you could run, saving a bunch of redundant settings.</p>

<p>Converting a codebase can be as simple as going into your project and running:</p>

<pre><code class="sh">npm install -g yarn
yarn install
</code></pre>

<p>Now you have a lockfile, and are using yarn. Awesome, if you are migrating from a project with a shrink-wrap - I have a script which will generate a summary of the changes for you: <a href="https://gist.github.com/orta/cb6d0b8256852c1f01ecf1d803b664c9">script</a>, <a href="https://github.com/artsy/metaphysics/pull/479">example</a>.</p>

<center>
 <img src="/images/js2017/jest.svg" style="width:300px;">
</center>


<a name="Jest"></a>
<h2>Jest</h2>

<p>One of the things that I find particularly pleasant about the JavaScript ecosystem are their testing tools. With our React Native, we came into the ecosystem with fresh eyes, and it was pretty obvious that Jest was an exceptional testing framework. I hear historically Jest has been a bit meh, but it is without a doubt worth another look.</p>

<p><strong>The watcher</strong> - The majority of your usage of Jest is with it running in watcher mode. This mode uses your git diff as a seed for what to run tests against. Jest will use that diff to define all the files that the changed code touches, and then all of the tests that cover those files.</p>

<p>For example, I make a change in one source file and 60 tests run from 6 different test suites. Finishing in under a second.</p>

<p></article>
<a href='/images/js2017/jest-watcher.gif' style="">
  <img src="/images/js2017/jest-watcher.gif" alt="Jest's awesome watch mode" style="width:100%;">
</a>
<article class="post">
</p>

<p>Not all tests are as important to a run, so Jest also keeps track of which tests failed last time and will run those first next time. This reduces iteration time considerably.</p>

<p><strong>Fast and safe</strong> - You think the watcher is smart? Well the way Jest handle test suites is also extremely elegant. Jest keeps track of how long each test suite took to run, and then will weigh the test suites across different processes in order to speed up the overall test suite. If Jest thinks they're all going to be really quick (like my GIF above) they will all happen in one process, as that can also be faster.</p>

<p>Each test suite is an entirely sandboxed node virtual machine, so you cannot have tests influencing each other.</p>

<p><strong>Snapshots</strong> - Jest provides a concept called snapshots, which provides an easy way to compare JavaScript objects. One place where this really shines is with React components. <a href="https://github.com/artsy/emission/blob/ec565b8492540b4e33066364b415c7906ec1e028/lib/containers/__tests__/gene-tests.js#L121-L158">For example</a>:</p>

<pre><code class="js">it('looks like expected', () =&gt; {
  const props = {
      gene:{...}
    }

  const tree = renderer.create(
    &lt;Gene geneID={props.gene.name} medium="painting" price_range="*-100000" gene={props.gene}/&gt;
  ).toJSON()

  expect(tree).toMatchSnapshot()
})
</code></pre>

<p>Now we will get a test failure when any changes happen in the component tree. For example, if I changed the background color to <code>blue</code> from <code>white</code>. I get a fail like this:</p>

<p><img src="/images/js2017/jest-snapshots.png" style="width:100%"></p>

<p>While that example is trivial, we really want to have tests like this to ensure we understand how changes propagate throughout the app.</p>

<p><strong>No config</strong> - When we first integrated Jest, we had no config. Now, to make sure that TypeScript works how we'd like, we require some setup. However, having smart defaults which works in most cases say a lot about the care and attention paid to Developer Experience from the Jest team. The documentation covers default integrations for: Babel, TypeScript and webpack. Three of the biggest modern tools for getting stuff done with node.</p>

<p><strong>Comprehensive API</strong> - Snapshots, watchers, custom matchers, useful JSON output, ESLint linters, Elegant Mocking tools and natural support for async code. All in one project.</p>

<p>If you're interested, there is a lot of work around automating the migration between different testing frameworks in <a href="https://github.com/skovhus/jest-codemods">jest-codemods</a> - getting started has never been easier. I'd also recommend looking at <a href="https://wallabyjs.com">wallaby.js</a> and <a href="https://github.com/orta/vscode-jest">vscode-jest</a> for tooling.</p>

<center>
 <img src="/images/vscode/vscode_logo_artsy.svg" style="width:300px;">
</center>


<a name="Visual.Studio.Code"></a>
<h2>Visual Studio Code</h2>

<p>Had you told me two years ago that my main editor would be a JavaScript app, I'd have bought you a beer for such a great joke.</p>

<p>Visual Studio Code was the app that changed my mind.</p>

<p>I've done a longer write up on the how and why we use VS Code in <a href="/blog/2016/08/15/vscode/">JavaScript projects</a>, however here I'd like to consider the cultural aspect of the choice. It's common practice among web technologists to all have different editors on a project, and for their editors to generally do little work for them. A lot of this culture came from the TextMate and Rails days with the infamous <a href="https://twitter.com/dhh/status/492706473936314369?lang=en">blog in 15 minutes video</a>. When I was a web developer, I also did this.</p>

<p>When you spend a lot of time in a <a href="https://developer.apple.com/xcode/">powerful IDE</a>, it gets pretty hard to go back to a bare-bones editor. VS Code sits at a good (just past) half-way point between text editor and IDE. You can get a lot of the flexibility from a text editor, making it good for one off files and IDEs where you have fully spec'd out projects.</p>

<p>Being able to have project specific setups is where VS Code really starts to shine. One thing that is working well for us is to gradually add project settings for our apps, first we add the ability to run tests with an attached debugger by adding a <code>launch.json</code>:</p>

<pre><code class="json">{
    "name": "Run Tests With Debugger (slower, use yarn for normal work)",
    "type": "node2",
    "request": "launch",
    "port": 5858,
    "address": "localhost",
    "sourceMaps": true,
    "stopOnEntry": false,
    "runtimeExecutable": null,
    "runtimeArgs": [
      "--debug-brk",
      "./node_modules/.bin/jest",
      "-i"
    ],
    "cwd": "${workspaceRoot}"
}
</code></pre>

<p>With this we can showcase how easy it is to use an inline debugger with source-maps, when working with tricky test logic. No more <code>console.log</code>. That's usually a great way to start moving everyone to a consistent environment. Then we add <a href="https://code.visualstudio.com/updates/v1_6#_workspace-extension-recommendations">recommended extensions</a> to the project.</p>

<p>Trying to set a consistent  development environment might sound a bit corporate for a ~25 person dev team, but one chief advantage is that you can feel comfortable taking time at work to improve your tooling knowing it will improve the tooling of everyone else on your team.</p>

<p>I've been exploring a consolidated <a href="https://github.com/artsy/vscode-artsy">Artsy VS Code</a> extension to handle extension dependencies and small tasks, but it's still early days. It's awesome that I can even think at that level of abstraction though.</p>

<a name="End"></a>
<h3>End</h3>

<p>None of these technologies are under a year old, all of them have adoption by substantial amount of companies. Nothing feels  either controversial or novel. This is great. It feels like a lot of the interesting work for us so far has been around improving the spaces between the projects: Finding improvements for generating types <a href="https://github.com/avantcredit/gql2ts/blob/master/Changelog.md">from GraphQL</a> or <a href="https://github.com/alloy/relay2ts">Relay</a>, adding <a href="https://github.com/facebook/jest/commit/e597e5c46f8f4925d9a10c73d8eab05a2c4b8bc3">editor support to jest</a>, adding Danger to <a href="https://github.com/facebook/jest/pull/2508">our dependencies</a> and improving our <a href="https://github.com/orta/vscode-react-native-storybooks">tooling</a> <a href="https://github.com/orta/vscode-jest">for</a> <a href="https://github.com/alloy/vscode-relay">vscode</a>. The front-end is still a pretty small dev team, so we want to do high impact, small projects that can make our tools drastically better.</p>

<p>React, React-Native, Jest, Yarn are all big Facebook projects. In the iOS world, there is a sense of wariness around building an app so heavily around Facebook tech, based on <a href="http://joehewitt.com/2009/03/23/the-three20-project">three20</a> - which I think is a bit unfair. From my perspective, determining whether you should have something as a dependency <a href="/blog/2015/09/18/Cocoa-Architecture-Dependencies/">should be nuanced</a>, but at a minimum you should feel like you can contribute bug fixes and ideally you should be able to maintain the project if it needs it. With Facebook projects, they've shown to be really open to PRs and discussion, and our work in them makes us feel comfortable to maintain a fork if needed.</p>

<p>We're still exploring the space where we can share code between web and mobile. I'd like to hope within a few months we can write up how that is going on. For now, if you're interested in prototypes, we've been moving our React Native components to the web inside <a href="https://github.com/alloy/relational-theory/">Relational Theory</a> and <a href="https://github.com/orta/systems-theory/">Systems Theory</a> tries bringing new ideas from Relational Theory back to React Native.</p>

<p>I have grown to love working with typed JavaScript to ensure soundness, with React and Relay to drastically reduce the amount of code we need to write and to provide awesome root abstractions to build on. Mix that with a hackable editor with substantial language support and it feels like almost exclusively writing business domain logic.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Helping the Web Towards OSS by Default]]></title>
    <link href="http://artsy.github.io/blog/2016/09/06/Milestone-on-OSS-by-Default/"/>
    <updated>2016-09-06T12:17:00+00:00</updated>
    <id>http://artsy.github.io/blog/2016/09/06/Milestone-on-OSS-by-Default</id>
    <content type="html"><![CDATA[<p>The main Artsy.net website for the desktop, <a href="https://github.com/artsy/force">Force</a>, was our first Artsy application to open its source code, <a href="http://artsy.github.io/author/craig">Craig</a> and <a href="http://artsy.github.io/author/brennan">Brennan</a> did it <a href="/blog/2014/09/05/we-open-sourced-our-isomorphic-javascript-website/">back in 2014</a>. Force's public offering laid the groundwork for the iOS OSS projects to come afterwards: <a href="/blog/2014/11/13/eidolon-retrospective/">Eidolon</a>, <a href="/blog/2015/04/28/how-we-open-sourced-eigen/">Eigen</a>, <a href="/blog/2015/08/06/open-sourcing-energy/">Energy</a> and <a href="/blog/2015/11/05/Emergence-Code-Review/">Emergence</a>.</p>

<p>Though Force wasn't quite Open Source by Default, it represented a <em>really</em> important step for  Artsy's OSS perspective but was not the end goal. We were opening our source, but not opening our process.</p>

<p>This month both <a href="https://github.com/artsy/force">Force</a>, the desktop version of <a href="https://www.artsy.net/">Artsy.net</a> and <a href="https://github.com/artsy/microgravity">Microgravity</a>, the mobile version - moved to being built entirely in the open. Read on to find out how.</p>

<!-- more -->


<a name="Force"></a>
<h2>Force</h2>

<p>Over the course of the last month, I've sat on and off with Charles "<a href="http://charlesbroskoski.com/_/">Cab</a>" Broskoski, and figured out what it would take to migrate Force to work in the public. Previous to this, work happened on a private repo, and we would push that code to the public.</p>

<p>We scoped out what it would require, creating an issue that summarized the work. Then we waited for 2 weeks, to give people the chance to discuss the idea and to offer examples for why we should delay or not move. Not all projects <em>should</em> be OSS, and everyone should have a say when it affects them - giving some time let the team speak their mind. Especially during summer, when people were less active at work.</p>

<p></div></div><a href='/images/oss-milestone/force-oss.png'><img src="/images/oss-milestone/force-oss.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>It had been 9 months since the last commit to the public repo, and so auditing the commits was a matter of investigating into configuration files, and seeing what's changed since the last public commit.</p>

<p>Next up, we renamed the current <code>force</code> repo to <code>force-private</code>. This was to keep the old issues and PRs around after we moved to working in the public. With <code>force</code> now available we re-named the already public project.</p>

<p>We then ensured all outstanding PRs were merged or closed, and pushed the commits from <code>force-private</code> to the now OSS <code>force</code>.</p>

<a name="CI"></a>
<h3>CI</h3>

<p>To get back up to speed we needed to set up CI, figuring this out took time.</p>

<p>We got testing up and running in no time. However, Force is deployed via <a href="https://semaphoreci.com/">Semaphore CI</a>, and to deploy we needed to push compiled assets to S3. To pull that off, we needed access to an S3 key, and token.</p>

<p>In our iOS projects, <a href="https://github.com/artsy/eidolon/pull/607">we do not expose environment variables</a> to PRs from forks, so we don't expect them to pass from external contributors. This is fine, because we have <a href="http://artsy.github.io/blog/2016/01/13/OSS-Expectations/">different expectations</a> for OSS apps vs libraries. We do this to ensure that we don't receive a PR that adds <code>printenv</code> to the CI scripts, exposing our secret keys.</p>

<p>As we couldn't add the keys to our testing environment, we added them to our heroku environment then took them from that. Semaphore sets up our heroku environment only during deployment, so in the deployment phase, we can use a line like:</p>

<pre><code class="sh">export FORCE_S3_KEY=$(heroku config:get FORCE_S3_KEY --app force-production)
</code></pre>

<p>This sets up the environment like we used to have it when force was private.</p>

<a name="Team"></a>
<h3>Team</h3>

<p>We needed to move all the team members to using the OSS version of our apps. This is a little bit complicated as <a href="/blog/2012/01/29/how-art-dot-sy-uses-github-to-build-art-dot-sy/">we work from forks</a>. <a href="http://www.anandarooproy.com/portfolio">Roop</a>, an engineer on the web team, created a "Force OSS Dance Script" ( sidenote: <a href="http://www.anandarooproy.com/portfolio">his site</a> is worth a visit, there's 15 years of interesting maps. )</p>

<pre><code class="sh">## RENAME THE OLD REPO

# on GitHub

# - Go to my fork https://github.com/&lt;username&gt;/force
# - Go to Settings tab
# - Rename repo to "force-private"

# on my local machine

mv force force-private
cd force-private
git remote set-url upstream git@github.com:artsy/force-private.git
git remote set-url origin git@github.com:&lt;username&gt;/force-private.git


## FORK AND CLONE THE NEW REPO

# back to GitHub

# - Go to the new Force repo https://github.com/artsy/force
# - Fork it to my account

# back to my local machine

git clone git@github.com:&lt;username&gt;/force.git
cd force
git remote add upstream git@github.com:artsy/force.git
cp ../force-private/.env ./
cp ../force-private/node_modules ./ # or just 'npm install' again


# all good now - both repos on local machine with correct remotes, envs, deps
</code></pre>

<p>For Force, all the same commits existed in both repos, so it would be difficult to push secrets to the open repo by accident. However, individuals did to sync up a new version of their forks.</p>

<p>And that, is how we moved force into OSS by Default. :+1: - We'll cover the issues migration later.</p>

<a name="Microgravity"></a>
<h2>Microgravity</h2>

<p>I have a lot of love for Microgravity. It's the web project that made <a href="/blog/2015/04/28/how-we-open-sourced-eigen/">Eigen</a> possible. Once Force had moved, I started spending time with Craig trying to understand what it would take to open up Microgravity.</p>

<p></div></div><a href='/images/oss-milestone/micrograv-oss.png'><img src="/images/oss-milestone/micrograv-oss.png"></a><div class='meta-container'><header>&nbsp;</header></div><div class='date-container'>&nbsp;</div><div class='content-container'><div class='entry-content'></p>

<p>It is no surprise to find a lot of overlap, both projects are based on the same foundations: <a href="https://github.com/artsy/ezel">Ezel.js</a>.</p>

<p>We didn't trust the commit history for microgravity, so we nuked it. Same as our native OSS apps.</p>

<p>We came up with a pattern to make it easier for people to migrate issues, we created a <code>migrate</code> GitHub label that anyone can apply to an issue in a private repo. Then we use <a href="https://github-issue-mover.appspot.com">Issue Mover for GitHub</a> with some inline JavaScript to loop through all our issues to migrate. As it's applying a label we can ask product owners and designers to choose ones that are important to them too.</p>

<p>--</p>

<p>I love that I got to help make these changes, the web team started the process of opening our apps at Artsy, then the mobile team took the next big step. Now the teams are both in lock-step, and if you work on the front-end at Artsy - OSS by Default is the way we all work now.</p>
]]></content>
  </entry>
  
</feed>
