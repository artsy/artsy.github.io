<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: guest | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/guest/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2024-05-17T14:49:02+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Relay Network Deep Dive]]></title>
    <link href="https://artsy.github.io/blog/2018/07/25/Relay-Networking-Deep-Dive/"/>
    <updated>2018-07-25T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2018/07/25/Relay-Networking-Deep-Dive</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Hey all, we have another guest post, this one comes from <a href="https://github.com/sibelius">Sibelius Seraphini</a> - a very active contributor to
Relay and its eco-system. When we spotted he had wrote an amazing article on how the networking aspects of Relay
comes together, we wanted to expand his reach and inform more people on how Relay comes together.</p>

  <p>– Orta</p>
</blockquote>

<p>Data fetching is a hard problem for apps. You need to ask yourself a lot of questions: How do you ask for data from
a server? How do you handle authentication? When is the right time to request data? How can you ensure you have all
the necessary data to render your views? How can you make sure you’re not over-fetching? Can you do lazy loading?
When should you trigger lazy loading of data? What about pre-fetching data?</p>

<p><a href="https://facebook.github.io/relay/">Relay</a> is a framework for building data-driven applications which handles data fetching for you. For an
introduction to Relay, read <a href="https://facebook.github.io/relay/">their docs</a>, and also check out my Relay talk at <a href="https://speakerdeck.com/sibelius/reactconfbr-is-relay-modern-the-future">React Conf BR</a>.</p>

<blockquote>
  <p>You don’t deep dive if you don’t know how to swim</p>
</blockquote>

<h2 id="tldr-relay-modern-network">TL;DR Relay Modern Network</h2>

<p>Relay will aggregate the data requirements (fragments) for your components, then create a request to fulfill it.
The API to do this is via the <a href="https://facebook.github.io/relay/docs/en/relay-environment.html">Relay Environment</a>:</p>

<blockquote>
  <p>The Relay “Environment” bundles together the configuration, cache storage, and network-handling that Relay needs
in order to operate.</p>
</blockquote>

<p>This post focuses on the “network-handling” part, the <a href="https://facebook.github.io/relay/docs/en/network-layer.html">Network Layer</a>. The network layer’s responsibility
is to make a request to a server (or a local graphql) and return the response data to Relay. Your implementation
should conform to either <a href="https://github.com/facebook/relay/blob/v1.6.0/packages/relay-runtime/network/RelayNetworkTypes.js#L79-L90">FetchFunction</a> for a Promise-like API, or <a href="https://github.com/facebook/relay/blob/v1.6.0/packages/relay-runtime/network/RelayNetworkTypes.js#L92-L107">SubscribeFunction</a> for an
Observable-like API.</p>

<p>This article will provide 5 implementations of a Relay Network Interface, each of one providing more capabilities
than the other one, eventually enabling GraphQL Live Queries and Deferrable Queries.</p>

<p>You can see the code for these 5 network layers on GitHub here, open source under MIT license:
<a href="https://github.com/sibelius/relay-modern-network-deep-dive">https://github.com/sibelius/relay-modern-network-deep-dive</a>.</p>

<!-- more -->

<h3 id="simplest-network-layer">Simplest Network Layer</h3>

<p>The simplest network layer would; get the request, send it to a GraphQL server to resolve and return the data to
Relay environment.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fetchFunction</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">request</span><span class="p">:</span> <span class="nx">RequestNode</span><span class="p">,</span>
  <span class="nx">variables</span><span class="p">:</span> <span class="nx">Variables</span><span class="p">,</span>
  <span class="nx">cacheConfig</span><span class="p">:</span> <span class="nx">CacheConfig</span><span class="p">,</span>
  <span class="nx">uploadables</span><span class="p">:</span> <span class="p">?</span><span class="nx">UploadableMap</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// Most GraphQL APIs expect a POST with a JSON</span>
  <span class="c1">// string containing the query and associated variables</span>
  <span class="kd">const</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
    <span class="na">query</span><span class="p">:</span> <span class="nx">request</span><span class="p">.</span><span class="nx">text</span><span class="p">,</span> <span class="c1">// GraphQL text from input</span>
    <span class="nx">variables</span>
  <span class="p">})</span>

  <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">Accept</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span><span class="p">,</span>
    <span class="dl">"</span><span class="s2">Content-type</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">application/json</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">authorization</span><span class="p">:</span> <span class="nx">getToken</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetchWithRetries</span><span class="p">(</span><span class="nx">ENV</span><span class="p">.</span><span class="nx">GRAPHQL_URL</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">headers</span><span class="p">,</span>
    <span class="nx">body</span><span class="p">,</span>
    <span class="na">fetchTimeout</span><span class="p">:</span> <span class="mi">20000</span><span class="p">,</span>
    <span class="na">retryDelays</span><span class="p">:</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]</span>
  <span class="p">})</span>

  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>

  <span class="c1">// Mutations should throw when they have errors, making it easier</span>
  <span class="c1">// for client code to react</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isMutation</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">errors</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="nx">data</span>
  <span class="p">}</span>

  <span class="c1">// We return the GraphQL response to update the Relay Environment</span>
  <span class="c1">// which updates internal store where relay keeps its data</span>
  <span class="k">return</span> <span class="nx">data</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="network-that-handle-uploadables">Network that Handle Uploadables</h3>

<p>The GraphQL spec does not handle form data, and so if you need to send along files to upload to your server with a
mutation, you’ll want to use the uploadables API in Relay when you commit the mutation.</p>

<p>Adding uploadables in a mutation will inevitably get passed to your network interface, where you’ll need to change
your request body to use FormData instead of the JSON string above:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getRequestBodyWithUploadables</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">variables</span><span class="p">,</span> <span class="nx">uploadables</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">formData</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">FormData</span><span class="p">()</span>
  <span class="nx">formData</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="dl">"</span><span class="s2">query</span><span class="dl">"</span><span class="p">,</span> <span class="nx">request</span><span class="p">.</span><span class="nx">text</span><span class="p">)</span>
  <span class="nx">formData</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="dl">"</span><span class="s2">variables</span><span class="dl">"</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">variables</span><span class="p">))</span>

  <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">uploadables</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">key</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">uploadables</span><span class="p">,</span> <span class="nx">key</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">formData</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">uploadables</span><span class="p">[</span><span class="nx">key</span><span class="p">])</span>
    <span class="p">}</span>
  <span class="p">})</span>

  <span class="k">return</span> <span class="nx">formData</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="network-that-caches-requests">Network that Caches Requests</h3>

<p>This builds on top of the other 2 implementations, we use
<a href="https://github.com/facebook/relay/blob/v1.6.0/packages/relay-runtime/network/RelayQueryResponseCache.js#L24-L29">RelayQueryResponseCache</a>
to query GraphQL requests based on query and variables.</p>

<p>Every time a mutation happens, we should invalidate our cache as we are not sure how a change can affect all cached
query responses.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Create our own in-memory cache</span>
<span class="kd">const</span> <span class="nx">relayResponseCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RelayQueryResponseCache</span><span class="p">({</span> <span class="na">size</span><span class="p">:</span> <span class="mi">250</span><span class="p">,</span> <span class="na">ttl</span><span class="p">:</span> <span class="nx">oneMinute</span> <span class="p">})</span>

<span class="kd">const</span> <span class="nx">cacheHandler</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">request</span><span class="p">:</span> <span class="nx">RequestNode</span><span class="p">,</span>
  <span class="nx">variables</span><span class="p">:</span> <span class="nx">Variables</span><span class="p">,</span>
  <span class="nx">cacheConfig</span><span class="p">:</span> <span class="nx">CacheConfig</span><span class="p">,</span>
  <span class="nx">uploadables</span><span class="p">:</span> <span class="nx">UploadableMap</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">queryID</span> <span class="o">=</span> <span class="nx">request</span><span class="p">.</span><span class="nx">text</span>

  <span class="c1">// If it's a mutation, clear all cache, then call the implementation above</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isMutation</span><span class="p">(</span><span class="nx">request</span><span class="p">))</span> <span class="p">{</span>
    <span class="nx">relayResponseCache</span><span class="p">.</span><span class="nx">clear</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">fetchFunction</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">variables</span><span class="p">,</span> <span class="nx">cacheConfig</span><span class="p">,</span> <span class="nx">uploadables</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// Try grab the request from the cache first</span>
  <span class="kd">const</span> <span class="nx">fromCache</span> <span class="o">=</span> <span class="nx">relayResponseCache</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">queryID</span><span class="p">,</span> <span class="nx">variables</span><span class="p">)</span>
  <span class="c1">// Did it hit? Or did we suppress the cache for this request</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">isQuery</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">fromCache</span> <span class="o">!==</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">forceFetch</span><span class="p">(</span><span class="nx">cacheConfig</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">fromCache</span>
  <span class="p">}</span>

  <span class="c1">// Make the request, and cache it if we get a response</span>
  <span class="kd">const</span> <span class="nx">fromServer</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetchFunction</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">variables</span><span class="p">,</span> <span class="nx">cacheConfig</span><span class="p">,</span> <span class="nx">uploadables</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">fromServer</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">relayResponseCache</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">queryID</span><span class="p">,</span> <span class="nx">variables</span><span class="p">,</span> <span class="nx">fromServer</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">fromServer</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="network-using-observable">Network using Observable</h3>

<p>Relay provides a limited implementation of the upcoming <a href="https://github.com/tc39/proposal-observable">ESObservables</a> spec. I recommend reading <a href="https://kriskowal.gitbooks.io/gtor/content/">A General
Theory of Reactivity</a> to understand why Observables are a great solution instead of promises in some
situations. Notably; a promise is one value in a time space, an observable is a stream of values in a time space.</p>

<!-- [TODO: Why Sink and not the Relay Observable? Observable is exported but has one more function (complete)] -->

<p>To work with this API, we’re going to use a private interface for the observable object called Sink:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * A Sink is an object of methods provided by Observable during construction.
 * The methods are to be called to trigger each event. It also contains a closed
 * field to see if the resulting subscription has closed.
 */</span>
<span class="k">export</span> <span class="nx">type</span> <span class="nx">Sink</span><span class="o">&lt;-</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span><span class="o">|</span>
  <span class="o">+</span><span class="na">next</span><span class="p">:</span> <span class="nx">T</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">,</span>
  <span class="o">+</span><span class="na">error</span><span class="p">:</span> <span class="p">(</span><span class="nb">Error</span><span class="p">,</span> <span class="nx">isUncaughtThrownError</span><span class="p">?:</span> <span class="nx">boolean</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">,</span>
  <span class="o">+</span><span class="na">complete</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">,</span>
  <span class="o">+</span><span class="na">closed</span><span class="p">:</span> <span class="nx">boolean</span>
<span class="o">|</span><span class="p">}</span>
</code></pre></div></div>

<p>Which is the shape of the Observable object we pass back to Relay:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fetchFunction</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">request</span><span class="p">:</span> <span class="nx">RequestNode</span><span class="p">,</span>
  <span class="nx">variables</span><span class="p">:</span> <span class="nx">Variables</span><span class="p">,</span>
  <span class="nx">cacheConfig</span><span class="p">:</span> <span class="nx">CacheConfig</span><span class="p">,</span>
  <span class="nx">uploadables</span><span class="p">:</span> <span class="p">?</span><span class="nx">UploadableMap</span><span class="p">,</span>
  <span class="nx">sink</span><span class="p">:</span> <span class="nx">Sink</span><span class="o">&lt;</span><span class="nx">any</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">body</span> <span class="o">=</span> <span class="nx">getRequestBody</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">variables</span><span class="p">,</span> <span class="nx">uploadables</span><span class="p">)</span>

  <span class="kd">const</span> <span class="nx">headers</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">...</span><span class="nx">getHeaders</span><span class="p">(</span><span class="nx">uploadables</span><span class="p">),</span>
    <span class="na">authorization</span><span class="p">:</span> <span class="nx">getToken</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetchWithRetries</span><span class="p">(</span><span class="nx">ENV</span><span class="p">.</span><span class="nx">GRAPHQL_URL</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">"</span><span class="s2">POST</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">headers</span><span class="p">,</span>
    <span class="nx">body</span><span class="p">,</span>
    <span class="na">fetchTimeout</span><span class="p">:</span> <span class="mi">20000</span><span class="p">,</span>
    <span class="na">retryDelays</span><span class="p">:</span> <span class="p">[</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">]</span>
  <span class="p">})</span>

  <span class="kd">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">handleData</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">isMutation</span><span class="p">(</span><span class="nx">request</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">errors</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">sink</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="nx">sink</span><span class="p">.</span><span class="nx">complete</span><span class="p">()</span>

    <span class="k">return</span>
  <span class="p">}</span>

  <span class="nx">sink</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
  <span class="nx">sink</span><span class="p">.</span><span class="nx">complete</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// Instead of returning a Promise that will resolve a single GraphQL response.</span>
<span class="c1">// We return an Observable that could fulfill many responses before it finishes.</span>

<span class="kd">const</span> <span class="nx">executeFunction</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">request</span><span class="p">:</span> <span class="nx">RequestNode</span><span class="p">,</span>
  <span class="nx">variables</span><span class="p">:</span> <span class="nx">Variables</span><span class="p">,</span>
  <span class="nx">cacheConfig</span><span class="p">:</span> <span class="nx">CacheConfig</span><span class="p">,</span>
  <span class="nx">uploadables</span><span class="p">:</span> <span class="p">?</span><span class="nx">UploadableMap</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">sink</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">fetchFunction</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">variables</span><span class="p">,</span> <span class="nx">cacheConfig</span><span class="p">,</span> <span class="nx">uploadables</span><span class="p">,</span> <span class="nx">sink</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is an implementation you would need when working with <a href="https://github.com/facebook/relay/issues/2174">GraphQL Live Queries</a> (based on polling), as you
are going to resolve the same query more than once.</p>

<h3 id="deferrable-queries-network">Deferrable Queries Network</h3>

<p>A common case for deferrable queries is to lazy load fragments. This lets you get request content above the page
fold first, and then request additional data after. A good example is loading a Post’s content first and then
subsequently loading all comments of this post after the post has finished.</p>

<p>Without deferrable queries you could simulate this using the <a href="https://facebook.github.io/relay/docs/en/graphql-in-relay.html#directives">@include</a> directive in your Relay fragment
and a <a href="https://facebook.github.io/relay/docs/en/refetch-container.html">refetch container</a>. When the component mounts the refetch container changes the variable used on
the <code class="language-plaintext highlighter-rouge">@include</code> to true and it will request the rest of the data.</p>

<p>The problem with above approach is that you need to wait for the component to mount before you can start the next
request. This becomes a bigger problem as React does more work asynchronously.</p>

<!-- TODO: There are no docs for relay deferrable -->

<p>An ideal deferrable query will start as soon as the previous query has finished, rather than depending on your
React components render cycles. Relay provides a <a href="https://github.com/facebook/relay/issues/2194#issuecomment-383466255">directive</a> for this: <code class="language-plaintext highlighter-rouge">@relay(deferrable: true)</code>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">PostFragment</span> <span class="o">=</span> <span class="nx">createFragmentContainer</span><span class="p">(</span><span class="nx">Post</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">post</span><span class="p">:</span> <span class="nx">graphql</span><span class="s2">`
    fragment Post_post on Post {
      title
      commentsCount
      ...CommentsList_post @relay(deferrable: true)
    }
  `</span>
<span class="p">})</span>
</code></pre></div></div>

<p>In the fragment above, Relay will first get the <code class="language-plaintext highlighter-rouge">title</code> and <code class="language-plaintext highlighter-rouge">commentsCount</code> from the Post, then afterwards Relay
will get the data for <code class="language-plaintext highlighter-rouge">CommentsList_post</code> fragment. Sending both through the observable.</p>

<p>Here is the implementation of an execute function to handle a batched request:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">executeFunction</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">request</span><span class="p">:</span> <span class="nx">RequestNode</span><span class="p">,</span>
  <span class="nx">variables</span><span class="p">:</span> <span class="nx">Variables</span><span class="p">,</span>
  <span class="nx">cacheConfig</span><span class="p">:</span> <span class="nx">CacheConfig</span><span class="p">,</span>
  <span class="nx">uploadables</span><span class="p">:</span> <span class="p">?</span><span class="nx">UploadableMap</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Observable</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">sink</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">kind</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">Request</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">cacheHandler</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">variables</span><span class="p">,</span> <span class="nx">cacheConfig</span><span class="p">,</span> <span class="nx">uploadables</span><span class="p">,</span> <span class="nx">sink</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">request</span><span class="p">.</span><span class="nx">kind</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">BatchRequest</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">batchRequestQuery</span><span class="p">(</span><span class="nx">request</span><span class="p">,</span> <span class="nx">variables</span><span class="p">,</span> <span class="nx">cacheConfig</span><span class="p">,</span> <span class="nx">uploadables</span><span class="p">,</span> <span class="nx">sink</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This execute function now can handle 2 types of requests:</p>

<ul>
  <li>a single GraphQL query <code class="language-plaintext highlighter-rouge">Request</code></li>
  <li>or a <code class="language-plaintext highlighter-rouge">BatchRequest</code> that could have be many queries with inter-related data</li>
</ul>

<p>So, what does the <code class="language-plaintext highlighter-rouge">batchRequestQuery</code> function look like?</p>

<!-- TODO: Annotate ths code, I'm not 100% what it's doing myself -->

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Get variables from the results that have already been sent</span>
<span class="kd">const</span> <span class="nx">getDeferrableVariables</span> <span class="o">=</span> <span class="p">(</span><span class="nx">requests</span><span class="p">,</span> <span class="nx">request</span><span class="p">,</span> <span class="nx">variables</span><span class="p">:</span> <span class="nx">Variables</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">argumentDependencies</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">request</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">argumentDependencies</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">variables</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">argumentDependencies</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">acc</span><span class="p">,</span> <span class="nx">ad</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">response</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">requests</span><span class="p">[</span><span class="nx">ad</span><span class="p">.</span><span class="nx">fromRequestName</span><span class="p">]</span>

    <span class="kd">const</span> <span class="nx">variable</span> <span class="o">=</span> <span class="kd">get</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span> <span class="nx">ad</span><span class="p">.</span><span class="nx">fromRequestPath</span><span class="p">)</span>

    <span class="c1">// TODO - handle ifList, ifNull</span>
    <span class="c1">// See: https://github.com/facebook/relay/issues/2194</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="p">...</span><span class="nx">acc</span><span class="p">,</span>
      <span class="p">[</span><span class="nx">ad</span><span class="p">.</span><span class="nx">name</span><span class="p">]:</span> <span class="nx">variable</span>
    <span class="p">}</span>
  <span class="p">},</span> <span class="p">{})</span>
<span class="p">}</span>

<span class="c1">// Execute each of the requests, and call `sink.next()` as soon as it has the GraphQL</span>
<span class="c1">/// server response data.</span>
<span class="c1">//</span>
<span class="c1">// It will only close the Observable stream when all requests has been fulfilled.</span>
<span class="kd">const</span> <span class="nx">batchRequestQuery</span> <span class="o">=</span> <span class="k">async</span> <span class="p">(</span>
  <span class="nx">request</span><span class="p">:</span> <span class="nx">RequestNode</span><span class="p">,</span>
  <span class="nx">variables</span><span class="p">:</span> <span class="nx">Variables</span><span class="p">,</span>
  <span class="nx">cacheConfig</span><span class="p">:</span> <span class="nx">CacheConfig</span><span class="p">,</span>
  <span class="nx">uploadables</span><span class="p">:</span> <span class="p">?</span><span class="nx">UploadableMap</span><span class="p">,</span>
  <span class="nx">sink</span><span class="p">:</span> <span class="nx">Sink</span><span class="o">&lt;</span><span class="nx">ExecutePayload</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">requests</span> <span class="o">=</span> <span class="p">{}</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">r</span> <span class="k">of</span> <span class="nx">request</span><span class="p">.</span><span class="nx">requests</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">v</span> <span class="o">=</span> <span class="nx">getDeferrableVariables</span><span class="p">(</span><span class="nx">requests</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">variables</span><span class="p">)</span>

    <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">cacheHandler</span><span class="p">(</span><span class="nx">r</span><span class="p">,</span> <span class="nx">v</span><span class="p">,</span> <span class="nx">cacheConfig</span><span class="p">,</span> <span class="nx">uploadables</span><span class="p">,</span> <span class="nx">sink</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>

    <span class="nx">requests</span><span class="p">[</span><span class="nx">r</span><span class="p">.</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">response</span>
  <span class="p">}</span>

  <span class="nx">sink</span><span class="p">.</span><span class="nx">complete</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="relay-modern-is-very-flexible">Relay Modern is very flexible</h2>

<p>Depending on your application needs, you can scale from a simpler Promise-based API for your custom network layer
to one that uses Observables to always resolves from cache data first and then resolves from the server.</p>

<p>Here are some production examples:</p>

<ul>
  <li>
    <p><a href="https://github.com/artsy/emission/blob/master/src/lib/relay/fetchQuery.ts">Artsy Emission</a>: Uses the Promise API, caches the results locally, and shares logic with native code in
an iOS app so that queries can be pre-cached before the JavaScript runtime has started.</p>
  </li>
  <li>
    <p><a href="https://github.com/relay-tools/react-relay-network-modern">ReactRelayNetworkModern</a>: A network layer that uses the middleware pattern to separate responsibilities like
retrying, logging, caching and auth.</p>
  </li>
  <li>
    <p><a href="https://github.com/facebook/relay/issues/2174#issuecomment-375274003">timobetina’s example</a>: The simplest Observable network layer you can start with.</p>
  </li>
</ul>

<!-- TODO: More, @sibelius do you have some good examples? -->

<h2 id="more-resources">More Resources</h2>

<p>If you want to expand your understanding of GraphQL and Relay Modern, I have two great related resources:</p>

<ul>
  <li>
    <p>A boilerplate that uses dataloader to batch and cache requests to your database in a GraphQL API:
<a href="https://github.com/entria/graphql-dataloader-boilerplate">https://github.com/entria/graphql-dataloader-boilerplate</a></p>
  </li>
  <li>
    <p>A simple boilerplate for working with Relay Modern and React Navigation:
<a href="https://github.com/entria/ReactNavigationRelayModern">https://github.com/entria/ReactNavigationRelayModern</a></p>
  </li>
</ul>

<p>If you have questions about this or anything send me a DM on twitter
<a href="https://twitter.com/sseraphini">https://twitter.com/sseraphini</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Relay Mutations]]></title>
    <link href="https://artsy.github.io/blog/2017/04/26/Relay-Mutations/"/>
    <updated>2017-04-26T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2017/04/26/Relay-Mutations</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Hey there everyone, it took us two years to <a href="https://github.com/artsy/metaphysics/pull/583">make our</a> GraphQL implementation support any mutations. We opted to keep it read-only for quite a long time because we use GraphQL to consolidate multiple APIs, but as we start new projects as GraphQL + databases then understanding mutations becomes much more important.</p>

  <p>Last month, I talked with the team at <a href="https://www.graph.cool/">Graph.cool</a> about having them talk through Relay mutations comprehensively as a guest post on the Artsy Engineering blog. So, I’m really excited to introduce this great post on the topic by <a href="http://twitter.com/nikolasburk">Nikolas Burk</a>.</p>

  <p>– Orta</p>
</blockquote>

<h1 id="the-magic-behind-relay-mutations">The Magic behind Relay Mutations</h1>

<p><a href="https://facebook.github.io/relay/">Relay</a> is a powerful GraphQL client for React and React Native applications. It was open sourced by Facebook alongside GraphQL in 2015 and is a great tool for supporting you with managing your app’s data layer.</p>

<p>In this post, we are going to explore how Relay mutations work by looking at a React Native app. The code can be found on <a href="https://github.com/graphcool-examples/react-native-relay-pokedex-example">GitHub</a>. Our sample application is a simple <em>Pokedex</em>, where users can manage their Pokemons.</p>

<p><img src="http://i.imgur.com/S21GfEo.png" alt="" /></p>

<blockquote>
  <p>Note: We’re going to assume a basic familiarity with GraphQL in this article. If you haven’t heard of GraphQL before, the <a href="www.graphql.org">documentation</a> and the <a href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile/">GraphQL for iOS Developers</a> post are great places to start. If you’re interested in learning more about Relay in general, head over to <a href="www.learnrelay.org">Learn Relay</a> for a comprehensive tutorial.</p>
</blockquote>

<!-- more -->

<p>If you want to run the example with your own GraphQL server, you can use <a href="https://www.graph.cool/graphql-up/">graphql-up</a> to quickly spin one up yourself from within your browser. Simply click the pink button and follow the instructions on the website.</p>

<p><a href="https://www.graph.cool/graphql-up/new?source=https://raw.githubusercontent.com/graphcool-examples/react-native-relay-pokedex-example/master/pokedex.schema"><img src="http://static.graph.cool/images/graphql-up.svg" alt="graphql-up" /></a></p>

<h2 id="relay---a-brief-overview">Relay - A brief Overview</h2>

<p>Relay is the most sophisticated GraphQL client available at the moment. Like GraphQL, it has been used and battle-tested internally by Facebook for many years before it was open sourced.</p>

<p>Relay surely isn’t the easiest framework to learn - but when used correctly, it takes care of managing large parts of your app’s data layer in a consistent and reliable manner! It therefore is particularly well-suited for complex applications with lots of data interdependencies and provides outstanding longterm developer productivity.</p>

<h3 id="declarative-api-and-colocation">Declarative API and Colocation</h3>

<p>With Relay, React components specify their data requirements in a declarative fashion, making use of GraphQL <em>fragments</em>.</p>

<blockquote>
  <p>A <a href="https://learngraphql.com/basics/fragments">GraphQL fragment</a> is a selection of fields on a GraphQL type. You can use them to define <em>reusable sub-parts</em> of queries or mutations.</p>
</blockquote>

<p>Considering the <code class="language-plaintext highlighter-rouge">PokemonDetails</code> view above, we need to display the Pokemon’s name and image. The fragment that represents these data requirements looks as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fragment PokemonDetails on Node {
  ... on Pokemon {
    id
    name
    url
  }
}
</code></pre></div></div>

<p>Note that the <code class="language-plaintext highlighter-rouge">id</code> is required so that Relay can identify the objects in the cache, so it’s included in the payload as well (even if it’s not displayed on the UI).</p>

<p>These fragments are kept in the same file as the React component, so UI and data requirements are <em>colocated</em>. Relay then uses a <a href="https://facebook.github.io/react/docs/higher-order-components.html">higher-order component</a> called <a href="https://facebook.github.io/relay/docs/guides-containers.html#content"><code class="language-plaintext highlighter-rouge">Relay.Container</code></a>, to wrap the component along with its data requirements. From this point, the developer doesn’t have to worry about the data any more! It will be fetched behind the scenes and is made available to the component via its props.</p>

<h3 id="build-time-schema-validation">Build-time Schema Validation</h3>

<p>Another great feature of Relay that ensures developer productivity is  <em>schema validation</em>. At build time, Relay checks your GraphQL queries, fragments and mutations to ensure their compatibility with the GraphQL API. It is thus able to catch any typos or other schema-related errors before you run (or even worse: deploy) your app, saving your users from unpleasant experiences. Note that the schema validation step requires a <a href="https://facebook.github.io/relay/docs/guides-babel-plugin.html">Babel Relay Plugin</a>.</p>

<h2 id="mutations-in-relay">Mutations in Relay</h2>

<h3 id="graphql-recap">GraphQL Recap</h3>

<p>In GraphQL, a <em>mutation</em> is the only way to create, update or delete data on the server - they effectively are the GraphQL abstraction for <em>changing state</em> in your backend.</p>

<p>As an example, creating a new Pokemon in our sample app uses the following mutation:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mutation CreatePokemon($name: String!, $url: String!) {
  createPokemon(input: {
    name: $name,
    url: $url
  }) {
    # payload of the mutation (will be returned by the server)
    pokemon {
      id 
    }
  }
}
</code></pre></div></div>

<p>Notice that mutations, similar to queries, also require a <em>payload</em> to be specified. This payload represents the information that we’d like to have returned from the server after the mutation was performed. In the above example, we’re asking for the <code class="language-plaintext highlighter-rouge">id</code> of the new <code class="language-plaintext highlighter-rouge">pokemon</code>.</p>

<h3 id="the-magic-declarative-mutations-">The Magic: Declarative Mutations 🔮</h3>

<p>Relay doesn’t (yet) give the developer the ability to manually modify the data that it stores internally. Instead, with every change, it requires a declarative <em>description</em> of how the local cache should be updated after the change happened in the form of a <a href="https://facebook.github.io/relay/docs/guides-mutations.html#content">mutation</a> and then takes care of the update under the hood.</p>

<p>The description is provided by subclassing <code class="language-plaintext highlighter-rouge">Relay.Mutation</code> and implementing (at least) four methods that help Relay to properly update the local store:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getMutation()</code>: the name of the mutation (from the GraphQL schema)</li>
  <li><code class="language-plaintext highlighter-rouge">getVariables()</code>: the input variables for the mutation</li>
  <li><code class="language-plaintext highlighter-rouge">getFatQuery()</code>: a GraphQL query that fetches all data that potentially was changed due to the mutation</li>
  <li><code class="language-plaintext highlighter-rouge">getConfigs()</code>: a precise specification how the mutation should be incorporated into the cache</li>
</ul>

<p>In the following, we’ll take a deeper look at the different kinds of mutations in our sample app, which are used for creating, updating and deleting Pokemons.</p>

<blockquote>
  <p>Note: We’re using the <a href="https://www.graph.cool/docs/reference/relay-api/overview-aizoong9ah">Graphcool Relay API</a> for this example. If you used <code class="language-plaintext highlighter-rouge">graphql-up</code> to create your own backend, you can explore the API by pasting the endpoint for the Relay API into the address bar of a browser.</p>
</blockquote>

<h3 id="creating-a-new-pokemon-range_add">Creating a new Pokemon: <code class="language-plaintext highlighter-rouge">RANGE_ADD</code></h3>

<p><img src="http://i.imgur.com/yskx5KU.png" alt="" /></p>

<p>Let’s walk through the different methods and understand what information we have to provide so that Relay can successfully merge the newly created Pokemon into its store.</p>

<p>The first two methods, <code class="language-plaintext highlighter-rouge">getMutation()</code> and <code class="language-plaintext highlighter-rouge">getVariables()</code> are relatively obvious and can be retrieved directly from the documentation where the API is described.</p>

<p>The implementations look as follows:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getMutation</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Relay</span><span class="p">.</span><span class="nx">QL</span><span class="s2">`mutation { createPokemon }`</span>
<span class="p">}</span>

<span class="nx">getVariables</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
    <span class="na">url</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">url</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice that the <code class="language-plaintext highlighter-rouge">props</code> of a <code class="language-plaintext highlighter-rouge">Relay.Mutation</code> are passed through its constructor. Here, we simply provide the <code class="language-plaintext highlighter-rouge">name</code> and the <code class="language-plaintext highlighter-rouge">url</code> of the Pokemon that is to be created.</p>

<p>Now, on to the interesting parts. In <code class="language-plaintext highlighter-rouge">getFatQuery()</code>, we need to specify the parts that might change due to the mutation. Here, we simply specify the <code class="language-plaintext highlighter-rouge">viewer</code>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getFatQuery</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Relay</span><span class="p">.</span><span class="nx">QL</span><span class="s2">`
    fragment on CreatePokemonPayload {
      viewer {
        allPokemons
      }
    }
  `</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Notice that <em>every</em> subfield of <code class="language-plaintext highlighter-rouge">allPokemons</code> is also automatically included with this approach. In our example app, <code class="language-plaintext highlighter-rouge">allPokemons</code> is the only point we expect to change after our mutation is performed.</p>

<p>Finally, in <code class="language-plaintext highlighter-rouge">getConfigs()</code>, we need to specify the <a href="https://facebook.github.io/relay/docs/guides-mutations.html#mutator-configuration">mutator configurations</a>, telling Relay exactly how the new data should be incorporated into the cache. This is where the magic happens:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getConfigs</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[{</span>
    <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">RANGE_ADD</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">parentName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">viewer</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">parentID</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">viewerId</span><span class="p">,</span>
    <span class="na">connectionName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">allPokemons</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">edgeName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">edge</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">rangeBehaviors</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">''</span><span class="p">:</span> <span class="dl">'</span><span class="s1">append</span><span class="dl">'</span>
    <span class="p">}</span>
  <span class="p">}]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We first express that we want to <em>add</em> the node using <code class="language-plaintext highlighter-rouge">RANGE_ADD</code> for the <code class="language-plaintext highlighter-rouge">type</code> (there are 5 different types in total).</p>

<p>Relay internally represents the stored data as a graph, so the remaining information expresses where exactly the new node should be hooked into the existing structure.</p>

<p>Let’s consider the shape of the data before we move on:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>viewer {
  allPokemons {
    edges {
      node {
        id
        name
      }
    }
  }
}
</code></pre></div></div>

<p>Here we clearly see the direct connection between <code class="language-plaintext highlighter-rouge">viewer</code> and the Pokemons goes through <code class="language-plaintext highlighter-rouge">allPokemons</code> <em>connection</em>, so the <em>parent</em> of the new Pokemon is the <code class="language-plaintext highlighter-rouge">viewer</code>. The name of that connection is <code class="language-plaintext highlighter-rouge">allPokemons</code>, and lastly the <code class="language-plaintext highlighter-rouge">edgeName</code> is taken from the payload of the mutation.</p>

<p>The last piece, <code class="language-plaintext highlighter-rouge">rangeBehaviors</code>, specifies whether we want to <em>append</em> or <em>prepend</em> the new node.</p>

<p>Executing the mutation is as simple as calling <code class="language-plaintext highlighter-rouge">commitUpdate</code> on the <code class="language-plaintext highlighter-rouge">relay</code> prop that’s injected to each component being wrapped with a <code class="language-plaintext highlighter-rouge">Relay.Container</code>. An instance of the mutation and the expected variables are passed as arguments to the constructor:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">_sendCreatePokemonMutation</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">createPokemonMutation</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CreatePokemonMutation</span><span class="p">({</span>
    <span class="na">viewerId</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">viewer</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
    <span class="na">name</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">pokemonName</span><span class="p">,</span>
    <span class="na">url</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">pokemonUrl</span><span class="p">,</span>
  <span class="p">})</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">relay</span><span class="p">.</span><span class="nx">commitUpdate</span><span class="p">(</span><span class="nx">createPokemonMutation</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="updating-a-pokemon-fields_change">Updating a Pokemon: <code class="language-plaintext highlighter-rouge">FIELDS_CHANGE</code></h3>

<p>Like with creating a Pokemon, <code class="language-plaintext highlighter-rouge">getMutation()</code> and <code class="language-plaintext highlighter-rouge">getVariables()</code> are trivial to implement and can be derived directly from the API documentation:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getMutation</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Relay</span><span class="p">.</span><span class="nx">QL</span><span class="s2">`mutation { updatePokemon }`</span>
<span class="p">}</span>

<span class="nx">getVariables</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">id</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
    <span class="na">name</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span>
    <span class="na">url</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">url</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">getFatQuery()</code>, we only include the <code class="language-plaintext highlighter-rouge">pokemon</code> which includes the updated info this time, since that is the only part we expect to change after our mutation:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getFatQuery</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Relay</span><span class="p">.</span><span class="nx">QL</span><span class="s2">`
    fragment on UpdatePokemonPayload {
      pokemon
    }
  `</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Finally, <code class="language-plaintext highlighter-rouge">getConfigs()</code>, this time specifies a mutator configuration of type <code class="language-plaintext highlighter-rouge">FIELDS_CHANGE</code> since we’re only updating properties on a single Pokemon:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getConfigs</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[{</span>
    <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FIELDS_CHANGE</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">fieldIDs</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">pokemon</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">}]</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As sole additional piece of info, we declare the ID of the Pokemon that is being updated so that Relay has this information available when receiving the new Pokemon data.</p>

<h3 id="deleting-a-pokemon-node_delete">Deleting a Pokemon: <code class="language-plaintext highlighter-rouge">NODE_DELETE</code></h3>

<p>As before, <code class="language-plaintext highlighter-rouge">getMutation()</code> and <code class="language-plaintext highlighter-rouge">getVariables()</code> are self-explanatory:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getMutation</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Relay</span><span class="p">.</span><span class="nx">QL</span><span class="s2">`mutation { deletePokemon }`</span>
<span class="p">}</span>

<span class="nx">getVariables</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="na">id</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, in <code class="language-plaintext highlighter-rouge">getFatQuery()</code>, we need to retrieve the <code class="language-plaintext highlighter-rouge">pokemon</code> from the mutation payload:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getFatQuery</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">Relay</span><span class="p">.</span><span class="nx">QL</span><span class="s2">`
    fragment on DeletePokemonPayload {
      pokemon
    }
  `</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">getConfigs()</code>, we’re getting to know another mutator configuration type called <code class="language-plaintext highlighter-rouge">NODE_DELETE</code>. This one requires a <code class="language-plaintext highlighter-rouge">parentName</code> as well as a <code class="language-plaintext highlighter-rouge">connectionName</code>, both coming from the mutation payload and specifying where that node existed in Relay’s data graph. Another requirement, that is specifically relevant for the implementation of a GraphQL server, is that the mutation payload of a deleting mutation always needs to return the <code class="language-plaintext highlighter-rouge">id</code> of the deleted node so that Relay can find that node in its store. Taking all of this together, our implementation of <code class="language-plaintext highlighter-rouge">getConfigs()</code> can be written like so:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getConfigs</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">[{</span>
    <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">NODE_DELETE</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">parentName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">pokemon</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">connectionName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">edge</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">deletedIDFieldName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">deletedId</span><span class="dl">'</span>
  <span class="p">}]</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="wrapping-up">Wrapping Up</h2>

<p>Relay has a lot of benefits that make it a very compelling framework to use for state management and interaction with GraphQL APIs. Its major strengths are a highly optimized cache, thoughtful UI integration as well as the declarative API for data fetching and mutations.</p>

<p>The initial version of Relay came with a notable learning curve due to lots of magic happening behind the scenes. However, Facebook recently released the first release candidates of <a href="https://github.com/facebook/relay/releases/">Relay v1.0.0</a> (<em>Relay Modern</em>) with the <a href="https://code.facebook.com/posts/1362748677097871">goal of making Relay generally more approachable</a>.</p>

<p>It’s worth noting that Relay isn’t the only available GraphQL client. Apollo Client is a great alternative which is a lot easier to get started with. <a href="https://www.graph.cool/docs/tutorials/relay-vs-apollo-iechu0shia/">For a detailed comparison please refer to this article.</a></p>

<p>If you want to learn more about GraphQL and want to stay up-to-date with the latest news of the GraphQL community, subscribe to <a href="https://graphqlweekly.com/">GraphQL Weekly</a>.</p>
]]></content>
  </entry>
  
</feed>
