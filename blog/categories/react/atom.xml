<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/react/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2022-01-10T18:20:02+01:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Accessing the Relay Store Without a Mutation]]></title>
    <link href="https://artsy.github.io/blog/2021/04/15/accessing-the-relay-store/"/>
    <updated>2021-04-15T00:00:00+02:00</updated>
    <id>https://artsy.github.io/blog/2021/04/15/accessing-the-relay-store</id>
    <content type="html"><![CDATA[<p>I recently encountered a problem where client-side data (returned from a Relay query) became out of sync after a
user interaction. How can we make sure our data is consistent while maintaining a single source of truth? This post
explores why a developer might want to update client-side data locally, the basics of Relay and its store, and how
to delete records in the store when you're not using a mutation.</p>

<a name="Relay.x.Artsy.x.Me"></a>
<h2>Relay x Artsy x Me</h2>

<p><a href="https://relay.dev/">Relay</a> is a GraphQL client library maintained by Facebook engineers and enables rapid client-side data
fetching in React applications. <a href="https://artsy.github.io/blog/2019/04/10/omakase-relay/">Artsy's adoption of Relay</a> coincided with our move
toward using React Native for our mobile work around 2016. I joined Artsy as an engineer in November of 2020 (after
<a href="https://medium.com/swlh/how-losing-my-job-helped-me-find-my-way-back-8c8f86552acc">transitioning to engineering from a non-technical role at the
company</a>.) When I joined, I was about a year into React development
and completely new to Relay.</p>

<!-- more -->


<p>I work on the Partner Experience (PX) team at Artsy. We build and maintain software used by our gallery and auction
house partners to sell artwork on Artsy. Although Relay is not new to Artsy, it‚Äôs relatively new to our team‚Äôs main
repository, Volt. (Volt is Artsy‚Äôs CMS used by gallery partners to manage their presences on the platform.) A topic
for another blog post, but Volt‚Äôs structure is worth noting here: Volt is a collection of mini React apps injected
into HAML views‚Äîour way of incrementally converting the codebase to our new stack.</p>

<p>Relay‚Äôs biggest advantage in my eyes is how it tightly couples the client view and API call (in our case, to the
GraphQL layer of our stack, which we call Metaphysics.) In addition to performance and other benefits, colocating a
component with its data requirements creates a pretty seamless developer experience.</p>

<a name="Building.an.Artwork.Checklist"></a>
<h2>Building an Artwork Checklist</h2>

<p>On the PX team, we recently launched a checklist feature aimed at empowering our gallery partners to be more
self-sufficient and find the greatest success possible on Artsy. The checklist prompts galleries to add specific
metadata to artworks that we know (because of our awesome data team) will make the work more likely to sell. The
new feature gathers a list of five high-priority artworks (meaning they are published, for-sale, and by a
top-selling artist) that are missing key pieces of metadata. The checklist prompts users to add the missing
metadata. Users also have the ability to click a button to ‚Äúsnooze‚Äù works, which removes them from the list for the
day.</p>

<p><figure class="illustration">
    <img src="https://user-images.githubusercontent.com/9466631/114630150-28886200-9c77-11eb-9f04-461101496ee0.png">
</figure></p>

<p>The feature makes use of <a href="https://redis.io/">Redis</a>, a key-value store used for in-memory cache, to store two lists:</p>

<ol>
<li><code>includeIDs</code> to store the five artworks in the list, so users see a consistent list of artworks whenever they
log in and load the page</li>
<li><code>excludeIDs</code> or ‚Äúsnoozed‚Äù IDs which Redis will store for 24 hours and ensure the user does not see</li>
</ol>


<p>When a user presses the ‚Äúsnooze‚Äù button, the ID for the artwork is added to the snoozed list in Redis. The list of
<code>includeIDs</code> and the list of <code>excludeIDs</code> are passed down from Rails controllers to our HAML views and then passed
as props into our React <code>HomePageChecklist</code> app. In our Checklist component, we use both the <code>includeIDs</code> and the
<code>excludeIDs</code> as arguments passed to our Relay query to determine what is returned from Metaphysics (Artsy's GraphQL
layer).</p>

<pre><code class="js">fragment ArtworksMissingMetadata_partner on Partner
  @argumentDefinitions(
    first: { type: "Int", defaultValue: 5 }
    after: { type: "String" }
    includeIDs: { type: "[String!]" }
    excludeIDs: { type: "[String!]" }
  ) {
    id
    artworksConnection(
      first: $first
      after: $after
      includeIDs: $includeIDs
      excludeIDs: $excludeIDs
    ) @connection(key: "ArtworksMissingMetadata_partner_artworksConnection", filters: []) {
      edges {
        node {
          ...ArtworksMissingMetadataItem_artwork
        }
      }
    }
  }
</code></pre>

<a name="Problem:.How.to.Change.the.Data.Displayed.When.a.User.Interacts.with.the.Page"></a>
<h2>Problem: How to Change the Data Displayed When a User Interacts with the Page</h2>

<p>The problem we were running into occurs when the user presses ‚Äúsnooze‚Äù on an item. We successfully update Redis
with the new snoozed item, but the UI still renders the item on the page. (This is because the response from Relay
becomes stale.) If the user refreshes the page, the list is correct: The up-to-date Redis <code>excludeIDS</code> list will be
passed into our component and used in the Relay query. But without refreshing the page, we need to make sure that
the list in the UI updates when the user snoozes an item.</p>

<p>The initial fix was to use a local state variable to keep track of which items were snoozed. We defined the following variable in the parent
React component that renders the list:</p>

<pre><code class="js">const [localSnoozedItems, setLocalSnoozedItems] = useState([])
</code></pre>

<p>We passed <code>localSnoozedItems</code> and <code>setLocalSnoozedItems</code> down to each of the children items. When the ‚Äúsnooze‚Äù
button was pressed on an item, the <code>localSnoozedItems</code> in the parent was updated with the complete list of snoozed
items. The parent then controls which items get rendered. We used the <code>localSnoozedItems</code> list to filter the connection
returned from our Relay query (which remember, is already filtered based on our Redis <code>excludeIDs</code> from Redis.)</p>

<p>This worked, but it definitely did not feel great to have two sources of truth for snoozing: The Redis key and the
local state variable.</p>

<a name="Solution:.Deleting.a.Record.From.the.Relay.Store"></a>
<h2>Solution: Deleting a Record From the Relay Store</h2>

<p>Cue the <a href="https://relay.dev/docs/api-reference/store/">RelayModernStore</a>! I learned that Relay keeps track of the GraphQL
data returned by each query in a store on the client. Each record in the store has a unique ID, and the store can be
changed, added to, and deleted from. There are a couple of helpful blog posts (like
<a href="https://yashmahalwal.medium.com/a-deep-dive-into-the-relay-store-9388affd2c2b">this</a> and
<a href="https://medium.com/entria/wrangling-the-client-store-with-the-relay-modern-updater-function-5c32149a71ac">this</a>) that explain the store and how to
interact with it.</p>

<p>In most of the Relay documentation, blog posts, and Artsy‚Äôs uses cases, the store is accessed through an <code>updater</code>
function via <a href="https://relay.dev/docs/guided-tour/updating-data/graphql-mutations/">mutations</a>. <a href="https://relay.dev/docs/guided-tour/updating-data/graphql-mutations/#updater-functions">Updater functions</a>
that return the store in the first argument can optionally be added to Relay mutations. Inside that function, you can access
the store to modify the records you need.</p>

<p>Here's an example:</p>

<pre><code class="js">commitMutation(defaultEnvironment, {
  mutation: graphql`
    mutation SomeMutation {
      ...
    }
  `,
  updater: (store) =&gt; {
    // Do something with the store
  },
})
</code></pre>

<p>In my use case, I was not using a Relay mutation because I did not need to modify anything on the server. Since
Redis is keeping track of our <code>excludeIDs</code> for us, any round trip to the server will be up-to-date. We just need to
modify our local data store.</p>

<p>Relay provides a <a href="https://relay.dev/docs/guided-tour/updating-data/local-data-updates/">separate API method to make local updates</a> to the Relay
store: <code>commitLocalUpdate</code>. <code>commitLocalUpdate</code> takes two arguments: the first is the Relay environment, which you
can easily access from the parent Relay fragment or refetch container. The second is an <code>updater</code> callback function
that returns the store in the first argument. We now have access to the store!</p>

<a name="Deleting.a.Connection.Node.with.ConnectionHandler"></a>
<h2>Deleting a Connection Node with ConnectionHandler</h2>

<p>My main hurdle during this journey was finding an appropriate way to hook into the store for our specific use case‚Äîwhen we do
not require an update to server data.</p>

<p>But to close us out: Let's finish the job and delete the item from the connection in the store.</p>

<p>When an item is snoozed, we call <code>commitLocalUpdate</code>, pass in the Relay environment, and then pass in the <code>updater</code>
function. Once we have access to the store, our goal is to delete this particular item from the
<code>artworksConnection</code>, which is the GraphQL object returned by our original Relay query.</p>

<p>Because we are dealing with connections, we want to use the <a href="https://relay.dev/docs/api-reference/store/#connectionhandler">ConnectionHandler
API</a> provided by Relay. <code>ConnectionHandler.getConnection</code> takes in the
connection's parent record (which we can find using the GraphQL ID added as a field on our query for the
connection) as the first argument and the connection key which can be provided through <a href="https://www.prisma.io/blog/relay-moderns-connection-directive-1ecd8322f5c8">Relay‚Äôs @connection
directive</a>.</p>

<p>Once we have the connection, we will use <code>ConnectionHandler.deleteNode</code> which takes the connection as the first
argument and the id to be deleted, which we can also easily access using the GraphQL ID added as a field to the
query for the item.</p>

<p>Bonus: Because <code>commitLocalUpdate</code> works anywhere in Relay land, we got to perform this deletion exactly where the
"snooze" action is happening: in the child item component. (In our previous solution, we had to manage the state of
the children from their parent component, which wasn't as intuitive.)</p>

<pre><code class="js">import { commitLocalUpdate } from "relay-runtime"

commitLocalUpdate(relay.environment, (store) =&gt; {
  const parentRecord = store.get(parentID)

  if (parentRecord) {
    const artworksConnection = ConnectionHandler.getConnection(
      parentRecord,
      "ArtworksMissingMetadata_partner_artworksConnection"
    )
    if (artworksConnection) {
      ConnectionHandler.deleteNode(artworksConnection, id)
    }
  }
})
</code></pre>

<a name="Key.Takeaways"></a>
<h2>Key Takeaways</h2>

<ol>
<li>Relay is great because it colocates a component with its data requirements.</li>
<li>The Relay store allows us to access and modify data that we are using on the client.</li>
<li><code>commitLocalUpdate</code> provides us access to the store if we just need to modify local data and aren‚Äôt using a
mutation to update server-side data.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Relay Pagination Containers Demystified]]></title>
    <link href="https://artsy.github.io/blog/2020/08/31/relay-pagination-containers-demystified/"/>
    <updated>2020-08-31T00:00:00+02:00</updated>
    <id>https://artsy.github.io/blog/2020/08/31/relay-pagination-containers-demystified</id>
    <content type="html"><![CDATA[<p>In 2017, Artsy adopted <a href="https://relay.dev/en/">Relay</a> in both its front-end web and iOS codebases (using React and
React Native, respectively). Generally speaking, this investment has turned out very well for us! Relay empowers
product teams to quickly iterate on new features and to share common infrastructure across web and iOS codebases.
However, most of the original engineers who pioneered using Relay at Artsy have since moved on to their next role;
this has left a knowledge gap where Artsy engineers are comfortable <em>using</em> Relay, but they don't totally
understand how it works.</p>

<p>This is a problem as old as software engineering itself, and it has a simple solution: learn and then teach others.
We'll be driving a peer learning group centering around Relay, but today we are going to dive into the part of
Relay that comes up the most in requests for pairing: getting Relay pagination to work. (Note: we're going to use
plain old Relay and not <a href="https://github.com/relay-tools/relay-hooks">relay-hooks</a>.)</p>

<!-- more -->


<p>My goal with this post is to show my thought process when trying to learn about, and clean up our use of, Relay
pagination containers. This post emphasizes the <em>demystifying</em> process and not so much the <em>Relay pagination
containers</em> themselves ‚Äì we'll briefly cover some Relay fundamentals before diving into a case study on how
problematic code proliferates through copy-and-paste.</p>

<p>Let's back up and talk a little bit about what Relay is and how it works. Relay is a framework that glues React
components and GraphQL requests together. React components define the data they need from a GraphQL schema in order
to render themselves, and Relay handles actually fetching GraphQL requests and marshalling data into the React
component tree. It is very efficient because of build-time optimizations by the Relay compiler.</p>

<p>The simplest use of Relay is a <a href="https://relay.dev/docs/en/fragment-container">fragment container</a>, which is created
from a React component and a <a href="https://blog.logrocket.com/graphql-fragments-explained/">GraphQL fragment</a>. (We're
going to skip over how the GraphQL query is made, but
<a href="https://relay.dev/docs/en/query-renderer">here are the docs on query renderers</a> if you're curious.)</p>

<pre><code class="js">class Artist extends React.Component {
  render() {
    return &lt;Text&gt;The artist name is ${this.props.artist.name}.&lt;/Text&gt;
  }
}

export ArtistFragmentContainer = createFragmentContainer(Artist, {
  artist: graphql` # artist will be passed in as props
    fragment Artist_artist on Artist { # Relay has strong naming conventions
      name # Get all the data we want here
    }
  `
})
</code></pre>

<p>(At Artsy, we use <a href="https://github.com/relay-tools/relay-compiler-language-typescript">TypeScript with Relay</a>, but
for this blog post we'll stick to JavaScript.)</p>

<p>So we have a plain React component that gets some props, and a Relay fragment container that wraps it, defining the
data that the component needs.</p>

<p>There are other types of Relay containers beyond simple fragment containers.
<a href="https://relay.dev/docs/en/refetch-container">Refetch containers</a> are like fragment containers except you can
refetch their contents from your GraphQL server (in response to, for example, user interaction). Using a refetch
container is very similar to using a plain fragment container. But today, we want to talk about
<a href="https://relay.dev/docs/en/pagination-container">pagination containers</a>, which use a GraphQL construct called
<em>connections</em> to show page after page of data.</p>

<p><a href="https://www.apollographql.com/blog/explaining-graphql-connections-c48b7c3d6976/">GraphQL connections</a> are beyond
the scope of this blog post, but they are a way to fetch lists of data without running into the limitations of
returning a simple array. Connections can return metadata about their results, like how many total results there
are, and use cursors (rather than page numbers) for paginating. They also handle when items are inserted or deleted
from the results between requests for pages ‚Äì
<a href="https://artsy.github.io/blog/2020/01/21/graphql-relay-windowed-pagination/">check out this blog post</a> for more
info on how to use connections with Relay.</p>

<p>Pagination containers take considerably more setup than plain fragment containers, and the setup itself is very
fickle. Things simply will not work until you get the configuration <em>exactly correct</em>, and then everything works
perfectly. The setup is largely repeated boilerplate, and what I've noticed (from other engineers but also myself)
is that the boilerplate for new pagination containers gets copy-and-pasted from existing ones. We will see how this
leads to small problems getting propagated throughout the codebase, and leads to engineers not feeling confident
when working in pagination containers.</p>

<p>So let's modify the Relay container above to fetch a list of the artist's artworks. This is a very simple example,
only used to illustrate how to use pagination containers.</p>

<pre><code class="js">class Artist extends React.Component {
  render() {
    return (
    &lt;Text&gt;The artist name is ${this.props.artist.name}.&lt;/Text&gt;
    {this.props.artist.artworks.edges.map(node =&gt;
      /* Render each artwork */
      &lt;Text key={node.id}&gt;{node.name}&lt;/Text&gt;
    )}
    {this.props.relay.hasMore() &amp;&amp;
      &lt;Button onPress={() =&gt; this.props.relay.loadMore() } text="Load next page" /&gt;
    )
  }
}

export ArtistFragmentContainer = createPaginationContainer(Artist, {
  artist: graphql`
    fragment Artist_artist on Artist
      @argumentDefinitions(
        count: { type: "Int", defaultValue: 10 }
        cursor: { type: "String" }
      ) {
      name
      id
      artworksConnection(first: $count, after: $cursor) @connection(key: "Artist_artworks") {
        edges {
          node {
            title # Now fetch all the artwork data
            id
          }
        }
      }
    }
  `
}, {
  direction: "forward",
  getConnectionFromProps(props) {
    return props.artist.artworks
  },
  getFragmentVariables(prevVars, count) {
    return {
      ...prevVars,
      count,
    }
  },
  getVariables(props, { count, cursor }, fragmentVariables) {
    return {
      id: props.artist.id,
      count,
      cursor,
    }
  },
  query: graphql` # Here is the query to fetch any specific page
    query ArtistArtworksQuery(
      $id: ID!
      $count: Int!
      $cursor: String) {
      artist(id: $id) {
        ...Artist_artist @arguments(
          count: $count
          cursor: $cursor
        )
      }
    }
  `
})
</code></pre>

<p>Wow, that's a lot! I don't want to get too bogged down in details, so let's break this apart at a high level:</p>

<ul>
<li>We changed the React component to show a list of artworks and include a button to load the next page.</li>
<li>We changed from <code>createFragmentContainer</code> to using <code>createPaginationContainer</code>.</li>
<li>We added GraphQL fragment variables for <code>count</code> and <code>cursor</code> to be passed through to the new
<code>artworksConnection</code>, which we also added.</li>
<li>Finally, we added a whole new configuration parameter to <code>createPaginationContainer</code>.</li>
</ul>


<p>This last bit is the part where I see the most frustration. Hopefully what follows will clear things up.</p>

<p>I like to always start by <a href="https://relay.dev/docs/en/pagination-container">reading the docs</a>. The <code>direction</code> key
is the direction that we paginate through, either <code>"forward"</code> or <code>"backward"</code>. <code>getConnectionFromProps</code> is a
function that returns the GraphQL connection, in case the query has more than one. And <code>query</code> is used to fetch any
specific page of results.</p>

<p>Those all makes sense to me, but then we arrive at the real gotchas: <code>getFragmentVariables</code> and <code>getVariables</code>. The
docs are helpful, but only if you understand
<a href="https://relay.dev/docs/en/runtime-architecture.html">the internals of how Relay works</a>. Relay has a sophisticated
architecture that delivers some really well-performing code, but its abstractions sometimes
"<a href="https://en.wikipedia.org/wiki/Leaky_abstraction">leak</a>" and you have to deal with underlying implementation
details of Relay (like <a href="https://relay.dev/docs/en/relay-store">the Relay store</a>) which you don't need to know about
<em>most</em> of the time.</p>

<p>So what are these two functions? Let's return to the docs:</p>

<ul>
<li><code>getFragmentVariables</code> is used when re-rendering the component, to retrieve the previously-fetched GraphQL
response for a certain set of variables.</li>
<li><code>getVariables</code> is used when actually fetching another page, and its return value is given to the <code>query</code>.</li>
</ul>


<p>I think of <code>getFragmentVariables</code> as a kind of caches key for lookup in Relay's internal store. Our implementation
of <code>getFragmentVariables</code> above doesn't really do anything interesting, but a connection that accepted <code>sort</code> or
<code>filter</code> parameters would need to return those to avoid lookup collisions when the user changed sort and filter
options.</p>

<p>Now for <code>getVariables</code>, which are the variables used for the <code>query</code> later on. It really ought to be named
<code>getQueryVariables</code>, I think. But I digress.</p>

<p>Every implementation of <code>getFragmentVariables</code> I could find at Artsy was identical, which makes sense because <em>that
is the default implementation</em>. We shouldn't be defining this option at all! As far as I can tell, Artsy started
with a few pagination containers that supplied this parameter unnecessarily and it got copy-and-pasted throughout
our codebases.</p>

<p>After revisiting the docs, I noticed other optional parameters that don't need to be defined either. Let's rewrite
the call to <code>createPaginationContainer</code> to only supply the parameters that are required:</p>

<pre><code class="js">export ArtistFragmentContainer = createPaginationContainer(Artist, {
  artist: graphql`
    fragment Artist_artist on Artist @argumentDefinitions(
      count: { type: "Int", defaultValue: 10 }
      cursor: { type: "String" } {
      name
      id
      artworksConnection (first: $count, after: $cursor) @connection(key: "Artist_artworks") {
        edges {
          node {
            title # Now fetch all the artwork data
            id
          }
        }
      }
    }
  `
  }, {
  getVariables(props, { count, cursor }, fragmentVariables) {
    return {
      id: props.artist.id,
      count,
      cursor,
    }
  },
  query: graphql` # Here is the query to fetch any specific page
    query ArtistArtworksQuery(
      $id: ID!
      $count: Int!
      $cursor: String) {
      artist(id: $id) {
        ...Artist_artist @arguments(
          count: $count
          cursor: $cursor
        )
      }
    }
  `
})
</code></pre>

<p>This is a lot nicer! By not specifying unnecessary options, we have a smaller surface area to make mistakes in. We
also have fewer overloaded terms, like "variables", so now it's more obvious that <code>getVariables</code> supplies data for
the <code>query</code> below it.</p>

<p>I've already <a href="https://github.com/artsy/eigen/pull/3711">sent a pull request</a> to clean up our use of pagination
containers in our React Native app, and will be following up on the web side next. But I wouldn't have discovered
this if I hadn't really dug into the docs, which I only did so that I could write this blog post. Earlier I said
that the solution to a knowledge gap is simple: learn, and then teach. I learned a lot about Relay today, and I
hope this blog post illustrates the value in the learn-then-teach approach.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Server-Rendering Responsively]]></title>
    <link href="https://artsy.github.io/blog/2019/05/24/server-rendering-responsively/"/>
    <updated>2019-05-24T00:00:00+02:00</updated>
    <id>https://artsy.github.io/blog/2019/05/24/server-rendering-responsively</id>
    <content type="html"><![CDATA[<p>We use server-side rendering (SSR) to deliver every page you hit on <a href="https://artsy.net">artsy.net</a>. We decided on
using SSR for many reasons, amongst them performance.
<a href="https://artsy.github.io/blog/2013/11/30/rendering-on-the-server-and-client-in-node-dot-js/">We wrote about this all the way back in 2013</a>!</p>

<p>We've also built our site using responsive design, so you get a browsing experience optimized for your device.</p>

<p>Combining SSR and responsive design is a non-trivial problem. There are many concerns to manage, and they are
sometimes in conflict with each other. We server render for performance reasons, but we also want to be sure our
app is performant when your browser takes over, all while optimizing for accessibility and SEO.</p>

<p>This article describes the tools we use on <a href="https://artsy.net">artsy.net</a> to combine SSR and responsive design.</p>

<!-- more -->


<a name="Tool.1:..code.styled-system..code."></a>
<h2>Tool 1: <a href="https://styled-system.com"><code>styled-system</code></a></h2>

<p>We handle the majority of responsive styling differences with
<a href="https://styled-system.com/responsive-styles"><code>styled-system</code></a>. This has been a really great addition to our
toolbox. Here's a component that would render a <code>div</code> (<code>Box</code>) with a width of 50% for small screens, 75% for
medium-sized screens, and 100% for anything larger:</p>

<pre><code class="xml">&lt;Box width={["50%", "75%", "100%"]}&gt;
  ...
&lt;/Box&gt;
</code></pre>

<p>Another example:</p>

<pre><code class="xml">&lt;Flex flexDirection={["column", "row"]}&gt;
  &lt;Box px={40} background="black10"&gt;
    ...
  &lt;/Box&gt;
&lt;/Box&gt;
</code></pre>

<p>While only one property in this example is specifying an array of values to be used at different breakpoints, all
of those properties <em>can</em> take an array for different breakpoints. As developers, we love this experience. We can
apply subtle differences to components across breakpoints with very little code and effort.</p>

<p>We use <a href="https://styled-system.com"><code>styled-system</code></a> extensively within
<a href="https://palette.artsy.net/">our design system</a>. You can
<a href="https://github.com/artsy/reaction/blob/32de03fe526355258655ded510d23335a456b9ce/src/Components/NavBar/Menus/MoreNavMenu.tsx#L23-L28">poke around our source</a>
to see how much we've embraced <a href="https://styled-system.com"><code>styled-system</code></a>'s responsive styles.</p>

<p>There's one type of challenge with building a responsive app that <a href="https://styled-system.com"><code>styled-system</code></a>
can't solve: when we need to emit different layouts across different breakpoints. In this case, we need something
that can render very different component sub-trees. We couldn't find an approach that satisfied our needs, so we
wrote our own.</p>

<a name="Tool.2:..code..artsy.fresnel..code."></a>
<h2>Tool 2: <a href="https://github.com/artsy/fresnel"><code>@artsy/fresnel</code></a></h2>

<p>First off, an announcement: we've just released <a href="https://github.com/artsy/fresnel"><code>@artsy/fresnel</code></a> version 1.0!</p>

<p><a href="https://github.com/artsy/fresnel"><code>@artsy/fresnel</code></a> allows you to define a set of breakpoint widths, then
declaratively render component sub-trees when those breakpoints are met. It looks something like this:</p>

<pre><code class="xml">&lt;&gt;
  &lt;Media at="xs"&gt;
    &lt;MobileLayout /&gt;
  &lt;/Media&gt;
  &lt;Media greaterThan="xs"&gt;
    &lt;NonMobileLayout /&gt;
  &lt;/Media&gt;
&lt;/&gt;
</code></pre>

<p>In this example, we're emitting the <code>MobileLayout</code> component for devices at or below our <code>xs</code> breakpoint, and the
<code>NonMobileLayout</code> for devices greater than our <code>xs</code> breakpoint. You can imagine that the <code>MobileLayout</code> and
<code>NonMobileLayout</code> components contain complicated sub-trees, with more significant differences than
<a href="https://styled-system.com"><code>styled-system</code></a> could handle.</p>

<a name="How.it.works"></a>
<h3>How it works</h3>

<p>The first important thing to note is that when server-rendering with
<a href="https://github.com/artsy/fresnel"><code>@artsy/fresnel</code></a>, <strong>all</strong> breakpoints get rendered by the server. Each <code>Media</code>
component is wrapped by plain CSS that will only show that breakpoint if it matches the user's current browser
size. This means that the client can accurately start rendering the HTML/CSS <em>while</em> it receives it, which is long
before the React application has booted. This improves perceived performance for end-users.</p>

<p>Why not just the breakpoint that the current device needs? Because we can't <em>accurately</em> identify which breakpoint
your device needs on the server. We could use a library to sniff the browser <code>user-agent</code>, but those aren't always
accurate, and they wouldn't give us all the information we need to know when we are server-rendering.</p>

<p>If you're interested, you can
<a href="https://github.com/artsy/reaction/issues/1367">read the issue that originally inspired us to build <code>@artsy/fresnel</code></a>.
One of the neat things about Artsy being <a href="/series/open-source-by-default/">open-source by default</a> is that you can
see decisions being made and libraries being built <em>as they happen</em>; not just after they're complete.</p>

<a name="Tool.3:..code..artsy.detect-responsive-traits..code."></a>
<h2>Tool 3: <a href="https://github.com/artsy/detect-responsive-traits"><code>@artsy/detect-responsive-traits</code></a></h2>

<p>I mentioned above that it's difficult to accurately detect devices by user agent to identify which breakpoint to
render. We didn't want this to be our primary strategy for combining SSR with responsive design.</p>

<p>But with <a href="https://github.com/artsy/fresnel"><code>@artsy/fresnel</code></a> as our primary approach, we felt that we could make
some further optimizations with user agent detection. In the event that we don't know your device by its user
agent, we'll still render all breakpoints on the server. But if we are certain you are on a device that only ever
needs a subset of the breakpoints, we only render those on the server. This saves a bit of rendering time; more
importantly it reduces the number of bytes sent over the wire.</p>

<p>We really wanted to not maintain our own list of user agents. Alas, we found that none of the existing user agent
detection libraries surfaced all the information we needed in a single resource. We needed to know the minimum
width for a browser on a given device, and if it was resizable, and to what dimensions it was resizable. If any
existing libraries <em>did</em> have this data, they didn't provide it to us easily.</p>

<p>So we did some experimentation, given the browsers and devices we knew we needed to support. And yeah...we
(reluctantly) created our own user-agent detection library,
<a href="https://github.com/artsy/detect-responsive-traits">@artsy/detect-responsive-traits</a>. We're using this to determine
if your browser is likely going to use only the mobile breakpoint of our app, in which case we don't have to also
render the desktop version. The library is currently targeting only the browsers and devices we support on
<a href="artsy.net">artsy.net</a>, but
<a href="https://github.com/artsy/detect-responsive-traits">we're always open to contributions</a>!</p>

<p>We aren't doing any detection of desktop browsers. They are more resizable than mobile browsers, and we are more
concerned with mobile users getting less content sent over their 3G connection.</p>

<a name="Why.didn.t.you.___."></a>
<h2>Why didn't you ___?</h2>

<p>Those are our primary tools for combining SSR with responsive design! They work well for us. We considered many
many other options along the way. Here are a couple:</p>

<a name="L.code.react-media..code..or..code.react-responsive..code."></a>
<h3><a href="https://github.com/ReactTraining/react-media"><code>react-media</code></a> or <a href="https://github.com/contra/react-responsive"><code>react-responsive</code></a></h3>

<p>We investigated both <a href="https://github.com/ReactTraining/react-media"><code>react-media</code></a> and
<a href="https://github.com/contra/react-responsive"><code>react-responsive</code></a>, but found that they didn't approach the SSR side
of the problem as deeply as we needed.</p>

<p>We also weren't fans of the imperative API in <a href="https://github.com/ReactTraining/react-media"><code>react-media</code></a>. We
started with a similar API when building <a href="https://github.com/artsy/fresnel"><code>@artsy/fresnel</code></a>, but found ourselves
inhibited by the restriction that only one branch can be rendered. This contradicted our strategy of emitting all
breakpoints from the server.</p>

<p>With <a href="https://github.com/contra/react-responsive"><code>react-responsive</code></a>, we didn't like that it relied on user agent
detection as its primary method of handling SSR.</p>

<a name="Rely.solely.on.CSS"></a>
<h3>Rely solely on CSS</h3>

<p>As mentioned before, we render all breakpoints from the server and hide the non-matching branches with CSS. The
issue with this approach, when combined with React, is that after
<a href="https://reactjs.org/docs/react-dom.html#hydrate">hydration</a> you have many components that are mounted and rendered
unnecessarily. There's a performance hit you take for rendering components your user isn't seeing, but even worse
is the potential for duplicate side-effects.</p>

<p>Imagine a component that, when rendered, emits a call to an analytics service. If this component exists in both a
mobile and desktop branch, you're now double-stuffing your analytics. Hopefully your analytics service is smart
enough to count only one call, but it's still a bad idea to duplicate components that have side-effects.</p>

<p><a href="https://github.com/artsy/fresnel"><code>@artsy/fresnel</code></a> will only client-render the breakpoint that matches your
browser dimensions, so you don't have to worry about duplicate side-effects.</p>

<a name="What.s.left.to.solve."></a>
<h2>What's left to solve?</h2>

<p>Our SSR and responsive design toolbox does a lot of things well. We get great performance from both the server and
client. Our site looks great on any device.</p>

<p>We do have some SEO concerns, though. Since we're server-rendering multiple breakpoints, it's likely that search
engine bots are seeing double the content on our pages. We <em>think</em> this is okay.
<a href="https://youtu.be/WsgrSxCmMbM">Google WebMasters</a> says it's okay. We haven't noticed any awful side-effects from
this yet, but SEO is a bit of a dark art, yeah?</p>

<a name="Our.advice"></a>
<h2>Our advice</h2>

<p>Responsive design is hard, especially when layouts change significantly between desktop and mobile. Server-side
rendering in React is hard to get right, period. Combining SSR with responsive design compounds the challenges.</p>

<p>At the end of the day, you should do everything you can to limit layout differences between mobile and desktop. Use
responsive props from <a href="https://styled-system.com"><code>styled-system</code></a>. Play around with <code>flexbox</code> and
<code>flex-direction</code>, start learning about CSS <code>grid</code>, and use CSS <code>@media</code> queries when you can. If you absolutely
must render different views on different breakpoints, render all the UI and hide what's not needed for that
breakpoint. You want your users to see the right content as quickly as possible. Send them HTML and CSS from your
server that their client can use.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rosalind and The Art Genome Project]]></title>
    <link href="https://artsy.github.io/blog/2019/05/09/rosalind/"/>
    <updated>2019-05-09T00:00:00+02:00</updated>
    <id>https://artsy.github.io/blog/2019/05/09/rosalind</id>
    <content type="html"><![CDATA[<p>We recently bade a fond farewell to two <a href="https://code.dblock.org">of</a> <a href="http://orta.io">the</a> champions of our ‚Äúopen source by default‚Äù ethos, but
this spirit lives on at Artsy.</p>

<p>Today we open-source one of our key metadata apps, and explain how it fits into Artsy‚Äôs ecosystem.</p>

<!-- more -->


<a name="Open.source.by.default....or.at.least.eventually"></a>
<h2>Open source by default‚Ä¶ or at least eventually</h2>

<p>Even when we don‚Äôt start a project by building in the open, we encourage ourselves to question why that is so. Can
we go ahead and open things up? If the answer is no (and it might be), are we clear on why not?</p>

<p>We‚Äôve even added a <a href="https://github.com/artsy/peril-settings/pull/96">light bit of process</a> to promote this kind of questioning. Our robots will periodically
trawl our GitHub org and file an issue against any closed-source repo that doesn‚Äôt include a rationale for its
closed nature in the project README.</p>

<p><figure class="illustration">
  <img alt="Peril issue" src="/images/2019-05-09-rosalind/issue.png"  />
  <figcaption>Robot would like to have a word with you</figcaption>
</figure></p>

<p>One of our repos got this <a href="https://github.com/artsy/rosalind/issues/179">treatment</a> recently. I‚Äôm the point person on this project, and while I considered
adding a rationale of ‚Äú<em>primary author will die of acute impostor syndrome if this repo is open-sourced, he will
just stop living</em> üòÖ,‚Äù instead we‚Äôve gone ahead and made this repo public.</p>

<p>Meet <a href="https://github.com/artsy/rosalind">Rosalind</a>, an admin app for large-batch genoming operations on Artsy‚Äôs database of artworks.</p>

<a name="The.Art.Genome.Project..and.the.Genome.Team"></a>
<h2>The Art Genome Project, and the Genome Team</h2>

<p>Rosalind is a close cousin of <a href="https://github.com/artsy/helix">Helix</a>, our original dedicated genoming app. (That project is private for
now, but was described by <a href="https://artsy.github.io/author/sarahweir/">Sarah</a> in an an <a href="/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react">earlier blog post</a>.)</p>

<p>What‚Äôs genoming, you ask, and what‚Äôs it got to do with art?</p>

<p>Artsy‚Äôs discovery and recommendation capabilites are powered in large part by <a href="https://www.artsy.net/about/the-art-genome-project">The Art Genome Project</a>,
a comprehensive system of classification that uses our homegrown art-historical controlled vocabulary to describe
the artists and artworks in our database. (Here‚Äôs an <a href="https://www.artsy.net/article/the-art-genome-project-seven-facts-about-the-art-genome-project">explainer</a> and our full list of
<a href="https://www.artsy.net/categories">categories</a>. You can even view a <a href="https://github.com/artsy/the-art-genome-project">structured data export</a> of the ‚Äúgenes‚Äù which make
up our controlled vocabulary.)</p>

<p><figure class="illustration">
  <img alt="Helix" src="/images/2019-05-09-rosalind/helix.png"  />
  <figcaption>Screenshot of Helix, an app for genoming artists and artworks, and an early foray into React</figcaption>
</figure></p>

<p>For a long time, our team of art historians ‚Äî the Genome Team ‚Äî bore sole responsibility for applying this
vocabulary, using Helix, to the artworks that entered our platform. This was always a daunting task, and only
became more so as our network of partner galleries and institutions continued to grow and upload more artworks.</p>

<p>Artsy is now home to over 1,000,000 artworks by over 100,000 artists, described by over 1,000 genes. A few years
ago, it became clear to us that in order to continue applying high-quality metadata at scale, we were going to need
some new processes and some new tools.</p>

<p>On the process side, we decided to share a simplified genoming interface with our gallery partners, so that they
could start contributing the metadata that would be most relevant to our audience of collectors. We called it
‚ÄúPartner Applied Categories.‚Äù</p>

<p><figure class="illustration">
  <img alt="Partner applied categories" src="/images/2019-05-09-rosalind/cms-pac.png"  />
  <figcaption>Partner Applied Categories interface from Artsy‚Äôs partner CMS, showing choices for works of photography</figcaption>
</figure></p>

<p>Note that this is a tiny subset of our full genome vocabulary, and that values are applied as on/off, versus the
more nuanced 0-100 score that our own Genome Team would apply.</p>

<p>This was a good step, a fundamental building block in scaling artwork metadata on our platform, but it created new
problems as well as new opportunities.</p>

<p>This is where Rosalind came in.</p>

<a name="About.Rosalind"></a>
<h2>About Rosalind</h2>

<p>We started work on this tool in earnest in early 2017, at a time when we felt an internal need for the ability to,
among other things:</p>

<ul>
<li><p>Perform boolean searches against our database of artworks using The Art Genome Project‚Äôs vocabulary ‚Äì a general
purpose superpower that would be useful for our art historians, our editorial team, and our collector relations
and marketing teams, among others</p></li>
<li><p>Make large-batch modifications to artworks‚Äô genomes (whether genomed by us, or by our gallery partners via
Partner Applied Categories), in order to maintain metadata quality</p></li>
</ul>


<p>The user experience we built looks something like this:</p>

<p><figure class="illustration">
  <img alt="Rosalind session" src="/images/2019-05-09-rosalind/rosalind.gif" style="outline: solid 1px #eee" />
  <figcaption>A sample admin interaction in Rosalind</figcaption>
</figure></p>

<p>Under the hood this is a Rails 5 application that talks to our core API server and our Elasticsearch cluster on the
backend, and serves up a React single page app on the frontend.</p>

<p><figure class="illustration">
  <img alt="Rosalind architecture" src="/images/2019-05-09-rosalind/architecture.png" />
  <figcaption>Bird‚Äôs eye view of Rosalind‚Äôs architecture</figcaption>
</figure></p>

<p>Among the tactical goals of this project were to support heavy-duty admin workflows by:</p>

<ul>
<li>offering a featureful interface tailored to power users</li>
<li>adding a useful complement of keyboard navigation capabilities</li>
<li>making it as blazingly fast as possible</li>
</ul>


<p>That last goal led to the somewhat quirky decision to have Rosalind talk to the Elasticsearch cluster directly,
instead of making a search request to our core API server.</p>

<p>While this entails some risk of drift from our accumulated search best practices as encapsulated in our API, in
reality this has not been a problem yet. Rosalind‚Äôs search needs are fairly straightforward and using
Elasticsearch‚Äôs REST API has been working out just fine. And it is fast as heck.</p>

<p>Although the project was mostly built out in early 2017, we‚Äôve periodically revisited it for upkeep and
maintenance. Along the way we‚Äôve ridden some of the larger trends in the React+Rails ecosystem, as well as internal
trends.</p>

<ul>
<li><p>We started out on <a href="https://github.com/mipearson/webpack-rails">webpack-rails</a>, an early pioneer in nudging Rails away from the Asset Pipeline
provided by Sprockets, and toward Webpack</p></li>
<li><p>We <a href="https://github.com/artsy/rosalind/pull/157">migrated</a> over to the <a href="https://github.com/rails/webpacker">Webpacker</a> gem once that became a core Rails concern</p></li>
<li><p>We <a href="https://github.com/artsy/rosalind/pull/158">migrated</a> from RSpec feature specs to <a href="https://guides.rubyonrails.org/testing.html#system-testing">Rails system tests</a>, after that was
rolled out</p></li>
<li><p>We experimented with adopting <a href="https://github.com/artsy/reaction">Reaction</a>, our shared internal React component library</p></li>
<li><p>We more recently switched to using <a href="https://github.com/artsy/palette">Palette</a>, our nascent design system library</p></li>
</ul>


<p>After being in maintenance mode for a couple of years, we‚Äôre excited to start up new feature work again, and plan
to bring even more bits of the <a href="https://artsy.github.io/series/omakase">Artsy Omakase</a> into this project. Maybe this project will even be a
good proving ground for <a href="https://github.com/prettier/plugin-ruby">prettier-ruby</a>.</p>

<p>Whatever happens, Rosalind will continue to play an important role in maintaining Artsy‚Äôs high-quality metadata and
in making Artsy the best online destination for art.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A History of Artsy's Web Frontend]]></title>
    <link href="https://artsy.github.io/blog/2018/10/04/artsy-frontend-history/"/>
    <updated>2018-10-04T00:00:00+02:00</updated>
    <id>https://artsy.github.io/blog/2018/10/04/artsy-frontend-history</id>
    <content type="html"><![CDATA[<p>As Artsy Engineering grows in 2018, we have so many newcomers looking for context: they want to understand the
systems they'll be working in day-to-day. Awesome! But it's not enough to understand the systems themselves, it's
often helpful to understand the <em>history</em> of how we ended up where we are.</p>

<p>Frontend web development has changed a <em>lot</em> during Artsy's existence, and it continues to advance at a blistering
pace. It's easy to get caught up in the churn of frameworks and languages and tools, so I want to use this post as
an opportunity to contextualize each transition that Artsy's web presence has made over the past seven years. We've
changed technologies, but we've tried to do so with care and attention. Documenting these decisions is important
(and is ideally done <a href="https://ashfurrow.com/blog/contemporaneous-blogging/">contemporaneously</a>), but even with the best documentation, <a href="https://github.com/artsy/artsy.github.io/pull/489#discussion_r221301472">sometimes our own documentation
is unclear to us</a>.</p>

<p>In an effort to help contextualize our web frontend (which is <a href="https://github.com/artsy/force">open source</a>), this blog post will document
the major transitions that Artsy's web presence has made over the past seven years. Let's begin!</p>

<!-- more -->


<a name="Backbone...CoffeeScript"></a>
<h2>Backbone + CoffeeScript</h2>

<p>Artsy as you know it today began as a standard Rails application. We ran <code>git init</code> in January 2011, which coupled
our backend API to our web frontend, but since our frontend was just a fancy user interface for our API, this
worked for over two years. The web app itself was a kind of simplified MVC ‚Äì controller logic lived inside the
views and models dealt with backend communication and notifying the view of state changes. For CSS, we used the
SASS CSS preprocessor. The Rails backend served initial pages that were then populated with follow-up API calls
made on the client-side. At a <em>very</em> high level, this isn't <em>that</em> different from what we do today with React.</p>

<p>Our site was built with a framework called <a href="http://backbonejs.org">Backbone</a>, which was really well-suited for our needs at the time.
From their documentation:</p>

<blockquote><p>Philosophically, Backbone is an attempt to discover the minimal set of data-structuring (models and collections)
and user interface (views and URLs) primitives that are generally useful when building web applications with
JavaScript. In an ecosystem where overarching, decides-everything-for-you frameworks are commonplace, and many
libraries require your site to be reorganized to suit their look, feel, and default behavior ‚Äî Backbone should
continue to be a tool that gives you the <em>freedom</em> to design the full experience of your web application.</p></blockquote>

<p>As an outsider to the web at that time, I can't comment too heavily on Backbone. It seems like the freedom
(emphasis theirs) that they describe is a freedom from tangled jQuery code everywhere. I think our definition of
freedom on the web frontend has evolved since then, but that's just my feeling.</p>

<p>The other key component to our web frontend was <a href="https://coffeescript.org">CoffeeScript</a>. According to its documentation, "CoffeeScript is
a little language that compiles into JavaScript", which was pretty important at the time. JavaScript in 2011 was
very different from JavaScript today. The CoffeeScript docs also state that "JavaScript has always had a gorgeous
heart", which I'm not sure I'd agree with to be honest, but the CoffeeScript project really shows how a handful of
engineers working to improve something they care about can change an entire industry. While I don't think
contemporary JavaScript would have gotten as good as it has without CoffeeScript, it's a bit anachronistic to see
it used today.</p>

<p>Our goal as a (very small!) engineering team at the time was to keep our moving parts to a minimum.
Rails+SASS+CoffeeScript+Backbone helped us achieve that goal, and we couldn't have gotten this far without the help
of those projects.</p>

<a name="Ezel..amp..Friends"></a>
<h2>Ezel &amp; Friends</h2>

<p>In November 2013, we split our web frontend from the API backend. You can read
<a href="2013_review">all the details in this blog post</a>, but the story is summarized nicely as "moving from a single
monolithic application to modular Backbone apps that run in Node and the browser and consume our external API."
This move from monolith to modular systems continues to influence day-to-day work on the Artsy Engineering team.</p>

<p>We had already started moving away from a typical Rails app by moving our API to <a href="https://github.com/ruby-grape/grape">Grape</a> in order to support an
iOS application. The monolith also had some clear drawbacks including severe page load times, maintaining
duplicated backend and frontend UI templates, slow test suites, and poor developer productivity. We took the
project of building our mobile web frontend, m.artsy.net (still known as "martsy" internally) as an opportunity to
address these problems.</p>

<p>We built our new site with <a href="https://github.com/ruby-grape/grape">Node.js</a> since it allowed us to share and consolidate our server/client rendering
code. We split out areas of concern into separate "apps", with their own bundled CSS/JS to help page load times. We
server-side rendered above-the-fold content and used client-side JS to load the rest, which helped SEO and user
experience. We took a <a href="http://getbem.com/introduction/">BEM</a>-like approach to our CSS, which helped developer productivity. Our technical
decisions were driven primarily by our desire to create great user experiences.</p>

<p>And because we are an open source by default organization, we collected these approaches into an open source
project called <a href="https://github.com/artsy/ezel">Ezel</a>. While our main app used this Ezel approach, other new web apps ‚Äì CMS systems for our
partners, auction-management systems for our admins, etc ‚Äì were built on new internal tools to share assets and
code across the apps. We experimented a lot; we got pretty good at sharing resources across codebases. Most of our
web projects started on Heroku before moving to heavier-duty deployments as needed. Our frontend mindset at the
time (2015) was focused on getting to a stable, predictable stack. However... we started experimenting with React
around the same time.</p>

<p>CoffeeScript and Backbone were still working for us, and we still use them in production in many systems. However,
the state of the art in web development moved on. When I joined the auctions team and helped maintain one of our
CoffeeScript+Backbone apps, I was <em>very</em> confused about how data flowed from one part of the app to another, across
languages, with a lot of magic happening. I think that's typical in these kinds of apps ‚Äì "convention over
configuration" is a good mantra <em>if</em> you can expect that incoming engineers are familiar with the conventions.
That's just not the case anymore.</p>

<p>By 2016, we had <a href="http://artsy.github.io/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react/">experimented with React</a> and followed up with <a href="http://artsy.github.io/blog/2016/08/09/the-tech-behind-live-auction-integration/">another app built with the
technology</a>. React (and Redux) were very well-suited for our realtime auction bidding UI, and would later
prove helpful in our <a href="https://github.com/artsy/positron">editorial CMS</a>. These experiences helped prove the technology was ready for
production use <em>and</em> convinced us that React was great at reducing the complexities of building user interfaces
(the realtime nature of our auctions product was particularly well-suited for Redux's state management; it was our
first from-scratch React app).</p>

<p>When the Artsy business require us to make changes to how we build software, like splitting up our monolith, we try
to take full advantage of those changes to improve how we work, which means evaluating new tools. Adopting Node.js
and Ezel wouldn't make sense today, but at the time, they helped us scale up Artsy's business without the same
scaling up of our engineering resources. Ezel helped us do more with less, which is still an important criteria we
use for evaluating new tools.</p>

<a name="React"></a>
<h2>React</h2>

<p>By 2017, the divisions between our mobile frontend and web frontend teams had been totally dissolved (as they
should ‚Äì the division between mobile and web developers is a false dichotomy). Our <a href="http://artsy.github.io/blog/2017/04/14/artsy-technology-stack-2017/">2017 tech stack
post</a> discusses this in depth, but our goal was really to unify the paradigm that frontend engineers
at Artsy use to build user interfaces, whether that's on mobile or web. React and React Native were our answer to
that challenge.</p>

<p>On the web side of things, however, Artsy had another challenge. Sure, React is great, and sure, it's how we want
to build user interfaces, but how do we get there? We're not fans of large rewriting projects, so we opted for what
we call an "incremental revolution" approach. We built a library called <a href="https://github.com/artsy/stitch">Stitch</a> that would let us mount React
components inside our existing app. Using this approach, we could migrate to React component-by-component. We've
been using Stitch in production for over a year and have been very happy with its approach; you can read more
details of integrating it into our main frontend app <a href="http://artsy.github.io/blog/2017/09/05/Modernizing-Force/">in this blog post</a>.</p>

<p>Today, principal React work takes place in <a href="https://github.com/artsy/reaction">a shared components repo</a>. We share these components across
several of our web apps using Stitch. We have been pretty pleased with the results! But our dive into React is only
just beginning. The community is moving quickly to figure out what best practices make sense in the React paradigm,
and we're a part of that. We are evaluating technologies like <a href="https://www.styled-components.com">styled-components</a> and <a href="https://jxnblk.com/styled-system/">styled-system</a> to create
a universal design system within Artsy. The area is under very active development, so I'll save details for a
future blog post.</p>

<p>I can't go too much further without talking about GraphQL. v1 of our API (REST) is still in use around much of
Artsy and, despite the best efforts of some of our engineers, v2 of our API (<a href="http://stateless.co/hal_specification.html">HAL</a>) hasn't gained significant
internal use yet. Instead, we found ourselves building a <a href="https://graphql.org">GraphQL</a> server to orchestrate API calls to our
existing APIs. This confers many benefits, which I describe from a mobile perspective in some detail <a href="https://ashfurrow.com/blog/the-spirit-of-moya/">here</a>.
The key thing to understand about our GraphQL server, <a href="https://github.com/artsy/metaphysics/">which is open source</a>, is that it is under the
stewardship of our frontend engineers, not our platform engineers. That's not to say that our platform team isn't
involved with its development ‚Äì in fact, they've been key to scaling it up ‚Äì but Artsy frontend engineers created
the server to help us build better UIs, and while the technology is still very new, we continue to see it pay
dividends.</p>

<p>Okay so remember earlier when I said that we dissolved our mobile team? Well, I was on that team and it wasn't like
our mobile engineers all learned how Artsy does web ‚Äì we brought our culture and tools with us and, together with
our web colleagues, have built an integrated engineering team that's greater than the sum of its parts. One thing
that was important to mobile engineers was type safety, so we had to have a conversation about JavaScript.</p>

<p>On its own, JavaScript can't guarantee type safety. We investigated two options: <a href="http://www.typescriptlang.org">TypeScript</a> and <a href="https://flow.org">Flow</a>. <a href="http://artsy.github.io/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/">This
blog post</a> goes into detail about our decision, but tl;dr we chose TypeScript. We have been building (and
helping to build) tools <a href="https://github.com/relay-tools/relay-compiler-language-typescript">relay-compiler-language-typescript</a> to take full advantage of interoperability
between TypeScript types and GraphQL types through <a href="https://facebook.github.io/relay/">Relay</a>, as well as using Babel 7 to migrate existing projects
to TypeScript incrementally, which you can read about in more detail <a href="https://artsy.github.io/blog/2017/11/27/Babel-7-and-TypeScript/">here</a>. It's all very exciting ‚Äì you
can read more on how Relay and GraphQL interoperate <a href="http://artsy.github.io/blog/2018/07/25/Relay-Networking-Deep-Dive/">in this blog post</a>.</p>

<p>We started building software in React not because it was trendy, but because it helped our engineering team deliver
more value to the business. It's been a huge success, but not without its costs. We've tried to mitigate those
costs by using tools like Stitch to migrate apps to React incrementally, and through spreading knowledge of how our
stack through internal knowledge-sharing like <a href="http://artsy.github.io/series/javascriptures/">JavaScriptures</a>. While the transition to React has had its costs,
<em>not</em> moving would also be costly, too.</p>

<hr />

<p>Since I joined Artsy, I've seen us continually investing in tooling that helps us build better software. The
results of this culture-of-continuous-improvement speak for themselves: with fewer than 30 engineers total, we
support a growing company with a suite of software built for many canvasses <em>and</em> we have an outsized impact on the
software industry relative to our size. Our frontend web stack is just one facet of our evolving technology ‚Äì
there's lots of exciting stuff on the backend, too (<a href="https://github.com/artsy/hokusai">for example...</a>). Through my research for this blog
post, I learned a lot about what drives technological decisions on our team. From humble beginnings as a Rails app,
to CoffeeScript and Bootstrap, to React and GraphQL, Artsy Engineering has evolved our frontend software to achieve
a quality worthy of art ‚Äì both from the user's perspective and from the developer's. I'm very excited about what's
coming next, and I can't wait to share it with you. Have a great day!</p>
]]></content>
  </entry>
  
</feed>
