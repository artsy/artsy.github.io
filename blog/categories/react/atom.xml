<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/react/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2024-05-17T14:49:02+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Context to Simplify a VERY Large React Form]]></title>
    <link href="https://artsy.github.io/blog/2022/02/01/using-context-to-simplify-a-react-form/"/>
    <updated>2022-02-01T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2022/02/01/using-context-to-simplify-a-react-form</id>
    <content type="html"><![CDATA[<p>For those unfamiliar, Artsy is a fine art marketplace. Knowing that, it follows logically to say that the form via
which our partners list artworks for sale is an integral part of Artsy’s core systems. This form, known only as
“The Artwork Form,” is whispered about in the halls of Arty’s New York headquarters. It is legendary. It is a
colossus. It is old enough not only to predate React v16.8 hooks and context APIs, but Artsy’s use of React
entirely. The first version of the Artwork Form was built in 2014 using ruby and haml, and began its refactoring
into JS/JQuery/React a full 2 years later, after having expanded considerably from the original implementation.
That process (at least what we’ve gleaned from our git excavation) was incremental, experimental, and passed
through many hands before it landed in the lap of the current Partner Experience (PX) team.</p>

<!-- more -->

<p>PX has since been tasked with the maintenance of this unwieldy kaiju, spending endless amounts of time on seemingly
insignificant changes to behavior or UI, all while watching its performance degrade. Many of the people reading
this are already familiar with the story we’re telling. Many have worked in their very own version of the tale, and
borne witness to the fact that legacy code of this scale becomes a living, breathing entity. The developers that
tend these beasts learn their patterns and idiosyncrasies, their little moans and groans, and for the sake of
expediency work within those constraints to accomplish their tasks. But when is enough, enough? When does the
developer time expended working within the constraints of an obsolete design begin to outweigh the time it would
take to simply <em>fix</em> <em>the code</em>?</p>

<p>First, let’s be honest: there is no single right answer to this question. When working in software development we
have to deal with certain realities: user experience vs. developer experience, lead time to the next release,
buy-in from stakeholders, etc. These factors may weigh more or less depending on the shop and the product. At Artsy
we’re very lucky, in that our engineering department is given the time to attend to our tech debt and to be
deliberate about when and how we go about this. In the case of the Artwork Form, there were several issues that had
become too glaring to ignore:</p>

<ol>
  <li>The data coming in, and subsequently being passed to individual components, was being completely obscured by the
amount of prop drilling and spreading that existed within the composed form.</li>
  <li>The prolific use of <code class="language-plaintext highlighter-rouge">any</code> when typing data was disabling typescript and consequently removing its usefulness
while still imposing all of its burdens.</li>
  <li>The components within the form were tightly coupled, the number and specificity of props needed for each
disallowing reuse in other parts of the app.</li>
</ol>

<p>A few of us on the PX team decided to take matters into our own hands and address some of these key problems with
the Artwork Form. We came up with a plan to incrementally convert the form to use values from the Formik context,
use these values wherever possible to reduce prop-drilling, add much more complete types to the components to get
rid of all the <code class="language-plaintext highlighter-rouge">any</code>’s, and update some of our testing strategies as needed.</p>

<p>Here are the steps we took to do this conversion:</p>

<ol>
  <li>
    <p>Create a hook that allows us to use the Formik context throughout the form</p>

    <p>The hook wraps <a href="https://formik.org/docs/api/useFormikContext"><code class="language-plaintext highlighter-rouge">useFormikContext</code></a> to allow all of our components
inside of Formik to access the values from Formik context. It looks like this:</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nx">useArtworkForm</span><span class="p">():</span> <span class="nx">FormikContextType</span><span class="o">&lt;</span><span class="nx">ArtworkValues</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">formikContext</span> <span class="o">=</span> <span class="nx">useFormikContext</span><span class="o">&lt;</span><span class="nx">ArtworkValues</span><span class="o">&gt;</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">formikContext</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>We use <code class="language-plaintext highlighter-rouge">ArtworkValues</code> as the generic type so that when we are accessing <code class="language-plaintext highlighter-rouge">values</code> anywhere inside the component
tree, <code class="language-plaintext highlighter-rouge">values</code> can be type-checked.</p>
  </li>
  <li>Convert all of the components in the form to functional components and to TypeScript. (Because the form is
several years old, there were still many class components and many components that were not yet using
TypeScript.) This step could be done in parallel with Step 1. One note here is that when converting files from
JavaScript to TypeScript, we did not explicitly type the props in an interface. Once we can take advantage of
our <code class="language-plaintext highlighter-rouge">useArtworkForm</code> hook, we will reduce the amount of props needed in each component, so we will hold off on
typing the props until step 3.</li>
  <li>
    <p>The bulk of the work was making use of the <code class="language-plaintext highlighter-rouge">useArtworkForm</code> hook in the Artwork Form components. Starting with
the lowest leaves of the component tree and moving up, we removed the <code class="language-plaintext highlighter-rouge">props</code> from the component definition and
destructured any values we needed in the component from the <code class="language-plaintext highlighter-rouge">useArtworkForm</code> hook. Once we used everything we
could from the context, we added back in any additional props that we would still need to have passed down from
the parent. In many cases, this was no props at all—a particularly satisfying case. If the component still
needed props passed down, we explicitly typed the props at the top of each component in an interface because we
now knew exactly which props we would need inside of the component. Another key step here was going into the
parent component and getting rid of any prop spreading (this: <code class="language-plaintext highlighter-rouge">...props</code>) and instead explicitly passing down
exactly the props needed in the component (if there were any).</p>

    <ol>
      <li>A note on tests: Whenever we took advantage of the Formik context in a component, we were breaking that
component’s tests, because the wrappers we were using in the tests did not have access to the Formik context
and were being passed props that the component was no longer looking at. We created a helper test wrapper
that we could use in all of our Artwork Form tests to wrap the test’s specific wrapper inside of a
<code class="language-plaintext highlighter-rouge">&lt;Formik/&gt;</code> component and provide the specific <code class="language-plaintext highlighter-rouge">values</code> to use as the initial values for <code class="language-plaintext highlighter-rouge">Formik</code>. Many of
our test cases involve passing different <code class="language-plaintext highlighter-rouge">values</code> into the component, which we originally did via props but
now will do via the Formik context through the wrapper. Here’s what the wrapper looks like:</li>
    </ol>

    <div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">const</span> <span class="nx">TestFormikWrapper</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">FC</span><span class="o">&lt;</span><span class="nx">TestFormikWrapperProps</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">values</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">props</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">Formik</span> <span class="na">initialValues</span><span class="p">=</span><span class="si">{</span><span class="nx">values</span><span class="si">}</span> <span class="na">onSubmit</span><span class="p">=</span><span class="si">{</span><span class="nx">jest</span><span class="p">.</span><span class="nx">fn</span><span class="p">()</span><span class="si">}</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">children</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nc">Formik</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>Here is an example of <code class="language-plaintext highlighter-rouge">TestFormikWrapper</code> used in a test:</p>

    <div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">describe</span><span class="p">(</span><span class="dl">"</span><span class="s2">TestComponent</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">it</span><span class="p">(</span><span class="dl">"</span><span class="s2">displays values</span><span class="dl">"</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">wrapper</span> <span class="o">=</span> <span class="nx">mount</span><span class="p">(</span>
      <span class="p">&lt;</span><span class="nc">TestFormikWrapper</span> <span class="na">values</span><span class="p">=</span><span class="si">{</span><span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Andy Warhol</span><span class="dl">"</span> <span class="p">}</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">TestComponent</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nc">TestFormikWrapper</span><span class="p">&gt;</span>
    <span class="p">)</span>

    <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">wrapper</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="dl">"</span><span class="s2">#name</span><span class="dl">"</span><span class="p">).</span><span class="nx">html</span><span class="p">()</span>
    <span class="nx">expect</span><span class="p">(</span><span class="nx">name</span><span class="p">).</span><span class="nx">toInclude</span><span class="p">(</span><span class="dl">"</span><span class="s2">Andy Warhol</span><span class="dl">"</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div>    </div>
  </li>
  <li>Once we completed the conversion all the way up the tree to the root component, the <code class="language-plaintext highlighter-rouge">ArtworkForm</code>, we typed that
component as strictly as possible and made sure to get rid of <code class="language-plaintext highlighter-rouge">any</code>’s. There were quite a few when we started
the process.</li>
</ol>

<p>So, where did we end up? Now all of the components in the Artwork Form are making use of the <code class="language-plaintext highlighter-rouge">useArtworkForm</code> hook
if they were previously accessing any of the values from the Formik context from props. We have much less prop
drilling between components and instead explicitly pass down the props needed from parent to child. It’s now much
more clear for developers what data is passing between the components and what data is actually being used in the
child. All of the components are also explicitly typed so we know exactly which props, if any, need to be passed
down from the parent. If any of these props are removed, TypeScript helps us by failing loudly.</p>

<p>One of the main pain points of the Artwork Form is that it’s very difficult for new developers (whether new to
Artsy or new to the Partner Experience team) to contribute and make changes to the form without breaking something
or spending extra time figuring out how data is passed within the form. Hopefully, this change will make it easier
for developers to understand the Artwork From.</p>

<p>How did the Artwork Form get so complicated? Well, as we shared, the Artwork Form is the key to achieving one of
the PX team’s core goals: surfacing the most accurate and rich information about artworks to collectors. We have to
allow partners to add more and increasingly specific pieces of metadata to artworks. The form has been growing and
for better or worse, will need to keep growing. Even though we expect to grow the form to meet metadata needs, we
do not put too much focus on the UX/UI of the Artwork Form in order to prioritize our collector-facing apps. (The
Artwork Form is only used by a relatively small subset of users, mostly gallery partners.) Hopefully, this refactor
will allow us to expand the form more seamlessly and will make it easier to navigate as it grows.</p>

<p>This refactor is still in its early days. The next steps for making the form easier to use (for both developers and
our end users) will require larger changes. When we think about further progress on revamping the Artwork Form, our
team is considering breaking the form up into smaller forms. Imagine, we are rendering several different top-level
<code class="language-plaintext highlighter-rouge">Formik</code> components that include discrete sections of the form, instead of just one giant <code class="language-plaintext highlighter-rouge">Formik</code> tree as we have
now. We would then combine these “mini forms” together, making better use of React’s core principle of composition.</p>

<p>Breaking up the form would be a big change for the developer experience (but hopefully made easier by this
refactor). It could also involve big changes to the UI. The Artwork Form is not just hard to navigate for
developers. It’s hard for users too. Over the next couple of months, our Product Manager will be working with one
of Artsy’s user researchers to conduct user testing on the form. Feedback from galleries will help determine where
we next take this project. We’re excited to have buy-in from our product team to work on a project that will
elevate the user experience while allowing us to use that opportunity to improve the developer experience as well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Accessing the Relay Store Without a Mutation]]></title>
    <link href="https://artsy.github.io/blog/2021/04/15/accessing-the-relay-store/"/>
    <updated>2021-04-15T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2021/04/15/accessing-the-relay-store</id>
    <content type="html"><![CDATA[<p>I recently encountered a problem where client-side data (returned from a Relay query) became out of sync after a
user interaction. How can we make sure our data is consistent while maintaining a single source of truth? This post
explores why a developer might want to update client-side data locally, the basics of Relay and its store, and how
to delete records in the store when you’re not using a mutation.</p>

<h2 id="relay-x-artsy-x-me">Relay x Artsy x Me</h2>

<p><a href="https://relay.dev/">Relay</a> is a GraphQL client library maintained by Facebook engineers and enables rapid client-side data
fetching in React applications. <a href="https://artsy.github.io/blog/2019/04/10/omakase-relay/">Artsy’s adoption of Relay</a> coincided with our move
toward using React Native for our mobile work around 2016. I joined Artsy as an engineer in November of 2020 (after
<a href="https://medium.com/swlh/how-losing-my-job-helped-me-find-my-way-back-8c8f86552acc">transitioning to engineering from a non-technical role at the
company</a>.) When I joined, I was about a year into React development
and completely new to Relay.</p>

<!-- more -->

<p>I work on the Partner Experience (PX) team at Artsy. We build and maintain software used by our gallery and auction
house partners to sell artwork on Artsy. Although Relay is not new to Artsy, it’s relatively new to our team’s main
repository, Volt. (Volt is Artsy’s CMS used by gallery partners to manage their presences on the platform.) A topic
for another blog post, but Volt’s structure is worth noting here: Volt is a collection of mini React apps injected
into HAML views—our way of incrementally converting the codebase to our new stack.</p>

<p>Relay’s biggest advantage in my eyes is how it tightly couples the client view and API call (in our case, to the
GraphQL layer of our stack, which we call Metaphysics.) In addition to performance and other benefits, colocating a
component with its data requirements creates a pretty seamless developer experience.</p>

<h2 id="building-an-artwork-checklist">Building an Artwork Checklist</h2>

<p>On the PX team, we recently launched a checklist feature aimed at empowering our gallery partners to be more
self-sufficient and find the greatest success possible on Artsy. The checklist prompts galleries to add specific
metadata to artworks that we know (because of our awesome data team) will make the work more likely to sell. The
new feature gathers a list of five high-priority artworks (meaning they are published, for-sale, and by a
top-selling artist) that are missing key pieces of metadata. The checklist prompts users to add the missing
metadata. Users also have the ability to click a button to “snooze” works, which removes them from the list for the
day.</p>

<figure class="illustration">
    <img src="https://user-images.githubusercontent.com/9466631/114630150-28886200-9c77-11eb-9f04-461101496ee0.png" />
</figure>

<p>The feature makes use of <a href="https://redis.io/">Redis</a>, a key-value store used for in-memory cache, to store two lists:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">includeIDs</code> to store the five artworks in the list, so users see a consistent list of artworks whenever they
log in and load the page</li>
  <li><code class="language-plaintext highlighter-rouge">excludeIDs</code> or “snoozed” IDs which Redis will store for 24 hours and ensure the user does not see</li>
</ol>

<p>When a user presses the “snooze” button, the ID for the artwork is added to the snoozed list in Redis. The list of
<code class="language-plaintext highlighter-rouge">includeIDs</code> and the list of <code class="language-plaintext highlighter-rouge">excludeIDs</code> are passed down from Rails controllers to our HAML views and then passed
as props into our React <code class="language-plaintext highlighter-rouge">HomePageChecklist</code> app. In our Checklist component, we use both the <code class="language-plaintext highlighter-rouge">includeIDs</code> and the
<code class="language-plaintext highlighter-rouge">excludeIDs</code> as arguments passed to our Relay query to determine what is returned from Metaphysics (Artsy’s GraphQL
layer).</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fragment</span> <span class="nx">ArtworksMissingMetadata_partner</span> <span class="nx">on</span> <span class="nx">Partner</span>
  <span class="p">@</span><span class="nd">argumentDefinitions</span><span class="p">(</span>
    <span class="nx">first</span><span class="p">:</span> <span class="p">{</span> <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Int</span><span class="dl">"</span><span class="p">,</span> <span class="nx">defaultValue</span><span class="p">:</span> <span class="mi">5</span> <span class="p">}</span>
    <span class="nl">after</span><span class="p">:</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">String</span><span class="dl">"</span> <span class="p">}</span>
    <span class="nl">includeIDs</span><span class="p">:</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">[String!]</span><span class="dl">"</span> <span class="p">}</span>
    <span class="nl">excludeIDs</span><span class="p">:</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">[String!]</span><span class="dl">"</span> <span class="p">}</span>
  <span class="p">)</span> <span class="p">{</span>
    <span class="nx">id</span>
    <span class="nx">artworksConnection</span><span class="p">(</span>
      <span class="nx">first</span><span class="p">:</span> <span class="nx">$first</span>
      <span class="nx">after</span><span class="p">:</span> <span class="nx">$after</span>
      <span class="nx">includeIDs</span><span class="p">:</span> <span class="nx">$includeIDs</span>
      <span class="nx">excludeIDs</span><span class="p">:</span> <span class="nx">$excludeIDs</span>
    <span class="p">)</span> <span class="p">@</span><span class="nd">connection</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ArtworksMissingMetadata_partner_artworksConnection</span><span class="dl">"</span><span class="p">,</span> <span class="nx">filters</span><span class="p">:</span> <span class="p">[])</span> <span class="p">{</span>
      <span class="nx">edges</span> <span class="p">{</span>
        <span class="nx">node</span> <span class="p">{</span>
          <span class="p">...</span><span class="nx">ArtworksMissingMetadataItem_artwork</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<h2 id="problem-how-to-change-the-data-displayed-when-a-user-interacts-with-the-page">Problem: How to Change the Data Displayed When a User Interacts with the Page</h2>

<p>The problem we were running into occurs when the user presses “snooze” on an item. We successfully update Redis
with the new snoozed item, but the UI still renders the item on the page. (This is because the response from Relay
becomes stale.) If the user refreshes the page, the list is correct: The up-to-date Redis <code class="language-plaintext highlighter-rouge">excludeIDS</code> list will be
passed into our component and used in the Relay query. But without refreshing the page, we need to make sure that
the list in the UI updates when the user snoozes an item.</p>

<p>The initial fix was to use a local state variable to keep track of which items were snoozed. We defined the following variable in the parent
React component that renders the list:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="p">[</span><span class="nx">localSnoozedItems</span><span class="p">,</span> <span class="nx">setLocalSnoozedItems</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">([])</span>
</code></pre></div></div>

<p>We passed <code class="language-plaintext highlighter-rouge">localSnoozedItems </code> and <code class="language-plaintext highlighter-rouge">setLocalSnoozedItems</code> down to each of the children items. When the “snooze”
button was pressed on an item, the <code class="language-plaintext highlighter-rouge">localSnoozedItems</code> in the parent was updated with the complete list of snoozed
items. The parent then controls which items get rendered. We used the <code class="language-plaintext highlighter-rouge">localSnoozedItems</code> list to filter the connection
returned from our Relay query (which remember, is already filtered based on our Redis <code class="language-plaintext highlighter-rouge">excludeIDs</code> from Redis.)</p>

<p>This worked, but it definitely did not feel great to have two sources of truth for snoozing: The Redis key and the
local state variable.</p>

<h2 id="solution-deleting-a-record-from-the-relay-store">Solution: Deleting a Record From the Relay Store</h2>

<p>Cue the <a href="https://relay.dev/docs/api-reference/store/">RelayModernStore</a>! I learned that Relay keeps track of the GraphQL
data returned by each query in a store on the client. Each record in the store has a unique ID, and the store can be
changed, added to, and deleted from. There are a couple of helpful blog posts (like
<a href="https://yashmahalwal.medium.com/a-deep-dive-into-the-relay-store-9388affd2c2b">this</a> and
<a href="https://medium.com/entria/wrangling-the-client-store-with-the-relay-modern-updater-function-5c32149a71ac">this</a>) that explain the store and how to
interact with it.</p>

<p>In most of the Relay documentation, blog posts, and Artsy’s uses cases, the store is accessed through an <code class="language-plaintext highlighter-rouge">updater</code>
function via <a href="https://relay.dev/docs/guided-tour/updating-data/graphql-mutations/">mutations</a>. <a href="https://relay.dev/docs/guided-tour/updating-data/graphql-mutations/#updater-functions">Updater functions</a>
that return the store in the first argument can optionally be added to Relay mutations. Inside that function, you can access
the store to modify the records you need.</p>

<p>Here’s an example:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">commitMutation</span><span class="p">(</span><span class="nx">defaultEnvironment</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">mutation</span><span class="p">:</span> <span class="nx">graphql</span><span class="s2">`
    mutation SomeMutation {
      ...
    }
  `</span><span class="p">,</span>
  <span class="na">updater</span><span class="p">:</span> <span class="p">(</span><span class="nx">store</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Do something with the store</span>
  <span class="p">},</span>
<span class="p">})</span>
</code></pre></div></div>

<p>In my use case, I was not using a Relay mutation because I did not need to modify anything on the server. Since
Redis is keeping track of our <code class="language-plaintext highlighter-rouge">excludeIDs</code> for us, any round trip to the server will be up-to-date. We just need to
modify our local data store.</p>

<p>Relay provides a <a href="https://relay.dev/docs/guided-tour/updating-data/local-data-updates/">separate API method to make local updates</a> to the Relay
store: <code class="language-plaintext highlighter-rouge">commitLocalUpdate</code>. <code class="language-plaintext highlighter-rouge">commitLocalUpdate</code> takes two arguments: the first is the Relay environment, which you
can easily access from the parent Relay fragment or refetch container. The second is an <code class="language-plaintext highlighter-rouge">updater</code> callback function
that returns the store in the first argument. We now have access to the store!</p>

<h2 id="deleting-a-connection-node-with-connectionhandler">Deleting a Connection Node with ConnectionHandler</h2>

<p>My main hurdle during this journey was finding an appropriate way to hook into the store for our specific use case—when we do
not require an update to server data.</p>

<p>But to close us out: Let’s finish the job and delete the item from the connection in the store.</p>

<p>When an item is snoozed, we call <code class="language-plaintext highlighter-rouge">commitLocalUpdate</code>, pass in the Relay environment, and then pass in the <code class="language-plaintext highlighter-rouge">updater</code>
function. Once we have access to the store, our goal is to delete this particular item from the
<code class="language-plaintext highlighter-rouge">artworksConnection</code>, which is the GraphQL object returned by our original Relay query.</p>

<p>Because we are dealing with connections, we want to use the <a href="https://relay.dev/docs/api-reference/store/#connectionhandler">ConnectionHandler
API</a> provided by Relay. <code class="language-plaintext highlighter-rouge">ConnectionHandler.getConnection</code> takes in the
connection’s parent record (which we can find using the GraphQL ID added as a field on our query for the
connection) as the first argument and the connection key which can be provided through <a href="https://www.prisma.io/blog/relay-moderns-connection-directive-1ecd8322f5c8">Relay’s @connection
directive</a>.</p>

<p>Once we have the connection, we will use <code class="language-plaintext highlighter-rouge">ConnectionHandler.deleteNode</code> which takes the connection as the first
argument and the id to be deleted, which we can also easily access using the GraphQL ID added as a field to the
query for the item.</p>

<p>Bonus: Because <code class="language-plaintext highlighter-rouge">commitLocalUpdate</code> works anywhere in Relay land, we got to perform this deletion exactly where the
“snooze” action is happening: in the child item component. (In our previous solution, we had to manage the state of
the children from their parent component, which wasn’t as intuitive.)</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">commitLocalUpdate</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">relay-runtime</span><span class="dl">"</span>

<span class="nx">commitLocalUpdate</span><span class="p">(</span><span class="nx">relay</span><span class="p">.</span><span class="nx">environment</span><span class="p">,</span> <span class="p">(</span><span class="nx">store</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">parentRecord</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">parentID</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">parentRecord</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">artworksConnection</span> <span class="o">=</span> <span class="nx">ConnectionHandler</span><span class="p">.</span><span class="nx">getConnection</span><span class="p">(</span>
      <span class="nx">parentRecord</span><span class="p">,</span>
      <span class="dl">"</span><span class="s2">ArtworksMissingMetadata_partner_artworksConnection</span><span class="dl">"</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">artworksConnection</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">ConnectionHandler</span><span class="p">.</span><span class="nx">deleteNode</span><span class="p">(</span><span class="nx">artworksConnection</span><span class="p">,</span> <span class="nx">id</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<h2 id="key-takeaways">Key Takeaways</h2>

<ol>
  <li>Relay is great because it colocates a component with its data requirements.</li>
  <li>The Relay store allows us to access and modify data that we are using on the client.</li>
  <li><code class="language-plaintext highlighter-rouge">commitLocalUpdate</code> provides us access to the store if we just need to modify local data and aren’t using a
mutation to update server-side data.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Relay Pagination Containers Demystified]]></title>
    <link href="https://artsy.github.io/blog/2020/08/31/relay-pagination-containers-demystified/"/>
    <updated>2020-08-31T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/08/31/relay-pagination-containers-demystified</id>
    <content type="html"><![CDATA[<p>In 2017, Artsy adopted <a href="https://relay.dev/en/">Relay</a> in both its front-end web and iOS codebases (using React and
React Native, respectively). Generally speaking, this investment has turned out very well for us! Relay empowers
product teams to quickly iterate on new features and to share common infrastructure across web and iOS codebases.
However, most of the original engineers who pioneered using Relay at Artsy have since moved on to their next role;
this has left a knowledge gap where Artsy engineers are comfortable <em>using</em> Relay, but they don’t totally
understand how it works.</p>

<p>This is a problem as old as software engineering itself, and it has a simple solution: learn and then teach others.
We’ll be driving a peer learning group centering around Relay, but today we are going to dive into the part of
Relay that comes up the most in requests for pairing: getting Relay pagination to work. (Note: we’re going to use
plain old Relay and not <a href="https://github.com/relay-tools/relay-hooks">relay-hooks</a>.)</p>

<!-- more -->

<p>My goal with this post is to show my thought process when trying to learn about, and clean up our use of, Relay
pagination containers. This post emphasizes the <em>demystifying</em> process and not so much the <em>Relay pagination
containers</em> themselves – we’ll briefly cover some Relay fundamentals before diving into a case study on how
problematic code proliferates through copy-and-paste.</p>

<p>Let’s back up and talk a little bit about what Relay is and how it works. Relay is a framework that glues React
components and GraphQL requests together. React components define the data they need from a GraphQL schema in order
to render themselves, and Relay handles actually fetching GraphQL requests and marshalling data into the React
component tree. It is very efficient because of build-time optimizations by the Relay compiler.</p>

<p>The simplest use of Relay is a <a href="https://relay.dev/docs/en/fragment-container">fragment container</a>, which is created
from a React component and a <a href="https://blog.logrocket.com/graphql-fragments-explained/">GraphQL fragment</a>. (We’re
going to skip over how the GraphQL query is made, but
<a href="https://relay.dev/docs/en/query-renderer">here are the docs on query renderers</a> if you’re curious.)</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Artist</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Text</span><span class="o">&gt;</span><span class="nx">The</span> <span class="nx">artist</span> <span class="nx">name</span> <span class="nx">is</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">artist</span><span class="p">.</span><span class="nx">name</span><span class="p">}.</span><span class="o">&lt;</span><span class="sr">/Text</span><span class="err">&gt;
</span>  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="nx">ArtistFragmentContainer</span> <span class="o">=</span> <span class="nx">createFragmentContainer</span><span class="p">(</span><span class="nx">Artist</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">artist</span><span class="p">:</span> <span class="nx">graphql</span><span class="s2">` # artist will be passed in as props
    fragment Artist_artist on Artist { # Relay has strong naming conventions
      name # Get all the data we want here
    }
  `</span>
<span class="p">})</span>
</code></pre></div></div>

<p>(At Artsy, we use <a href="https://github.com/relay-tools/relay-compiler-language-typescript">TypeScript with Relay</a>, but
for this blog post we’ll stick to JavaScript.)</p>

<p>So we have a plain React component that gets some props, and a Relay fragment container that wraps it, defining the
data that the component needs.</p>

<p>There are other types of Relay containers beyond simple fragment containers.
<a href="https://relay.dev/docs/en/refetch-container">Refetch containers</a> are like fragment containers except you can
refetch their contents from your GraphQL server (in response to, for example, user interaction). Using a refetch
container is very similar to using a plain fragment container. But today, we want to talk about
<a href="https://relay.dev/docs/en/pagination-container">pagination containers</a>, which use a GraphQL construct called
<em>connections</em> to show page after page of data.</p>

<p><a href="https://www.apollographql.com/blog/explaining-graphql-connections-c48b7c3d6976/">GraphQL connections</a> are beyond
the scope of this blog post, but they are a way to fetch lists of data without running into the limitations of
returning a simple array. Connections can return metadata about their results, like how many total results there
are, and use cursors (rather than page numbers) for paginating. They also handle when items are inserted or deleted
from the results between requests for pages –
<a href="https://artsy.github.io/blog/2020/01/21/graphql-relay-windowed-pagination/">check out this blog post</a> for more
info on how to use connections with Relay.</p>

<p>Pagination containers take considerably more setup than plain fragment containers, and the setup itself is very
fickle. Things simply will not work until you get the configuration <em>exactly correct</em>, and then everything works
perfectly. The setup is largely repeated boilerplate, and what I’ve noticed (from other engineers but also myself)
is that the boilerplate for new pagination containers gets copy-and-pasted from existing ones. We will see how this
leads to small problems getting propagated throughout the codebase, and leads to engineers not feeling confident
when working in pagination containers.</p>

<p>So let’s modify the Relay container above to fetch a list of the artist’s artworks. This is a very simple example,
only used to illustrate how to use pagination containers.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Artist</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Text</span><span class="o">&gt;</span><span class="nx">The</span> <span class="nx">artist</span> <span class="nx">name</span> <span class="nx">is</span> <span class="nx">$</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">artist</span><span class="p">.</span><span class="nx">name</span><span class="p">}.</span><span class="o">&lt;</span><span class="sr">/Text</span><span class="err">&gt;
</span>    <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">artist</span><span class="p">.</span><span class="nx">artworks</span><span class="p">.</span><span class="nx">edges</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">node</span> <span class="o">=&gt;</span>
      <span class="cm">/* Render each artwork */</span>
      <span class="o">&lt;</span><span class="nx">Text</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="nx">node</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">node</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/Text</span><span class="err">&gt;
</span>    <span class="p">)}</span>
    <span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">relay</span><span class="p">.</span><span class="nx">hasMore</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
      <span class="o">&lt;</span><span class="nx">Button</span> <span class="nx">onPress</span><span class="o">=</span><span class="p">{()</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">relay</span><span class="p">.</span><span class="nx">loadMore</span><span class="p">()</span> <span class="p">}</span> <span class="nx">text</span><span class="o">=</span><span class="dl">"</span><span class="s2">Load next page</span><span class="dl">"</span> <span class="o">/&gt;</span>
    <span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="nx">ArtistFragmentContainer</span> <span class="o">=</span> <span class="nx">createPaginationContainer</span><span class="p">(</span><span class="nx">Artist</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">artist</span><span class="p">:</span> <span class="nx">graphql</span><span class="s2">`
    fragment Artist_artist on Artist
      @argumentDefinitions(
        count: { type: "Int", defaultValue: 10 }
        cursor: { type: "String" }
      ) {
      name
      id
      artworksConnection(first: $count, after: $cursor) @connection(key: "Artist_artworks") {
        edges {
          node {
            title # Now fetch all the artwork data
            id
          }
        }
      }
    }
  `</span>
<span class="p">},</span> <span class="p">{</span>
  <span class="na">direction</span><span class="p">:</span> <span class="dl">"</span><span class="s2">forward</span><span class="dl">"</span><span class="p">,</span>
  <span class="nx">getConnectionFromProps</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">props</span><span class="p">.</span><span class="nx">artist</span><span class="p">.</span><span class="nx">artworks</span>
  <span class="p">},</span>
  <span class="nx">getFragmentVariables</span><span class="p">(</span><span class="nx">prevVars</span><span class="p">,</span> <span class="nx">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="p">...</span><span class="nx">prevVars</span><span class="p">,</span>
      <span class="nx">count</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">getVariables</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="p">{</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">cursor</span> <span class="p">},</span> <span class="nx">fragmentVariables</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">id</span><span class="p">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">artist</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
      <span class="nx">count</span><span class="p">,</span>
      <span class="nx">cursor</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">query</span><span class="p">:</span> <span class="nx">graphql</span><span class="s2">` # Here is the query to fetch any specific page
    query ArtistArtworksQuery(
      $id: ID!
      $count: Int!
      $cursor: String) {
      artist(id: $id) {
        ...Artist_artist @arguments(
          count: $count
          cursor: $cursor
        )
      }
    }
  `</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Wow, that’s a lot! I don’t want to get too bogged down in details, so let’s break this apart at a high level:</p>

<ul>
  <li>We changed the React component to show a list of artworks and include a button to load the next page.</li>
  <li>We changed from <code class="language-plaintext highlighter-rouge">createFragmentContainer</code> to using <code class="language-plaintext highlighter-rouge">createPaginationContainer</code>.</li>
  <li>We added GraphQL fragment variables for <code class="language-plaintext highlighter-rouge">count</code> and <code class="language-plaintext highlighter-rouge">cursor</code> to be passed through to the new
<code class="language-plaintext highlighter-rouge">artworksConnection</code>, which we also added.</li>
  <li>Finally, we added a whole new configuration parameter to <code class="language-plaintext highlighter-rouge">createPaginationContainer</code>.</li>
</ul>

<p>This last bit is the part where I see the most frustration. Hopefully what follows will clear things up.</p>

<p>I like to always start by <a href="https://relay.dev/docs/en/pagination-container">reading the docs</a>. The <code class="language-plaintext highlighter-rouge">direction</code> key
is the direction that we paginate through, either <code class="language-plaintext highlighter-rouge">"forward"</code> or <code class="language-plaintext highlighter-rouge">"backward"</code>. <code class="language-plaintext highlighter-rouge">getConnectionFromProps</code> is a
function that returns the GraphQL connection, in case the query has more than one. And <code class="language-plaintext highlighter-rouge">query</code> is used to fetch any
specific page of results.</p>

<p>Those all makes sense to me, but then we arrive at the real gotchas: <code class="language-plaintext highlighter-rouge">getFragmentVariables</code> and <code class="language-plaintext highlighter-rouge">getVariables</code>. The
docs are helpful, but only if you understand
<a href="https://relay.dev/docs/en/runtime-architecture.html">the internals of how Relay works</a>. Relay has a sophisticated
architecture that delivers some really well-performing code, but its abstractions sometimes
“<a href="https://en.wikipedia.org/wiki/Leaky_abstraction">leak</a>” and you have to deal with underlying implementation
details of Relay (like <a href="https://relay.dev/docs/en/relay-store">the Relay store</a>) which you don’t need to know about
<em>most</em> of the time.</p>

<p>So what are these two functions? Let’s return to the docs:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">getFragmentVariables</code> is used when re-rendering the component, to retrieve the previously-fetched GraphQL
response for a certain set of variables.</li>
  <li><code class="language-plaintext highlighter-rouge">getVariables</code> is used when actually fetching another page, and its return value is given to the <code class="language-plaintext highlighter-rouge">query</code>.</li>
</ul>

<p>I think of <code class="language-plaintext highlighter-rouge">getFragmentVariables</code> as a kind of caches key for lookup in Relay’s internal store. Our implementation
of <code class="language-plaintext highlighter-rouge">getFragmentVariables</code> above doesn’t really do anything interesting, but a connection that accepted <code class="language-plaintext highlighter-rouge">sort</code> or
<code class="language-plaintext highlighter-rouge">filter</code> parameters would need to return those to avoid lookup collisions when the user changed sort and filter
options.</p>

<p>Now for <code class="language-plaintext highlighter-rouge">getVariables</code>, which are the variables used for the <code class="language-plaintext highlighter-rouge">query</code> later on. It really ought to be named
<code class="language-plaintext highlighter-rouge">getQueryVariables</code>, I think. But I digress.</p>

<p>Every implementation of <code class="language-plaintext highlighter-rouge">getFragmentVariables</code> I could find at Artsy was identical, which makes sense because <em>that
is the default implementation</em>. We shouldn’t be defining this option at all! As far as I can tell, Artsy started
with a few pagination containers that supplied this parameter unnecessarily and it got copy-and-pasted throughout
our codebases.</p>

<p>After revisiting the docs, I noticed other optional parameters that don’t need to be defined either. Let’s rewrite
the call to <code class="language-plaintext highlighter-rouge">createPaginationContainer</code> to only supply the parameters that are required:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="nx">ArtistFragmentContainer</span> <span class="o">=</span> <span class="nx">createPaginationContainer</span><span class="p">(</span><span class="nx">Artist</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">artist</span><span class="p">:</span> <span class="nx">graphql</span><span class="s2">`
    fragment Artist_artist on Artist @argumentDefinitions(
      count: { type: "Int", defaultValue: 10 }
      cursor: { type: "String" } {
      name
      id
      artworksConnection (first: $count, after: $cursor) @connection(key: "Artist_artworks") {
        edges {
          node {
            title # Now fetch all the artwork data
            id
          }
        }
      }
    }
  `</span>
  <span class="p">},</span> <span class="p">{</span>
  <span class="nx">getVariables</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="p">{</span> <span class="nx">count</span><span class="p">,</span> <span class="nx">cursor</span> <span class="p">},</span> <span class="nx">fragmentVariables</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">id</span><span class="p">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">artist</span><span class="p">.</span><span class="nx">id</span><span class="p">,</span>
      <span class="nx">count</span><span class="p">,</span>
      <span class="nx">cursor</span><span class="p">,</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="na">query</span><span class="p">:</span> <span class="nx">graphql</span><span class="s2">` # Here is the query to fetch any specific page
    query ArtistArtworksQuery(
      $id: ID!
      $count: Int!
      $cursor: String) {
      artist(id: $id) {
        ...Artist_artist @arguments(
          count: $count
          cursor: $cursor
        )
      }
    }
  `</span>
<span class="p">})</span>
</code></pre></div></div>

<p>This is a lot nicer! By not specifying unnecessary options, we have a smaller surface area to make mistakes in. We
also have fewer overloaded terms, like “variables”, so now it’s more obvious that <code class="language-plaintext highlighter-rouge">getVariables</code> supplies data for
the <code class="language-plaintext highlighter-rouge">query</code> below it.</p>

<p>I’ve already <a href="https://github.com/artsy/eigen/pull/3711">sent a pull request</a> to clean up our use of pagination
containers in our React Native app, and will be following up on the web side next. But I wouldn’t have discovered
this if I hadn’t really dug into the docs, which I only did so that I could write this blog post. Earlier I said
that the solution to a knowledge gap is simple: learn, and then teach. I learned a lot about Relay today, and I
hope this blog post illustrates the value in the learn-then-teach approach.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Server-Rendering Responsively]]></title>
    <link href="https://artsy.github.io/blog/2019/05/24/server-rendering-responsively/"/>
    <updated>2019-05-24T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/05/24/server-rendering-responsively</id>
    <content type="html"><![CDATA[<p>We use server-side rendering (SSR) to deliver every page you hit on <a href="https://artsy.net">artsy.net</a>. We decided on
using SSR for many reasons, amongst them performance.
<a href="https://artsy.github.io/blog/2013/11/30/rendering-on-the-server-and-client-in-node-dot-js/">We wrote about this all the way back in 2013</a>!</p>

<p>We’ve also built our site using responsive design, so you get a browsing experience optimized for your device.</p>

<p>Combining SSR and responsive design is a non-trivial problem. There are many concerns to manage, and they are
sometimes in conflict with each other. We server render for performance reasons, but we also want to be sure our
app is performant when your browser takes over, all while optimizing for accessibility and SEO.</p>

<p>This article describes the tools we use on <a href="https://artsy.net">artsy.net</a> to combine SSR and responsive design.</p>

<!-- more -->

<h2 id="tool-1-styled-system">Tool 1: <a href="https://styled-system.com"><code class="language-plaintext highlighter-rouge">styled-system</code></a></h2>

<p>We handle the majority of responsive styling differences with
<a href="https://styled-system.com/responsive-styles"><code class="language-plaintext highlighter-rouge">styled-system</code></a>. This has been a really great addition to our
toolbox. Here’s a component that would render a <code class="language-plaintext highlighter-rouge">div</code> (<code class="language-plaintext highlighter-rouge">Box</code>) with a width of 50% for small screens, 75% for
medium-sized screens, and 100% for anything larger:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Box</span> <span class="na">width=</span><span class="s">{["50%",</span> <span class="err">"75%",</span> <span class="err">"100%"]}</span><span class="nt">&gt;</span>
  ...
<span class="nt">&lt;/Box&gt;</span>
</code></pre></div></div>

<p>Another example:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Flex</span> <span class="na">flexDirection=</span><span class="s">{["column",</span> <span class="err">"row"]}</span><span class="nt">&gt;</span>
  <span class="nt">&lt;Box</span> <span class="na">px=</span><span class="s">{40}</span> <span class="na">background=</span><span class="s">"black10"</span><span class="nt">&gt;</span>
    ...
  <span class="nt">&lt;/Box&gt;</span>
<span class="nt">&lt;/Box&gt;</span>
</code></pre></div></div>

<p>While only one property in this example is specifying an array of values to be used at different breakpoints, all
of those properties <em>can</em> take an array for different breakpoints. As developers, we love this experience. We can
apply subtle differences to components across breakpoints with very little code and effort.</p>

<p>We use <a href="https://styled-system.com"><code class="language-plaintext highlighter-rouge">styled-system</code></a> extensively within
<a href="https://palette.artsy.net/">our design system</a>. You can
<a href="https://github.com/artsy/reaction/blob/32de03fe526355258655ded510d23335a456b9ce/src/Components/NavBar/Menus/MoreNavMenu.tsx#L23-L28">poke around our source</a>
to see how much we’ve embraced <a href="https://styled-system.com"><code class="language-plaintext highlighter-rouge">styled-system</code></a>’s responsive styles.</p>

<p>There’s one type of challenge with building a responsive app that <a href="https://styled-system.com"><code class="language-plaintext highlighter-rouge">styled-system</code></a>
can’t solve: when we need to emit different layouts across different breakpoints. In this case, we need something
that can render very different component sub-trees. We couldn’t find an approach that satisfied our needs, so we
wrote our own.</p>

<h2 id="tool-2-artsyfresnel">Tool 2: <a href="https://github.com/artsy/fresnel"><code class="language-plaintext highlighter-rouge">@artsy/fresnel</code></a></h2>

<p>First off, an announcement: we’ve just released <a href="https://github.com/artsy/fresnel"><code class="language-plaintext highlighter-rouge">@artsy/fresnel</code></a> version 1.0!</p>

<p><a href="https://github.com/artsy/fresnel"><code class="language-plaintext highlighter-rouge">@artsy/fresnel</code></a> allows you to define a set of breakpoint widths, then
declaratively render component sub-trees when those breakpoints are met. It looks something like this:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">&lt;</span>&gt;
  <span class="nt">&lt;Media</span> <span class="na">at=</span><span class="s">"xs"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;MobileLayout</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/Media&gt;</span>
  <span class="nt">&lt;Media</span> <span class="na">greaterThan=</span><span class="s">"xs"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;NonMobileLayout</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;/Media&gt;</span>
<span class="err">&lt;</span>/&gt;
</code></pre></div></div>

<p>In this example, we’re emitting the <code class="language-plaintext highlighter-rouge">MobileLayout</code> component for devices at or below our <code class="language-plaintext highlighter-rouge">xs</code> breakpoint, and the
<code class="language-plaintext highlighter-rouge">NonMobileLayout</code> for devices greater than our <code class="language-plaintext highlighter-rouge">xs</code> breakpoint. You can imagine that the <code class="language-plaintext highlighter-rouge">MobileLayout</code> and
<code class="language-plaintext highlighter-rouge">NonMobileLayout</code> components contain complicated sub-trees, with more significant differences than
<a href="https://styled-system.com"><code class="language-plaintext highlighter-rouge">styled-system</code></a> could handle.</p>

<h3 id="how-it-works">How it works</h3>

<p>The first important thing to note is that when server-rendering with
<a href="https://github.com/artsy/fresnel"><code class="language-plaintext highlighter-rouge">@artsy/fresnel</code></a>, <strong>all</strong> breakpoints get rendered by the server. Each <code class="language-plaintext highlighter-rouge">Media</code>
component is wrapped by plain CSS that will only show that breakpoint if it matches the user’s current browser
size. This means that the client can accurately start rendering the HTML/CSS <em>while</em> it receives it, which is long
before the React application has booted. This improves perceived performance for end-users.</p>

<p>Why not just the breakpoint that the current device needs? Because we can’t <em>accurately</em> identify which breakpoint
your device needs on the server. We could use a library to sniff the browser <code class="language-plaintext highlighter-rouge">user-agent</code>, but those aren’t always
accurate, and they wouldn’t give us all the information we need to know when we are server-rendering.</p>

<p>If you’re interested, you can
<a href="https://github.com/artsy/reaction/issues/1367">read the issue that originally inspired us to build <code class="language-plaintext highlighter-rouge">@artsy/fresnel</code></a>.
One of the neat things about Artsy being <a href="/series/open-source-by-default/">open-source by default</a> is that you can
see decisions being made and libraries being built <em>as they happen</em>; not just after they’re complete.</p>

<h2 id="tool-3-artsydetect-responsive-traits">Tool 3: <a href="https://github.com/artsy/detect-responsive-traits"><code class="language-plaintext highlighter-rouge">@artsy/detect-responsive-traits</code></a></h2>

<p>I mentioned above that it’s difficult to accurately detect devices by user agent to identify which breakpoint to
render. We didn’t want this to be our primary strategy for combining SSR with responsive design.</p>

<p>But with <a href="https://github.com/artsy/fresnel"><code class="language-plaintext highlighter-rouge">@artsy/fresnel</code></a> as our primary approach, we felt that we could make
some further optimizations with user agent detection. In the event that we don’t know your device by its user
agent, we’ll still render all breakpoints on the server. But if we are certain you are on a device that only ever
needs a subset of the breakpoints, we only render those on the server. This saves a bit of rendering time; more
importantly it reduces the number of bytes sent over the wire.</p>

<p>We really wanted to not maintain our own list of user agents. Alas, we found that none of the existing user agent
detection libraries surfaced all the information we needed in a single resource. We needed to know the minimum
width for a browser on a given device, and if it was resizable, and to what dimensions it was resizable. If any
existing libraries <em>did</em> have this data, they didn’t provide it to us easily.</p>

<p>So we did some experimentation, given the browsers and devices we knew we needed to support. And yeah…we
(reluctantly) created our own user-agent detection library,
<a href="https://github.com/artsy/detect-responsive-traits">@artsy/detect-responsive-traits</a>. We’re using this to determine
if your browser is likely going to use only the mobile breakpoint of our app, in which case we don’t have to also
render the desktop version. The library is currently targeting only the browsers and devices we support on
<a href="artsy.net">artsy.net</a>, but
<a href="https://github.com/artsy/detect-responsive-traits">we’re always open to contributions</a>!</p>

<p>We aren’t doing any detection of desktop browsers. They are more resizable than mobile browsers, and we are more
concerned with mobile users getting less content sent over their 3G connection.</p>

<h2 id="why-didnt-you-___">Why didn’t you ___?</h2>

<p>Those are our primary tools for combining SSR with responsive design! They work well for us. We considered many
many other options along the way. Here are a couple:</p>

<h3 id="react-media-or-react-responsive"><a href="https://github.com/ReactTraining/react-media"><code class="language-plaintext highlighter-rouge">react-media</code></a> or <a href="https://github.com/contra/react-responsive"><code class="language-plaintext highlighter-rouge">react-responsive</code></a></h3>

<p>We investigated both <a href="https://github.com/ReactTraining/react-media"><code class="language-plaintext highlighter-rouge">react-media</code></a> and
<a href="https://github.com/contra/react-responsive"><code class="language-plaintext highlighter-rouge">react-responsive</code></a>, but found that they didn’t approach the SSR side
of the problem as deeply as we needed.</p>

<p>We also weren’t fans of the imperative API in <a href="https://github.com/ReactTraining/react-media"><code class="language-plaintext highlighter-rouge">react-media</code></a>. We
started with a similar API when building <a href="https://github.com/artsy/fresnel"><code class="language-plaintext highlighter-rouge">@artsy/fresnel</code></a>, but found ourselves
inhibited by the restriction that only one branch can be rendered. This contradicted our strategy of emitting all
breakpoints from the server.</p>

<p>With <a href="https://github.com/contra/react-responsive"><code class="language-plaintext highlighter-rouge">react-responsive</code></a>, we didn’t like that it relied on user agent
detection as its primary method of handling SSR.</p>

<h3 id="rely-solely-on-css">Rely solely on CSS</h3>

<p>As mentioned before, we render all breakpoints from the server and hide the non-matching branches with CSS. The
issue with this approach, when combined with React, is that after
<a href="https://reactjs.org/docs/react-dom.html#hydrate">hydration</a> you have many components that are mounted and rendered
unnecessarily. There’s a performance hit you take for rendering components your user isn’t seeing, but even worse
is the potential for duplicate side-effects.</p>

<p>Imagine a component that, when rendered, emits a call to an analytics service. If this component exists in both a
mobile and desktop branch, you’re now double-stuffing your analytics. Hopefully your analytics service is smart
enough to count only one call, but it’s still a bad idea to duplicate components that have side-effects.</p>

<p><a href="https://github.com/artsy/fresnel"><code class="language-plaintext highlighter-rouge">@artsy/fresnel</code></a> will only client-render the breakpoint that matches your
browser dimensions, so you don’t have to worry about duplicate side-effects.</p>

<h2 id="whats-left-to-solve">What’s left to solve?</h2>

<p>Our SSR and responsive design toolbox does a lot of things well. We get great performance from both the server and
client. Our site looks great on any device.</p>

<p>We do have some SEO concerns, though. Since we’re server-rendering multiple breakpoints, it’s likely that search
engine bots are seeing double the content on our pages. We <em>think</em> this is okay.
<a href="https://youtu.be/WsgrSxCmMbM">Google WebMasters</a> says it’s okay. We haven’t noticed any awful side-effects from
this yet, but SEO is a bit of a dark art, yeah?</p>

<h2 id="our-advice">Our advice</h2>

<p>Responsive design is hard, especially when layouts change significantly between desktop and mobile. Server-side
rendering in React is hard to get right, period. Combining SSR with responsive design compounds the challenges.</p>

<p>At the end of the day, you should do everything you can to limit layout differences between mobile and desktop. Use
responsive props from <a href="https://styled-system.com"><code class="language-plaintext highlighter-rouge">styled-system</code></a>. Play around with <code class="language-plaintext highlighter-rouge">flexbox</code> and
<code class="language-plaintext highlighter-rouge">flex-direction</code>, start learning about CSS <code class="language-plaintext highlighter-rouge">grid</code>, and use CSS <code class="language-plaintext highlighter-rouge">@media</code> queries when you can. If you absolutely
must render different views on different breakpoints, render all the UI and hide what’s not needed for that
breakpoint. You want your users to see the right content as quickly as possible. Send them HTML and CSS from your
server that their client can use.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rosalind and The Art Genome Project]]></title>
    <link href="https://artsy.github.io/blog/2019/05/09/rosalind/"/>
    <updated>2019-05-09T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2019/05/09/rosalind</id>
    <content type="html"><![CDATA[<p>We recently bade a fond farewell to two <a href="https://code.dblock.org">of</a> <a href="http://orta.io">the</a> champions of our “open source by default” ethos, but
this spirit lives on at Artsy.</p>

<p>Today we open-source one of our key metadata apps, and explain how it fits into Artsy’s ecosystem.</p>

<!-- more -->

<h2 id="open-source-by-default-or-at-least-eventually">Open source by default… or at least eventually</h2>

<p>Even when we don’t start a project by building in the open, we encourage ourselves to question why that is so. Can
we go ahead and open things up? If the answer is no (and it might be), are we clear on why not?</p>

<p>We’ve even added a <a href="https://github.com/artsy/peril-settings/pull/96">light bit of process</a> to promote this kind of questioning. Our robots will periodically
trawl our GitHub org and file an issue against any closed-source repo that doesn’t include a rationale for its
closed nature in the project README.</p>

<figure class="illustration">
  <img alt="Peril issue" src="/images/2019-05-09-rosalind/issue.png" />
  <figcaption>Robot would like to have a word with you</figcaption>
</figure>

<p>One of our repos got this <a href="https://github.com/artsy/rosalind/issues/179">treatment</a> recently. I’m the point person on this project, and while I considered
adding a rationale of “<em>primary author will die of acute impostor syndrome if this repo is open-sourced, he will
just stop living</em> 😅,” instead we’ve gone ahead and made this repo public.</p>

<p>Meet <a href="https://github.com/artsy/rosalind">Rosalind</a>, an admin app for large-batch genoming operations on Artsy’s database of artworks.</p>

<h2 id="the-art-genome-project-and-the-genome-team">The Art Genome Project, and the Genome Team</h2>

<p>Rosalind is a close cousin of <a href="https://github.com/artsy/helix">Helix</a>, our original dedicated genoming app. (That project is private for
now, but was described by <a href="https://artsy.github.io/author/sarahweir/">Sarah</a> in an an <a href="/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react">earlier blog post</a>.)</p>

<p>What’s genoming, you ask, and what’s it got to do with art?</p>

<p>Artsy’s discovery and recommendation capabilites are powered in large part by <a href="https://www.artsy.net/about/the-art-genome-project">The Art Genome Project</a>,
a comprehensive system of classification that uses our homegrown art-historical controlled vocabulary to describe
the artists and artworks in our database. (Here’s an <a href="https://www.artsy.net/article/the-art-genome-project-seven-facts-about-the-art-genome-project">explainer</a> and our full list of
<a href="https://www.artsy.net/categories">categories</a>. You can even view a <a href="https://github.com/artsy/the-art-genome-project">structured data export</a> of the “genes” which make
up our controlled vocabulary.)</p>

<figure class="illustration">
  <img alt="Helix" src="/images/2019-05-09-rosalind/helix.png" />
  <figcaption>Screenshot of Helix, an app for genoming artists and artworks, and an early foray into React</figcaption>
</figure>

<p>For a long time, our team of art historians — the Genome Team — bore sole responsibility for applying this
vocabulary, using Helix, to the artworks that entered our platform. This was always a daunting task, and only
became more so as our network of partner galleries and institutions continued to grow and upload more artworks.</p>

<p>Artsy is now home to over 1,000,000 artworks by over 100,000 artists, described by over 1,000 genes. A few years
ago, it became clear to us that in order to continue applying high-quality metadata at scale, we were going to need
some new processes and some new tools.</p>

<p>On the process side, we decided to share a simplified genoming interface with our gallery partners, so that they
could start contributing the metadata that would be most relevant to our audience of collectors. We called it
“Partner Applied Categories.”</p>

<figure class="illustration">
  <img alt="Partner applied categories" src="/images/2019-05-09-rosalind/cms-pac.png" />
  <figcaption>Partner Applied Categories interface from Artsy’s partner CMS, showing choices for works of photography</figcaption>
</figure>

<p>Note that this is a tiny subset of our full genome vocabulary, and that values are applied as on/off, versus the
more nuanced 0-100 score that our own Genome Team would apply.</p>

<p>This was a good step, a fundamental building block in scaling artwork metadata on our platform, but it created new
problems as well as new opportunities.</p>

<p>This is where Rosalind came in.</p>

<h2 id="about-rosalind">About Rosalind</h2>

<p>We started work on this tool in earnest in early 2017, at a time when we felt an internal need for the ability to,
among other things:</p>

<ul>
  <li>
    <p>Perform boolean searches against our database of artworks using The Art Genome Project’s vocabulary – a general
purpose superpower that would be useful for our art historians, our editorial team, and our collector relations
and marketing teams, among others</p>
  </li>
  <li>
    <p>Make large-batch modifications to artworks’ genomes (whether genomed by us, or by our gallery partners via
Partner Applied Categories), in order to maintain metadata quality</p>
  </li>
</ul>

<p>The user experience we built looks something like this:</p>

<figure class="illustration">
  <img alt="Rosalind session" src="/images/2019-05-09-rosalind/rosalind.gif" style="outline: solid 1px #eee" />
  <figcaption>A sample admin interaction in Rosalind</figcaption>
</figure>

<p>Under the hood this is a Rails 5 application that talks to our core API server and our Elasticsearch cluster on the
backend, and serves up a React single page app on the frontend.</p>

<figure class="illustration">
  <img alt="Rosalind architecture" src="/images/2019-05-09-rosalind/architecture.png" />
  <figcaption>Bird’s eye view of Rosalind’s architecture</figcaption>
</figure>

<p>Among the tactical goals of this project were to support heavy-duty admin workflows by:</p>

<ul>
  <li>offering a featureful interface tailored to power users</li>
  <li>adding a useful complement of keyboard navigation capabilities</li>
  <li>making it as blazingly fast as possible</li>
</ul>

<p>That last goal led to the somewhat quirky decision to have Rosalind talk to the Elasticsearch cluster directly,
instead of making a search request to our core API server.</p>

<p>While this entails some risk of drift from our accumulated search best practices as encapsulated in our API, in
reality this has not been a problem yet. Rosalind’s search needs are fairly straightforward and using
Elasticsearch’s REST API has been working out just fine. And it is fast as heck.</p>

<p>Although the project was mostly built out in early 2017, we’ve periodically revisited it for upkeep and
maintenance. Along the way we’ve ridden some of the larger trends in the React+Rails ecosystem, as well as internal
trends.</p>

<ul>
  <li>
    <p>We started out on <a href="https://github.com/mipearson/webpack-rails">webpack-rails</a>, an early pioneer in nudging Rails away from the Asset Pipeline
provided by Sprockets, and toward Webpack</p>
  </li>
  <li>
    <p>We <a href="https://github.com/artsy/rosalind/pull/157">migrated</a> over to the <a href="https://github.com/rails/webpacker">Webpacker</a> gem once that became a core Rails concern</p>
  </li>
  <li>
    <p>We <a href="https://github.com/artsy/rosalind/pull/158">migrated</a> from RSpec feature specs to <a href="https://guides.rubyonrails.org/testing.html#system-testing">Rails system tests</a>, after that was
rolled out</p>
  </li>
  <li>
    <p>We experimented with adopting <a href="https://github.com/artsy/reaction">Reaction</a>, our shared internal React component library</p>
  </li>
  <li>
    <p>We more recently switched to using <a href="https://github.com/artsy/palette">Palette</a>, our nascent design system library</p>
  </li>
</ul>

<p>After being in maintenance mode for a couple of years, we’re excited to start up new feature work again, and plan
to bring even more bits of the <a href="https://artsy.github.io/series/omakase">Artsy Omakase</a> into this project. Maybe this project will even be a
good proving ground for <a href="https://github.com/prettier/plugin-ruby">prettier-ruby</a>.</p>

<p>Whatever happens, Rosalind will continue to play an important role in maintaining Artsy’s high-quality metadata and
in making Artsy the best online destination for art.</p>

]]></content>
  </entry>
  
</feed>
