<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: the art genome project | Artsy Engineering]]></title>
  <link href="http://artsy.github.io/blog/categories/the-art-genome-project/atom.xml" rel="self"/>
  <link href="http://artsy.github.io/"/>
  <updated>2020-12-17T22:48:53+00:00</updated>
  <id>http://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rosalind and The Art Genome Project]]></title>
    <link href="http://artsy.github.io/blog/2019/05/09/rosalind/"/>
    <updated>2019-05-09T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2019/05/09/rosalind</id>
    <content type="html"><![CDATA[<p>We recently bade a fond farewell to two <a href="https://code.dblock.org">of</a> <a href="http://orta.io">the</a> champions of our ‚Äúopen source by default‚Äù ethos, but
this spirit lives on at Artsy.</p>

<p>Today we open-source one of our key metadata apps, and explain how it fits into Artsy‚Äôs ecosystem.</p>

<!-- more -->


<a name="Open.source.by.default....or.at.least.eventually"></a>
<h2>Open source by default‚Ä¶ or at least eventually</h2>

<p>Even when we don‚Äôt start a project by building in the open, we encourage ourselves to question why that is so. Can
we go ahead and open things up? If the answer is no (and it might be), are we clear on why not?</p>

<p>We‚Äôve even added a <a href="https://github.com/artsy/peril-settings/pull/96">light bit of process</a> to promote this kind of questioning. Our robots will periodically
trawl our GitHub org and file an issue against any closed-source repo that doesn‚Äôt include a rationale for its
closed nature in the project README.</p>

<p><figure class="illustration">
  <img alt="Peril issue" src="/images/2019-05-09-rosalind/issue.png"  />
  <figcaption>Robot would like to have a word with you</figcaption>
</figure></p>

<p>One of our repos got this <a href="https://github.com/artsy/rosalind/issues/179">treatment</a> recently. I‚Äôm the point person on this project, and while I considered
adding a rationale of ‚Äú<em>primary author will die of acute impostor syndrome if this repo is open-sourced, he will
just stop living</em> üòÖ,‚Äù instead we‚Äôve gone ahead and made this repo public.</p>

<p>Meet <a href="https://github.com/artsy/rosalind">Rosalind</a>, an admin app for large-batch genoming operations on Artsy‚Äôs database of artworks.</p>

<a name="The.Art.Genome.Project..and.the.Genome.Team"></a>
<h2>The Art Genome Project, and the Genome Team</h2>

<p>Rosalind is a close cousin of <a href="https://github.com/artsy/helix">Helix</a>, our original dedicated genoming app. (That project is private for
now, but was described by <a href="https://artsy.github.io/author/sarahweir/">Sarah</a> in an an <a href="/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react">earlier blog post</a>.)</p>

<p>What‚Äôs genoming, you ask, and what‚Äôs it got to do with art?</p>

<p>Artsy‚Äôs discovery and recommendation capabilites are powered in large part by <a href="https://www.artsy.net/about/the-art-genome-project">The Art Genome Project</a>,
a comprehensive system of classification that uses our homegrown art-historical controlled vocabulary to describe
the artists and artworks in our database. (Here‚Äôs an <a href="https://www.artsy.net/article/the-art-genome-project-seven-facts-about-the-art-genome-project">explainer</a> and our full list of
<a href="https://www.artsy.net/categories">categories</a>. You can even view a <a href="https://github.com/artsy/the-art-genome-project">structured data export</a> of the ‚Äúgenes‚Äù which make
up our controlled vocabulary.)</p>

<p><figure class="illustration">
  <img alt="Helix" src="/images/2019-05-09-rosalind/helix.png"  />
  <figcaption>Screenshot of Helix, an app for genoming artists and artworks, and an early foray into React</figcaption>
</figure></p>

<p>For a long time, our team of art historians ‚Äî the Genome Team ‚Äî bore sole responsibility for applying this
vocabulary, using Helix, to the artworks that entered our platform. This was always a daunting task, and only
became more so as our network of partner galleries and institutions continued to grow and upload more artworks.</p>

<p>Artsy is now home to over 1,000,000 artworks by over 100,000 artists, described by over 1,000 genes. A few years
ago, it became clear to us that in order to continue applying high-quality metadata at scale, we were going to need
some new processes and some new tools.</p>

<p>On the process side, we decided to share a simplified genoming interface with our gallery partners, so that they
could start contributing the metadata that would be most relevant to our audience of collectors. We called it
‚ÄúPartner Applied Categories.‚Äù</p>

<p><figure class="illustration">
  <img alt="Partner applied categories" src="/images/2019-05-09-rosalind/cms-pac.png"  />
  <figcaption>Partner Applied Categories interface from Artsy‚Äôs partner CMS, showing choices for works of photography</figcaption>
</figure></p>

<p>Note that this is a tiny subset of our full genome vocabulary, and that values are applied as on/off, versus the
more nuanced 0-100 score that our own Genome Team would apply.</p>

<p>This was a good step, a fundamental building block in scaling artwork metadata on our platform, but it created new
problems as well as new opportunities.</p>

<p>This is where Rosalind came in.</p>

<a name="About.Rosalind"></a>
<h2>About Rosalind</h2>

<p>We started work on this tool in earnest in early 2017, at a time when we felt an internal need for the ability to,
among other things:</p>

<ul>
<li><p>Perform boolean searches against our database of artworks using The Art Genome Project‚Äôs vocabulary ‚Äì a general
purpose superpower that would be useful for our art historians, our editorial team, and our collector relations
and marketing teams, among others</p></li>
<li><p>Make large-batch modifications to artworks‚Äô genomes (whether genomed by us, or by our gallery partners via
Partner Applied Categories), in order to maintain metadata quality</p></li>
</ul>


<p>The user experience we built looks something like this:</p>

<p><figure class="illustration">
  <img alt="Rosalind session" src="/images/2019-05-09-rosalind/rosalind.gif" style="outline: solid 1px #eee" />
  <figcaption>A sample admin interaction in Rosalind</figcaption>
</figure></p>

<p>Under the hood this is a Rails 5 application that talks to our core API server and our Elasticsearch cluster on the
backend, and serves up a React single page app on the frontend.</p>

<p><figure class="illustration">
  <img alt="Rosalind architecture" src="/images/2019-05-09-rosalind/architecture.png" />
  <figcaption>Bird‚Äôs eye view of Rosalind‚Äôs architecture</figcaption>
</figure></p>

<p>Among the tactical goals of this project were to support heavy-duty admin workflows by:</p>

<ul>
<li>offering a featureful interface tailored to power users</li>
<li>adding a useful complement of keyboard navigation capabilities</li>
<li>making it as blazingly fast as possible</li>
</ul>


<p>That last goal led to the somewhat quirky decision to have Rosalind talk to the Elasticsearch cluster directly,
instead of making a search request to our core API server.</p>

<p>While this entails some risk of drift from our accumulated search best practices as encapsulated in our API, in
reality this has not been a problem yet. Rosalind‚Äôs search needs are fairly straightforward and using
Elasticsearch‚Äôs REST API has been working out just fine. And it is fast as heck.</p>

<p>Although the project was mostly built out in early 2017, we‚Äôve periodically revisited it for upkeep and
maintenance. Along the way we‚Äôve ridden some of the larger trends in the React+Rails ecosystem, as well as internal
trends.</p>

<ul>
<li><p>We started out on <a href="https://github.com/mipearson/webpack-rails">webpack-rails</a>, an early pioneer in nudging Rails away from the Asset Pipeline
provided by Sprockets, and toward Webpack</p></li>
<li><p>We <a href="https://github.com/artsy/rosalind/pull/157">migrated</a> over to the <a href="https://github.com/rails/webpacker">Webpacker</a> gem once that became a core Rails concern</p></li>
<li><p>We <a href="https://github.com/artsy/rosalind/pull/158">migrated</a> from RSpec feature specs to <a href="https://guides.rubyonrails.org/testing.html#system-testing">Rails system tests</a>, after that was
rolled out</p></li>
<li><p>We experimented with adopting <a href="https://github.com/artsy/reaction">Reaction</a>, our shared internal React component library</p></li>
<li><p>We more recently switched to using <a href="https://github.com/artsy/palette">Palette</a>, our nascent design system library</p></li>
</ul>


<p>After being in maintenance mode for a couple of years, we‚Äôre excited to start up new feature work again, and plan
to bring even more bits of the <a href="https://artsy.github.io/series/omakase">Artsy Omakase</a> into this project. Maybe this project will even be a
good proving ground for <a href="https://github.com/prettier/plugin-ruby">prettier-ruby</a>.</p>

<p>Whatever happens, Rosalind will continue to play an important role in maintaining Artsy‚Äôs high-quality metadata and
in making Artsy the best online destination for art.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Art + Feminism and Artsy Wikipedia/Wikidata Editathon]]></title>
    <link href="http://artsy.github.io/blog/2017/08/31/Editathon/"/>
    <updated>2017-08-31T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/08/31/Editathon</id>
    <content type="html"><![CDATA[<p>Artsy has always had a focus on Art meets Science, and we <a href="https://www.meetup.com/CocoaPods-NYC/messages/boards/thread/50940969">hosted a meet-up in July</a> that really hits
on both. We had a collection of Artsy Staff, members of <a href="http://www.artandfeminism.org">Art + Feminism</a> NYC, the <a href="/blog/2015/08/10/peer-lab/">CocoaPods Peer
Lab</a>, <a href="http://www.artspracticum.org">New York Arts Practicum</a> and volunteers from <a href="https://nyc.wikimedia.org/">Wikimedia NYC</a> all helping out.</p>

<p>We came with two aims:</p>

<ul>
<li>Help anyone interested in contributing to Wikipedia get started.</li>
<li>Use <a href="https://github.com/artsy/the-art-genome-project">The Art Genome Project</a>(TAGP) to improve Wikidata entries for women Artists.</li>
</ul>


<p>I helped out with the second part, and the rest of this post will be about the lessons learned during this
<a href="https://en.wikipedia.org/wiki/Edit-a-thon">editathon</a>.</p>

<!-- more -->


<a name="What.is.Wikidata."></a>
<h1>What is Wikidata?</h1>

<p>Everyone knows Wikipedia, but fewer people know about <a href="https://www.wikidata.org/wiki/Wikidata:Main_Page">Wikidata</a>. We learned about it in the process of helping
set up this meetup. Wikidata is a structured document store for generic items. The lexicon of keys that can go into
a document are handled by community consensus.</p>

<p>For example let's take the artist: Ana Mendieta (<a href="https://www.artsy.net/artist/ana-mendieta">artsy.net/artist/ana-mendieta</a>) in (truncated) <a href="https://www.wikidata.org/wiki/Special:EntityData/Q463639.json">JSON
representation</a> inside Wikidata:</p>

<pre><code class="json">{

  // General database metadata
  "pageid": 437301,
  "ns": 0,
  "title": "Q463639",
  "lastrevid": 517662334,
  "modified": "2017-07-11T12:30:29Z",
  "type": "item",
  "id": "Q463639",

  // What is the name of this item in the db, in multiple languages
  "labels": {
    [...]
    "ru": {
      "language": "ru",
      "value": "–ú–µ–Ω–¥—å–µ—Ç–∞, –ê–Ω–∞"
    },
    "en": {
      "language": "en",
      "value": "Ana Mendieta"
    },
    [...]
    "he": {
      "language": "he",
      "value": "◊ê◊†◊î ◊û◊†◊ì◊ô◊ô◊ò◊î"
    },
    [...]
  },

  // How do you describe the item per language
  "descriptions": {
    "es": {
      "language": "es",
      "value": "artista cubanoestadounidense"
    },
    "de": {
      "language": "de",
      "value": "US-amerikanische Perfomancek√ºnstlerin"
    },
    "en": {
      "language": "en",
      "value": "American artist"
    },
   [...]
  },

  // How does this item connect to other parts of the system
  "claims": {
    [...]

    // This is https://www.wikidata.org/wiki/Property:P2042
    // Aka: The Artsy Artist ID
    "P2042": [
      {
        "mainsnak": {
          "snaktype": "value",
          "property": "P2042",
          "datavalue": {

            // The slug on the Artsy app/site
            "value": "ana-mendieta",
            "type": "string"
          },
          "datatype": "external-id"
        },
        "type": "statement",
        "id": "Q463639$67B7BA7A-D008-4EB9-BDE6-909ED82DE72A",
        "rank": "normal"
      }
    ],

    [...]

    // This is used in our example below
    "P27": [
      {
        "id": "Q463639$5B578566-EEC7-45F9-9007-612E98CA2D59",
        "mainsnak": {
          "datatype": "wikibase-item",
          "datavalue": {
            "type": "wikibase-entityid",
            "value": {
              "entity-type": "item",
              "id": "Q30",
              "numeric-id": 30
            }
          },
          "property": "P27",
          "snaktype": "value"
        },
        "rank": "normal",
        "type": "statement"
      }
    ],
  },

  // Internal links to this document
  "sitelinks": {
    "cawiki": {
      "site": "cawiki",
      "title": "Ana Mendieta",
      "badges": [],
      "url": "https://ca.wikipedia.org/wiki/Ana_Mendieta"
    },
    "cswiki": {
      "site": "cswiki",
      "title": "Ana Mendieta",
      "badges": [],
      "url": "https://cs.wikipedia.org/wiki/Ana_Mendieta"
    },
    [...]
  }
}
</code></pre>

<p>The database is created with the the notion of "<a href="https://en.wikipedia.org/wiki/Semantic_triple">semantic triples</a>", which was new to us. The idea being
that each <code>Item</code> (corresponding to a Q id (<code>Q463639</code>)) has a bunch of associated <code>Statements</code> via <code>Properties</code> in
the form:</p>

<blockquote><p>subject ‚Äî predicate ‚Äî object</p></blockquote>

<p>Which means‚Ä¶</p>

<blockquote><p><code>&lt;this thing&gt;</code> <code>&lt;has some relationship to&gt;</code> <code>&lt;that thing&gt;</code></p></blockquote>

<p>For example‚Ä¶</p>

<blockquote><p><code>Q463639</code> <code>P27</code> <code>Q30</code></p></blockquote>

<p>In plain English‚Ä¶</p>

<blockquote><p><strong>Ana Mendietta</strong> has a <strong>country of citizenship</strong> which is <strong>United States of America</strong></p></blockquote>

<p>In essence, a Wikidata <code>Item</code> is just some structured data around a big bag of triples, like the above.</p>

<a name="Artsy...Wikidata"></a>
<h1>Artsy + Wikidata</h1>

<p>Lucky for this editathon, both <a href="https://www.wikidata.org/wiki/Property:P2042">Artsy Artist ID</a>, and <a href="https://www.wikidata.org/wiki/Property:P2411">TAGP ID</a> were already inside the
Wikidata controlled vocabulary of <code>Properties</code>. This mean we could think about how to connect items rather than how
we can pitch that is worth connecting them at all.</p>

<p>We used Wikipedia to keep track of all <a href="https://en.wikipedia.org/wiki/Wikipedia:Meetup/NYC/Artsy_ArtAndFeminism">the useful links</a> to share among contributors.</p>

<p>As the majority of us were new to the Wikidata, we scoped our projects to "get something small done." We ended up
with three projects on the Wikidata side:</p>

<ul>
<li>Edit some wikidata items manually to understand the process.</li>
<li>Understand QuickStatements in order to do mass-updates of Wikidata items from Artsy data.</li>
<li>Explore using pywikibot to ensure that updated Artsy details can be kept in sync with Wikidata.</li>
</ul>


<a name="Outcomes"></a>
<h1>Outcomes</h1>

<p>We got some changes to Wikidata. üéâ.</p>

<p>In preparing for this we also generated some data on Artists:</p>

<ul>
<li><a href="https://docs.google.com/spreadsheets/d/1bjIKKSHOxR2fJvLgf6yOwuDr3Iqo85hYMDMr4lL7Pxg/edit?usp=sharing">Artsy Female and Nonbinary Emerging Artists</a></li>
<li><a href="https://docs.google.com/spreadsheets/d/1G_wCTrP4WzouxfmZdKzqcIKghJDJdiFrv4xQURxrsbI/edit?usp=sharing">Artsy Female and Nonbinary Artists with "Feminist Art" and "Contemporary Feminist" Genes</a></li>
</ul>


<p>These were generated back in July, so if you're looking for up-to-date data, we recommend using the <a href="https://developers.artsy.net/">Artsy
Developer API</a>.</p>

<a name="Updating.Wikidata.with.data.from.Artsy"></a>
<h1>Updating Wikidata with data from Artsy</h1>

<p>After spending some time familiarizing ourselves with the process of manually creating and editing Items, we moved
onto some basic <a href="https://tools.wmflabs.org/wikidata-todo/quick_statements.php">QuickStatement</a> updates. QuickStatments are a simple text based interface for updating
multiple items and properties at once.</p>

<p>We ended up writing what would be the script for a single data item based on hardcoded values:</p>

<pre><code class="sh"># COMPACT VERSION -- see below for annotated version
CREATE
LAST  Len  "Amina Benbouchta"
LAST  Den  "Moroccan contemporary artist"
LAST  P2042  "amina-benbouchta"
LAST  P106  Q483501  S2042  "amina-benbouchta"
LAST  P106  Q1281618  S2042  "amina-benbouchta"
LAST  P21  Q6581072  S2042  "amina-benbouchta"
LAST  P27  Q1028  S2042  "amina-benbouchta"
LAST  P569  +1963-01-01T00:00:00Z/9  S2042  "amina-benbouchta"

# ANNOTATED VERSION

# create new Item
CREATE

# add a label in English to the last created item
LAST  Len  "Amina Benbouchta"

# add a description in English
LAST  Den  "Moroccan contemporary artist"

# add an Artsy Artist ID
LAST  P2042  "amina-benbouchta"

# add occupation (e.g. artist: Q483501, painter: Q1028181, sculptor: Q1281618, photographer: Q33231)
# and source these statements to Artsy (source 2042)
LAST  P106  Q483501  S2042  "amina-benbouchta"
LAST  P106  Q1281618  S2042  "amina-benbouchta"

# add sex or gender (e.g. female: Q6581072; nonbinary: not in Wikidata yet)
LAST  P21  Q6581072  S2042  "amina-benbouchta"

# add country of citizenship (e.g. USA: Q30, Morocco: Q1028)
LAST  P27  Q1028  S2042  "amina-benbouchta"

# add birthdate (precision: /9=year /10=month /11=day)
LAST  P569  +1963-01-01T00:00:00Z/9  S2042  "amina-benbouchta"
</code></pre>

<p>By the end of the day we were able to enter basic biographical facts from Artsy's CSVs into Wikidata in one fell
swoop, by batching up several QuickStatement instructions. In the future, we could write an "Artsy data to
QuickStatement" script to handle larger imports.</p>

<p>One of the interesting aspects of looking through the data is that our Artists had a more nuanced set of gender
identities than is currently available inside Wikidata's database. We found that we didn't have enough time to
address this, but as Wikidata is an on-going project, anyone can add this in the future. If you're looking for a
good first foray into Wikidata - this will improve the foundations for everyone.</p>

<a name="Using.pywikibot.to.update.Wikidata"></a>
<h1>Using pywikibot to update Wikidata</h1>

<p>We created a <a href="https://www.wikidata.org/wiki/Wikidata:Pywikibot_-_Python_3_Tutorial">PAWS</a> Python script that would take metadata from the CSVs Artsy provided on Genes and added that
data to existing Wikidata documents. You can get our bot <a href="https://github.com/orta/artsy-wikidata-bot">on GitHub</a>.</p>

<p>Most of the work is inside a Jupyter Notebook, which you can get a full preview of <a href="https://github.com/orta/artsy-wikidata-bot/blob/master/Artsy%2BGenes%2Bto%2BWikiData.ipynb">on GitHub</a></p>

<p><img src="/images/editathon/jupyternotebook.png"></p>

<p>We loved the idea of having code showing the incremental process as it's being eval'd. We got the bot to a point
where it could edit a Wikidata item based on it data exported from Artsy.</p>

<p>We plan to keep an eye on future efforts to coordinate Wikidata bot development, such as
<a href="https://github.com/SuLab/WikidataIntegrator">WikidataIntegrator</a></p>

<a name="Upcoming.ideas"></a>
<h1>Upcoming ideas</h1>

<p>We discussed what Artsy can do next, we have an idea of how we can connect our data to confirmed data on Wikidata
by keeping the Wikidata QID inside our databases too. This means that we can safely keep that up to date.</p>

<p>We would love to do this again, it was exciting to have the project introduced to us - and we really get what
they're trying to do. We want to host another, and you should come if you're in NYC!</p>

<p>If you're interested in exploring the Artsy Genome database, we recently updated <a href="https://github.com/artsy/the-art-genome-project">The Art Genome Project's Genes
and Definitions</a> with all of our genes as a CSV under <a href="https://creativecommons.org/licenses/by/4.0/">CC-A</a>. We'd love to know if you find any
interesting uses.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Calculating the Importance of an Artwork with Apache Spark]]></title>
    <link href="http://artsy.github.io/blog/2017/04/21/calculating-the-importance-of-an-artwork-with-apache-spark/"/>
    <updated>2017-04-21T00:00:00+00:00</updated>
    <id>http://artsy.github.io/blog/2017/04/21/calculating-the-importance-of-an-artwork-with-apache-spark</id>
    <content type="html"><![CDATA[<p>How important is a single artwork within the artist's body of work? At Artsy we try to answer this question by
extracting and scoring a set of features across roughly one million artworks. We call it an <em>iconicity</em> score and
we calculate that in Apache Spark for the entire dataset in under 5 minutes.</p>

<!-- more -->


<a name="Extracting.Features"></a>
<h3>Extracting Features</h3>

<p>First, we retrieve artwork features (eg. artwork size or number of users that liked the work), artist features (eg.
number of users following an artist), the origin of the work (eg. the work is in a museum) and art genome data (eg.
an art historically important sculpture) from HDFS using Hive. Here's a subset of the query.</p>

<pre><code class="scala">case class Artwork(
  val id: Int,
  val partnerType: String,
  val artistFollowsCount: Long = 0
) = {
  def isMuseumWork: Boolean = {
    partnerType == "museum"
  }
}

def getArtworks(hc: HiveContext): RDD[Artwork] = {
  hc.sql(
    s"""
     |SELECT
     |  artwork.id,
     |  partner.type,
     |  artist_follows_count,
     |FROM
     |  db.artworks AS artwork
     |LEFT JOIN db.partners partner
     |  ON partner.id = partner_id
     |LEFT JOIN db.artists artist
     |  ON artist.id = artwork.artist_id
     |LEFT JOIN (
     |  SELECT follow_artists.artist_id, COUNT(*) AS artist_follows_count FROM db.follow_artists GROUP BY follow_artists.artist_id
     |) artist_follows_count ON artist_follows_count.artist_id = artwork.artist_id
    """.stripMargin
  ).rdd.map {
    row =&gt;
      Artwork(
        id = row.getString(0)
        partnerType = row.getString(1)
        artistFollowsCount = row.getLong(2)
      )
  }
}
</code></pre>

<p>Some features are binary and others require minor transforms. For example, the fact that the work belongs to a
museum scores 1, and otherwise scores a 0.</p>

<pre><code class="scala">case class Features(
  val artworkId: Int,
  val artistFollowsCount: Long = 0,
  val isMuseumWork: Int = 0
)

def extractFeatures(artworks: RDD[Artwork]): RDD[Features] = {
  artworks.map { artwork =&gt;
    Features(
      artworkId = artwork.id,
      artistFollowsCount = artwork.artistFollowsCount,
      isMuseumWork = if (artwork.isMuseumWork) 1 else 0
    )
  }
}
</code></pre>

<p>Features are packed in a vector to become usable by the built-in Spark functions.</p>

<pre><code class="scala">case class Features(
   ...
) = {
  def vector: Vector = {
    Vectors.dense(
      numArtistFollowers.toDouble,
      isMuseumWork.toDouble
    )
  }
}
</code></pre>

<a name="Normalizing.and.Weighing.Features"></a>
<h3>Normalizing and Weighing Features</h3>

<p>Since having 10,000 artist followers doesn't make a work 10,000 times more important than the fact that it belongs
to a museum, we must normalize them for unit variance across the entire data set. This is also a good time to weigh
some features more than others according to our understanding of the art world.</p>

<pre><code class="scala">import org.apache.spark.mllib.feature._
import org.apache.spark.mllib.linalg._

def normalize(features: RDD[Features]): RDD[(Int, Vector)] = {
  val scaler = new StandardScaler().fit(features.map(f =&gt; f.vector))

  val weightAdjuster = new ElementwiseProduct(Vectors.dense(
    0.5, // number of users following an artist is a popularity contest
    2.0  // having a work in a museum is a big deal
  ))

  features.map { f =&gt;
    (
      f.artworkId,
      weightAdjuster.transform(
        scaler.transform(f.vector)
      )
    )
  }
}
</code></pre>

<a name="Scoring.Artworks"></a>
<h3>Scoring Artworks</h3>

<p>The score is just the sum of the normalized and weighted features.</p>

<pre><code class="scala">def score(normalizedFeatures: RDD[(Int, Vector)]): RDD[(Int, Double)] = {
  normalizedFeatures.map {
    f =&gt; (f._1, f._2.toArray.sum)
  }
}
</code></pre>

<a name="Storing.Data"></a>
<h3>Storing Data</h3>

<p>We write this data in JSON format to S3, then load it in a system that serves the Artsy API.</p>

<a name="Conclusion"></a>
<h3>Conclusion</h3>

<p>In our dataset this creates a nice distribution. Here's an example of iconicity across
<a href="https://www.artsy.net/artist/banksy/works">works by the street artist Banksy</a>.</p>

<p><img src="/images/2017-04-21-calculating-the-importance-of-an-artwork-with-apache-spark/banksy-iconicity.png" alt="banksy iconicity" /></p>

<p>We notably sort works by iconicity in <a href="https://www.artsy.net/search?q=banksy">search results</a> and in the carousel
on top of artist pages. We also have made it available in our <a href="https://developers.artsy.net">public API</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trying out React]]></title>
    <link href="http://artsy.github.io/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react/"/>
    <updated>2015-04-08T11:30:00+00:00</updated>
    <id>http://artsy.github.io/blog/2015/04/08/creating-a-dynamic-single-page-app-for-our-genome-team-using-react</id>
    <content type="html"><![CDATA[<p>We recently picked up a Rails application that was a few features away from completion. This application allows our
<a href="https://www.artsy.net/about/the-art-genome-project">Genome Team</a> to classify multiple artworks based on visual and
art historical characteristics. These characteristics, or "genes", can be added, removed, and changed for any of
the artworks on the panel.</p>

<center><img src='/images/2015-04-08-creating-a-dynamic-single-page-app-for-our-genome-team-using-react/helix_screenshot.png'></center>


<p>Our genomers are masters of efficiency, and over the years we have worked closely with them to tailor a dynamic
interface to their specific workflow.</p>

<p>When we started working on the app, the back-end was organized, modular, and interfaced seamlessly with the Artsy
API, but there were still a few front-end features we needed to implement before it could be used by the Genome
Team. The app did not use a front-end framework, and as our features scaled it was difficult to keep track of UI
state with pure CoffeeScript and global event listeners. Eventually, we decided to stop trying to patch our leaky
roof and build a new one.</p>

<!-- more -->


<a name="Choosing.a.Suitable.Framework"></a>
<h3>Choosing a Suitable Framework</h3>

<p>We decided to introduce a front-end framework to make it easier to add new features, and spent a day researching
different options. Our requirements were:</p>

<ul>
<li>A robust view layer that could work on top of our already-solid Rails back-end,</li>
<li>A framework performant enough for an interaction-heavy single-page app with hundreds of editable fields
autosaving on change,</li>
<li>A streamlined framework that favors freedom over unnecessary structure.</li>
</ul>


<p>We chose <a href="http://facebook.github.io/react/">React</a>, Facebook's view layer framework, because it provides
much-needed structure and support for components in a single page app without too much boilerplate.</p>

<p>Our plan was to eventually replace all of the existing <code>*.haml.erb</code> templates and global CoffeeScript mixins with
discrete React components. We used the <a href="https://github.com/reactjs/react-rails">react-rails</a> gem, which easily
integrates React components with Rails views.</p>

<p>In line with the <a href="https://facebook.github.io/react/docs/tutorial.html">React tutorial</a>, we first broke up our UI
into functional and visual components. For each component we found the relevant HAML template, converted it into
<a href="https://facebook.github.io/react/docs/jsx-in-depth.html">jsx</a> and React components using dummy data, and
eventually updated it to accept the correct state from our top-level component which did all of the dynamic
fetching and saving. Then we deleted the associated HAML and CoffeeScript code.</p>

<a name="Thinking.the.React.Way"></a>
<h3>Thinking the React Way</h3>

<p>At this point we have replaced the majority of the app's front-end with React components. We love React because it
encourages you to follow certain <a href="http://www.reactivemanifesto.org/">ideological conventions</a>, but it does not
force you into a structure that may not exactly align with your goals.</p>

<p>In React, having a single source of truth is ideal. Gone are liberally distributed global event listeners that can
conflict and cause pages to get bogged down with transition logic. State is held at the topmost level in React and
when state changes, React automatically re-renders only the affected components.</p>

<p>For example, we hold a hash <code>artworks</code> in the highest-level state of the page:</p>

<pre><code class="javascript">getInitialState: function() {
  var artworks = _.map(this.props.artwork_ids, function(id) {
    return [id, {
      _id: id,
      isLoaded: false,
      isSelected: false,
      isMinimized: false
    }];
  });
  return {
    artworks: _.object(artworks),
    ...
  }
},
</code></pre>

<p>We also store a method at this level to update the <code>artworks</code> state when there is a change:</p>

<pre><code class="javascript">updateArtwork: function(artwork_id, cb) {
  // finds an artwork, passes it to callback (cb) to be mutated,
  // sets the mutated artwork on state from the return value of
  // the callback
  var new_artwork = cb(this.state.artworks[artwork_id]);
  var state_copy = this.state;
  state_copy.artworks[artwork_id] = new_artwork;
  this.setState(state_copy);
},
</code></pre>

<p>That method is passed to child components, and when there is an update to an <code>artwork</code>, such as when it becomes
selected, we invoke it to update all affected components:</p>

<pre><code class="javascript">changeIsSelected: function (e) {
  e.preventDefault();
  var newSelectedState = !this.props.artwork.isSelected;
  this.props.updateArtwork(this.props.artwork._id, function(artwork) {
    artwork.isSelected = newSelectedState;
    return artwork;
  })
},
</code></pre>

<p>React lets us define our components and interactions in a declarative style instead of stringing together possible
transitions triggered by events. Before converting this app to React, we had many bugs around form submission and
saving genome progress. However, by modeling state instead of UI transitions, we can easily track changes and save
progress incrementally in the background without requiring a page refresh from the user.</p>

<a name="From.CoffeeScript.to.React:.Selecting.Artworks"></a>
<h4>From CoffeeScript to React: Selecting Artworks</h4>

<p>In this app, genomers are able to 'select' artworks on the panel for the purposes of saving and conducting batch
actions. In our initial implementation, clicking the 'select all' button would individually click each artwork and
used global event listeners to change UI state:</p>

<pre><code class="javascript">($ 'body').on 'click', '.artwork-selector', (evt) -&gt;
  container = $(this)
  currentSlug = container.data('id')
  artworkIdsElement = $('#selected_artwork_ids')
  selectedArtworkIds = _.compact(_.uniq(artworkIdsElement.val().split(',')))
  indexOfCurrentSlug = selectedArtworkIds.indexOf(currentSlug)
  if selectedArtworkIds.indexOf(currentSlug) != -1
    selectedArtworkIds.splice(indexOfCurrentSlug, 1)
    container.text('Not selected')
    container.removeClass('btn-purple')
  else
    selectedArtworkIds.push currentSlug
    container.text('Selected')
    container.addClass('btn-purple')
  $('#selected_artwork_ids').val(selectedArtworkIds.join(','))
  return false
</code></pre>

<p>With React, we store whether or not an artwork is selected as part of our state, and the appearance of elements
results from this variable. We use <a href="https://facebook.github.io/react/docs/class-name-manipulation.html">class sets</a>
to dynamically alter styles such as button color. When the <code>selected</code> state changes, React re-renders all
components that depend on that variable.</p>

<pre><code class="javascript">var SelectedButton = React.createClass({
  changeIsSelected: function(e) {
    e.preventDefault()
    var newSelectedState = !this.props.artwork.isSelected
    this.props.updateArtwork(this.props.artwork._id, function(artwork) {
      artwork.isSelected = newSelectedState
      return artwork
    })
  },
  render: function() {
    var cx = React.addons.classSet
    var selectedButtonClasses = cx({
      "btn-purple": this.props.artwork.isSelected,
      "btn-tiny": true,
      btn: true,
      "artwork-selector": true
    })
    return (
      &lt;div className="panel-artwork-actions"&gt;
        &lt;a className={selectedButtonClasses} data-id="false" href="#" onClick={this.changeIsSelected}&gt;
          {this.props.artwork.isSelected ? "" : "Not "}Selected
        &lt;/a&gt;
      &lt;/div&gt;
    )
  }
})
</code></pre>

<a name="Challenges"></a>
<h3>Challenges</h3>

<a name="React.s.Virtual.DOM"></a>
<h4>React's Virtual DOM</h4>

<p>React keeps track of a Virtual DOM created by components you define. This can lead to issues, especially when
trying to integrate React with jQuery plugins. For example, our modals kept showing up within other components
until we explicitly rendered them on the outermost level. We also had issues trying to use an existing drag/drop
plugin with the way we set up our state, and ended up
<a href="https://gist.github.com/sweir27/4ea941dd717da69527d6">building one from scratch</a>.</p>

<p>React also crashes when the Virtual DOM becomes out-of-sync with the page DOM. We unearthed a mysterious bug in
which the browser was automatically inserting a <code>tbody</code> tag when it saw a table rendered without one... causing
React (and therefore our entire app) to crash. In order to rectify this, we had to explicitly include these
normally optional tags:</p>

<pre><code class="javascript">if (geneList.length) {
  var results = (
    &lt;table className="triple-margin-top"&gt;
      &lt;thead&gt;{DictionaryView.header}&lt;/thead&gt;
      &lt;tbody&gt;{geneList}&lt;/tbody&gt;
    &lt;/table&gt;
  )
} else {
  var results = null
}
</code></pre>

<a name="Working.with.the.React.Lifecycle"></a>
<h4>Working with the React Lifecycle</h4>

<p>Sometimes it is unavoidable to model transitions directly with JavaScript/jQuery, instead of using React's built-in
lifecycle methods. In one case, we had to dynamically change the top padding of a component based on the height of
a different one. Although we tried to do this using the
<a href="https://facebook.github.io/react/docs/component-specs.html">React lifecycle</a> methods, there ended up being too
many edge cases and we were having to add more and more states just to avoid:</p>

<pre><code class="javascript">currentTemplateHeight = $(".panel-template-wrap").height()
$(".panel-data-items").css("padding-top", currentTemplateHeight)
</code></pre>

<p>In this case, we found it more straightforward to go with the jQuery solution.</p>

<a name="React....Refactor"></a>
<h3>React == Refactor</h3>

<p>When we started out converting the app to React, it was hard to know whether or not an element should be its own
component or if it could exist within another one. Often when we add new features, we have to refactor to make sure
that we are reusing components and maintaining a single source of truth.</p>

<p>For example, we originally had one component to hold metadata on an artwork, such as artist, title, and date:</p>

<pre><code class="javascript">var PanelArtworkInfo = React.createClass({
  ...
  render: function() {
    var artistName;
    var artworkTitle;
    var artworkDate;
    ...
    if (this.props.artwork.artist &amp;&amp; this.props.artwork.artist['name']) {
      artistName = &lt;ArtistName artwork={this.props.artwork} setTemplateArtistId={this.props.setTemplateArtistId} /&gt;;
    } else {
      artistName = &lt;span&gt;Unattributed&lt;/span&gt;;
    }
    artworkTitle = this.props.artwork.title ? this.props.artwork.title : 'Untitled';
    artworkDate = this.props.artwork.date ? this.props.artwork.date : 'No Date';
    ...
    return (
      &lt;div className="dummy-wrap"&gt;
        &lt;div className="row"&gt;
          ...
          &lt;div className="col-sm-6"&gt;
            &lt;div className="artist-name"&gt;
              {artistName}
            &lt;/div&gt;
            &lt;div className="title"&gt;
              {artworkTitle}
            &lt;/div&gt;
            &lt;div className="date"&gt;
              {artworkDate}
            &lt;/div&gt;
            ...
          &lt;/div&gt;
        &lt;/div&gt;
        ...
      &lt;/div&gt;
    );
  }
});
</code></pre>

<p>When we implemented a new 'minimized' view for artworks, we also showed the title and artist, and so we broke these
bits of information into separate components:</p>

<pre><code class="javascript">var ArtistName = React.createClass({
  handleClick: function() {
    if (this.props.artwork.artist["name"]) {
      this.props.setTemplateArtistId(this.props.artwork.artist["_id"])
    }
  },
  render: function() {
    var artistName
    if (this.props.artwork.artist &amp;&amp; this.props.artwork.artist["name"]) {
      artistName = (
        &lt;a
          className="artist-as-template-link"
          data-template-id={this.props.artwork.artist["_id"]}
          onClick={this.handleClick}
          data-template-type="Artist"
          href="#"
        &gt;
          {this.props.artwork.artist["name"]}
        &lt;/a&gt;
      )
    } else if (this.props.artwork["cultural_maker"]) {
      artistName = &lt;span&gt;{this.props.artwork["cultural_maker"]}&lt;/span&gt;
    } else {
      artistName = &lt;span&gt;Unattributed&lt;/span&gt;
    }
    return &lt;div className="artist-name"&gt;{artistName}&lt;/div&gt;
  }
})

var ArtworkTitle = React.createClass({
  render: function() {
    var artworkTitle = this.props.artwork.title ? this.props.artwork.title : "Untitled"
    return &lt;div className="title"&gt;{artworkTitle}&lt;/div&gt;
  }
})

var ArtworkDate = React.createClass({
  render: function() {
    var artworkDate = this.props.artwork.date ? this.props.artwork.date : "No Date"
    return &lt;div className="date"&gt;{artworkDate}&lt;/div&gt;
  }
})
</code></pre>

<p>And updated our parent to reuse the new child components:</p>

<pre><code class="javascript">var PanelArtworkInfo = React.createClass({
  ...
  render: function() {
    ...
    return (
      &lt;div className="dummy-wrap"&gt;
        &lt;div className="row"&gt;
          ...
          &lt;div className="col-sm-6"&gt;
            &lt;ArtistName artwork={this.props.artwork} setTemplateArtistId={this.props.setTemplateArtistId} /&gt;
            &lt;ArtworkTitle artwork={this.props.artwork} /&gt;
            &lt;ArtworkDate artwork={this.props.artwork} /&gt;
            ...
          &lt;/div&gt;
        &lt;/div&gt;
        ...
      &lt;/div&gt;
    );
  }
});
</code></pre>

<a name="Writing.Specs"></a>
<h3>Writing Specs</h3>

<p>All of the existing specs for the app were written in RSpec, so we chose to write integration tests using
RSpec+Capybara. The headless Capybara webkit did not integrate with our React setup, so we switched to using
Selenium as our Capybara JavaScript driver (which also conveniently let us debug our specs within the browser).</p>

<p>Our main challenge with specs had to do with RSpec not waiting long enough for components (such as autocomplete
results) to appear, perhaps due to React's Virtual DOM. We spent many sad hours debugging spurious tests, and even
included a few dreaded 'sleep' commands. Eventually, we integrated the
<a href="https://github.com/y310/rspec-retry">rspec-retry</a> gem to retry spurious tests during CI.</p>

<a name="Conclusion"></a>
<h3>Conclusion</h3>

<p>Converting our app to use a React-based front-end went surprisingly smoothly. We were able to incrementally change
certain templates to React components, which made it easy to test as we went along. Additionally, our development
time in adding new features since then has decreased dramatically. It is much easier to add new components or edit
existing ones when there is a single source of truth and you don't have to search through global event listeners.</p>

<p>Choosing a front-end framework is non-trivial but incredibly important, and we are glad we found React. Because it
does not require much overhead and it is possible to only use it on a portion of a page, React can be integrated
into small or large projects. Although we deliberated for a long time over whether or not to use a framework, we
never regretted moving to React and investing in the future of the app.</p>
]]></content>
  </entry>
  
</feed>
