<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: eigen | Artsy Engineering]]></title>
  <link href="https://artsy.github.io/blog/categories/eigen/atom.xml" rel="self"/>
  <link href="https://artsy.github.io/"/>
  <updated>2024-05-17T14:49:02+00:00</updated>
  <id>https://artsy.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Becoming Mobile First]]></title>
    <link href="https://artsy.github.io/blog/2020/09/29/becoming-mobile-first-at-artsy/"/>
    <updated>2020-09-29T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2020/09/29/becoming-mobile-first-at-artsy</id>
    <content type="html"><![CDATA[<p>It was a Wednesday, mid-summer 2019. I don’t know which Wednesday specifically, but I know that it was <em>a</em>
Wednesday because I was attending Artsy’s weekly all-hands meeting. Two hundred colleagues were also there (many
dialing in remotely) and we were all listening to
<a href="https://files.artsy.net/documents/artsy-names-new-ceo.pdf">Artsy’s new CEO</a> talk about the company’s direction.
Mike Steib had only been around for a few months at that point, getting to know the business. He was talking about
the product direction, and I was listening intently.</p>

<p>With Artsy’s iOS app, I knew there were only really two directions we could go. As I listened, I reflected on how
we had gotten here.</p>

<!-- more -->

<p>When I joined Artsy in 2014, I joined the Mobile Team. It was an amazing team. While we were called the “mobile”
team, we only worked on Artsy’s iOS apps and not the mobile website.</p>

<p>By 2016, Artsy Engineering had grown to the size that having only a “mobile team” and a “web team” was no longer
working well. We dissolved both teams and distributed the engineers into
<a href="https://artsy.github.io/blog/2016/03/28/artsy-engineering-organization-stack/">new product teams</a>, focused on
vertical aspects of Artsy’s business. Auctions. Partner Success. Editorial. And so on. The idea was that each team
would have total autonomy over building products to support their slice of the business, and each would have the
engineering and design resources to build new features across both our web and iOS canvases.</p>

<p>That structure worked well, and continues to work well today (we have continued re-organizing ourselves into new
teams to better meet business goals). But once we dissolved the mobile team, there was no longer anyone looking at
our iOS software holistically. The app had become a series of silos – each silo was internally consistent, but
distinct from each other. Often each silo was written in distinct programming languages (we had also started
adopting React Native).</p>

<p>New iOS technologies had been created by Apple, but our teams weren’t taking full advantage of them. We would
update to support the latest versions of Xcode and iOS in the free time between other tickets. It wasn’t ideal. Of
the <a href="https://github.com/artsy/mobile">five original members of the Mobile Team</a>, everyone else had moved on except
me.</p>

<p>As a product, the app was languishing.</p>

<p>Yet despite this, it was also hugely popular among our users and very important to Artsy’s business. Art collectors
love our app! It gets a large percentage of our total sessions. Also, users place an outsized number of auction
bids and artwork inquiries using our app relative to the number of sessions on our website. In fact, the highest
value artwork transaction <em>ever</em> to take place on Artsy was made on an iPad, running software that I helped build.
I’m still pretty proud of that.</p>

<p>So, Wednesday all-hands. I stood there, not sure of what would happen next. I could see Artsy either making a
massive investment in the app, or I could see Artsy cutting its losses and focusing on the software that we already
knew how to build. Which direction we took largely depended on this new CEO, who was now standing in front of us
all and describing the direction Artsy’s product would take next.</p>

<h2 id="the-dream">The Dream</h2>

<p>Mike said something that caused a lot of raised eyebrows in the crowd. People were excited. <em>I</em> was excited.
Artsy’s product organization would shift to adopt a “mobile-first strategy.”</p>

<p>Someone asked “does this mean the app will reach feature parity with Artsy’s website?”</p>

<p>Mike responded: “No. It means that features are going to launch <em>first</em> on the app. If anything, it’s the <em>website</em>
that will be catching up <em>to the app</em>.”</p>

<p>I was kind of blown away! I mean, this had been the spirit of our original re-org in 2016, but that hadn’t really
materialized. The app had continued to trail the website. At most, only one product team was ever building new
features for the app (usually which ever team I happened to be on). Shifting to this mobile-first strategy would be
a <em>massive</em> undertaking, but I was keen.</p>

<p>In August, an email landed in my inbox from Artsy’s head of software. He wanted to spin up a new team to focus on
the app: the team would be responsible for supporting Artsy’s new mobile-first product strategy. He wanted to know
what I thought, and he wanted to know if I was interested in leading the team.</p>

<p>Honestly, it was a dream come true.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/rfc.png" alt="Screenshot of the RFC for creating the Mobile Experience team" /></p>

<p>Here we are, a year later. This is the story of how Artsy created its Mobile Experience team. How we recovered a
languishing iOS app. How engineers helped shift the product organization to a mobile-first product strategy. And
how Artsy grew from <em>sometimes</em> having <em>a</em> team working on the app, to usually having <em>every</em> team working on it.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/faq.png" alt="Another screenshot of the RFC for creating the Mobile Experience team, describing frequently asked questions" /></p>

<h2 id="getting-our-bearings">Getting Our Bearings</h2>

<p>When Artsy created its new Mobile Experience team, we were already resource-constrained and so the new team would
need to be nimble. We had three full-time engineers (myself as tech lead, and two others), assisted by a designer,
product manager, and data analyst, who would each be spending only half their work time on the Mobile Experience
team. We needed to be scrappy. I’m really proud of the work that that early team accomplished, and I look back
fondly on those first few months working with Sam, Joanna, David, Kieran, and Ani.</p>

<p>The first thing we did was define our own mandate. What was this team responsible for? What was it <em>not</em>
responsible for? “Mobile Experience” is pretty vague, and we had to answer a lot of upfront questions. Would we be
responsible for <em>all</em> of Artsy’s iOS software? No, just the main collector app. Would we be responsible for Artsy’s
mobile website? No, that’s too far-reaching. What about Android? Well, yes, eventually…</p>

<p>After we decided on our mandate, the next step was to get really familiar with the existing app. We storyboarded
out all the existing screens and their connections to one another.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/walkthrough.png" alt="Screenshot of all the screens in our app laid out to discuss" /></p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/brainstorm.png" alt="Screenshot of a brainstorm for app ideas" /></p>

<p>No one on our team had complete knowledge of every screen in the app, not even me, so exploring it together was a
great way to uncover what needed immediate attention. One example was our partner page, which displayed information
to our users about Artsy’s partners: galleries, museums, auction houses, etc. We learned that the app actually used
an ancient web view, and it didn’t even show the partner’s <em>artworks</em>. The artworks! Probably the most important
thing for it to do!</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/old_partner.png" alt="Screenshot of a presentation showing the old partner page" /></p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/new_partner.png" alt="Screenshot of a presentation showing the new partner page, which looks much nicer" /></p>

<p>This is where “being scrappy” started to take root. Usually when developing new features, Artsy designers iterate
on a design before we plan on execution, then we implement, test, and deploy. The nice part of replacing something
that was <em>obviously broken</em> was that we didn’t feel beholden to this usual process; whatever we built would be
better than what we had. One engineer and our designer started the new partner page with a quick pencil sketch,
using the app’s existing UI abstractions to design something that we could quickly build. Once we had a prototype,
the engineer and designer iterated. The whole project took only about three weeks.</p>

<h2 id="early-wins">Early Wins</h2>

<p>Learning about the app itself was critical, but equally important was learning about how our users <em>used</em> the app.
We scheduled user interviews and, in the mean time, looked into our anonymized user analytics. Our data analyst
found a few representative sessions and we walked through each action that a user took. One big lesson here was how
much our app users relied on the app’s search feature, which was still written in Objective-C and hadn’t been
updated in a long time. We found that users would often search for the same query several times in the same
session. For example, users would search for “banksy”, wander off exploring some art, and then return to search for
“bansky” again. And again. And again.</p>

<p>Our search implementation didn’t show users their own recent searches, which would have greatly reduced the amount
of friction users experienced while exploring the art world in the app. Our other engineer took point working with
our designer to migrate the app’s search to React Native. We also added some other features to our search page,
like adding entity subtitles so users would know if the result they were tapping on was an artwork, and artist, a
gallery, and so on. The whole project took about a month to complete, and we have continued to iterate on the app’s
search.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/new_search.png" alt="Screenshot of a presentation showing the new search" /></p>

<p>In early conversations with company leadership, the Mobile Experience team settled on an… interesting strategy to
what we would prioritize. Our mission was “to make the app not suck.” This might seem harsh! But it came from a
place of caring. We knew how much better the app could be and we were motivated to make that a reality. In the
spring of 2020, the team felt like we had reached a point where the app no longer “sucked” – our goal now was “to
make the app amazing.”</p>

<p>During 2020, we made a lot of changes to the app. We had built a new home page, a profile tab for users, granular
push notification settings, Sign In with Apple, and more.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/new_home.png" alt="Screenshot of a presentation showing the new home page" /></p>

<p>It was really exciting to show off our progress to the rest of the company at our monthly Demo Day, especially in
those early months. The product team makes up only a quarter of our company and it was really cool to hear gallery
liaisons complementing our new partner page, or sales people complementing our refreshed home feed. I think that
people had gotten so used to the app not moving much at all that this sudden high velocity of development was as
exciting for them as it was for us.</p>

<h2 id="setting-up-others-to-succeed">Setting Up Others To Succeed</h2>

<p>Artsy’s goal for the Mobile Experience team was explicitly <em>not</em> to centralize all our iOS feature development, and
so our mandate included much more that just working on iOS software ourselves. We wanted to sit between a typical
product team and a “platform” team, to provide infrastructure and assistance so any team at Artsy could develop
their own iOS feature. This was a big challenge, and required work at the individual and team levels.</p>

<p>The first step was apparent before we even created the Mobile Experience team. Artsy Engineering runs skills
surveys every six months, and we knew that building iOS software in React Native was something Artsy engineers
weren’t really familiar with, but that they really wanted to learn more about. I worked with the Engineering team’s
Peer Learning Working Group to design a curriculum – big shout out to Christina and Adam for their help here!</p>

<p><a href="https://artsy.github.io/blog/2019/12/03/ios-learning-group/">The iOS Learning Group took four weeks to deliver four lessons</a>.
The learners were mostly web engineers, so I emphasized the familiar parts of writing React Native software. I also
provided weekly office hours for learners to get assistance with homework. I even stretched my wings as an
educator, developing new skills around curriculum design and delivery. After the course, learners responded
positively to the experience and we have integrated lessons learned from the iOS Learning Group into subsequent
peer learning groups.</p>

<h2 id="aligning-product-releases">Aligning Product Releases</h2>

<p>Now that engineers had a solid grasp of how to build software in our application, we could re-align our product
development process around iOS. I can’t speak to the design side of this, but from a product perspective the most
critical milestone was defining a regular 2-week app release cadence. Let me explain.</p>

<p>Prior to the Mobile Experience team, we released the app pretty irregularly. We would release whenever we had
something big to release, basically. There are two major flaws with that approach. The first problem is that since
each release was bigger, each release was scarier. No one really felt confident releasing app updates. The second
problem was that large pieces of work tended to get coupled together. This came to a head last summer when we were
blocked from releasing an redesigned artwork view because we were waiting for a major overhaul to Artsy’s GraphQL
API to be completed. Without guidance or structure, different teams were building big projects and both had their
changes in our default branch – it was a bit chaotic.</p>

<p>These two problems are incidental to how we worked at Artsy but there is another, inherent problem to developing
mobile apps:
<a href="https://artsy.github.io/blog/2020/03/02/ios-deploys-super-weird-totally-normal/">deploying iOS software is weird</a>.
Engineers, designers, and product managers at Artsy are used to being able to quickly and cheaply deploy software
to the <em>web</em>, not the App Store. iOS software is deployed to our user’s hardware, not to servers we control, which
introduces the possibility that users might not upgrade. Software we shipped years ago is still being run today –
we have the analytics to prove it. Not to mention that every app update has to go through Apple’s App Store review
process. Getting our product team aligned on a release schedule might also help us get aligned on the weirdness of
deploying iOS software.</p>

<center>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">iOS developers! I have a question for you. I hear a lot about teams releasing app updates on a 2-week cadence, to increase user confidence/App Store ranking/team morale/etc.<br /><br />Have any teams shared their experiences with this? Bonus points for any quantitative data. Thanks!! 🤗</p>&mdash; Ash Furrow (@ashfurrow) <a href="https://twitter.com/ashfurrow/status/1184845989510811649?ref_src=twsrc%5Etfw">October 17, 2019</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>
<p><br /></p>

<p>As the Mobile Experience team formed, I reached out to other mobile teams to find out about how they structured
regular releases. <a href="https://twitter.com/Cform">Matt Greenwell</a> from BuzzFeed was really helpful in particular,
outlining their experience of the pros and cons of a regular release cadence. We implemented a two-week release
cadence so that all product teams could align their own feature development and testing around this predictable
structure. We also created documentation for teams to hide their in-progress work behind feature flags. And
finally, we refined our app QA process; teams would QA their own features and bug fixes while the Mobile Experience
team would used a QA script to test the app <em>generally</em>, every other Monday, before submitting an update to the App
Store.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/cadence.png" alt="Calendar describing our cadence on an example sprint" /></p>

<h2 id="making-deploys-not-scary">Making Deploys Not Scary</h2>

<p>To further help teams get into the habit of developing and releasing iOS software often, we created nightly betas.
We also adopted a clever idea from our web colleagues: deploy blocks. In case of a technical reason to not release
a beta, we create a block and the CI job that deploys the beta would fail with a descriptive message. This reduced
a lot of chatter in Slack where engineers would ask “could I make a new beta?” Instead, engineers usually just wait
for the nightly beta. And if they get impatient, they now default to action (their beta deploy will fail if we set
up a block).</p>

<p>All of this was automated through <a href="https://fastlane.tools">fastlane</a> on our CI provider. We had been using fastlane
for a long time at Artsy, but the Mobile Experience team took the time to share knowledge of how it worked. Any
engineer at Artsy can now make a beta (<code class="language-plaintext highlighter-rouge">make deploy</code>) or promote the latest beta to an App Store submission
(<code class="language-plaintext highlighter-rouge">make promote_beta_to_submission</code>).</p>

<p>We deploy more often and, consequently, each deploy is less scary. And everyone is aware of the need to hide
in-progress work behind feature flags. At this point, updates to our app are mundane, predictable, and boring. Just
the way we like them.</p>

<h2 id="being-generous-with-our-time">Being Generous With Our Time</h2>

<p>Our QA and deploy process touches on something I want to go into more detail about, which is how the Mobile
Experience team helped support other product teams. I described earlier how Mobile Experience sits somewhere
between a normal product team and a platform team, and we leveraged that to our advantage. It would have been easy
to become primarily a supportive team, and leave feature development up to others. However, that would leave us
unaware of how day-to-day development <em>feels</em> in the app. We own the platform, and that includes the developer
experience. By sitting in this ambiguous in-between state, we stayed aware of both the needs of everyday
developers, and the needs of our platform.</p>

<p>I would encourage engineers from other teams to ask us for help, which led to a lot of pairing sessions. To be
honest, I think it probably interfered with our productivity, but it was worth it. A half hour of my time spent
pairing with a colleague might save them three hours of banging their head against Xcode. But it’s not the time
saved that I care about, it’s the head-banging. I want engineers at Artsy to feel empowered to build their own iOS
software, and that’s only going to happen if they feel comfortable and supported.</p>

<p>When the Galleries team kicked off their ambitious Viewing Rooms project, we helped them get started by lending an
engineer to them for a few sprints. When they ran into problems, we were generous with our time by pairing with
them. When they were nearing completion, we helped them test the new feature. This all culminated in a smooth
release.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/new_loader.png" alt="Screenshot of a presentation showing the new home page's new loading indicator" /></p>

<p>Speaking of Developer Experience, we took a keen interest in standardizing our best practices and modernizing the
codebase. We
<a href="https://github.com/artsy/eigen/blob/dc81bbc9cd33d51d10054a6c57e61a1bd0ee3e75/docs/preferred_practices.md">documented how we wanted the app’s codebase to look</a>
and set up
<a href="https://github.com/artsy/eigen/blob/dc81bbc9cd33d51d10054a6c57e61a1bd0ee3e75/tslint-rules/useWrappedComponentsRule.js">processes like lint rules</a>
to encourage developers to follow our best practices. We also invited any engineer at Artsy to join our
twice-weekly Knowledge Share meetings (I’ll discuss these in-depth shortly). We looked for bottle necks in the
development process and found many problems, which we addressed.
<a href="https://github.com/artsy/eigen/pull/3022">We combined the Native iOS and React Native repositories</a> (which had
historically been separated). <a href="https://github.com/artsy/eigen/pull/3105">We overhauled the CI configuration</a> to
leverage heavy caching – average build times dropped from fifteen minutes to less than five.
<a href="https://github.com/artsy/eigen/pull/3210">And we adopted stricter TypeScript compiler settings</a> so that engineers
would be forced to deal with nullability and other causes of bugs. (Hey, sometimes you need a carrot and sometimes
you need a stick.)</p>

<p>The React Native community has grown a lot since 2016. If Artsy were to begin our adoption of React Native today,
we would be really well-supported by a community that has defined best practices, documented standard approaches to
problems, and a consolidated opinion on what a React Native codebase should “feel” like. None of that existed in
2016, and our early architectural decisions don’t really reflect contemporary best practices. We continue working
to bring our codebase closer to resembling a fresh project created with <code class="language-plaintext highlighter-rouge">react-native init</code>.</p>

<p>I’m extraordinarily happy with how things have shaped up, and in the direction we continue to move. This is all an
ongoing process, and should remain an ongoing process. For example, engineers were still facing a bottleneck with
core parts of our app’s routing logic that were in Objective-C, so we recently
<a href="https://github.com/artsy/eigen/pull/3771">moved all routing to TypeScript</a>. Not only does moving code out of
Objective-C make it easier for everyone to build, but it also ladders up to a cross-platform Artsy app.</p>

<p>We still have older practices in the app that we want to migrate away from, like testing with Enzyme. But overall,
things are looking good!</p>

<iframe width="100%" height="400" src="https://www.youtube.com/embed/IEn2_WSKFHw" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>

<h2 id="knowledge-shares">Knowledge Shares</h2>

<p>We achieved most of these big, infrastructural changes in meetings called <em>Knowledge Shares</em>, which I mentioned
earlier. I should write a dedicated blog post on these (update: <a href="/blog/2020/12/09/share-your-knowledge/">I did write one</a>), but in short: Knowledge Shares are a <em>structured</em> time to
facilitate <em>unstructured learning</em>. Anyone can bring a topic to Knowledge Share, from a ticket that they’re stuck
on to an idea they have to a neat trick they recently learned. We set aside these two hours a week to discuss
whatever the team wants, and we don’t only invite engineers.</p>

<p>New feature designs, product roadmaps, and data analyses are often brought up by our non-engineering colleagues; we
discuss these at the beginning of the meetings to make sure everyone’s time is respected. Throughout the week,
someone will raise a question in Slack. Before we had Knowledge Share meetings, we might schedule a dedicated
half-hour meeting to discussing this question. But instead, we now say “alright let’s chat about this at tomorrow’s
KS.” Usually the discussion lasts a lot less than a half hour, so we save time and needless context-switching.</p>

<p>Knowledge Shares are also a manifestation of my philosophy of tech leadership, which is this: none of us have built
an Artsy before, so instead of optimizing for building an Artsy, let’s optimize for <em>learning</em> how to build an
Artsy. The best Artsy we can build. And as a natural byproduct, an Artsy gets built. But it’s the <em>learning</em> that
is treated as the paramount goal.</p>

<p>Like I said, I owe you a whole blog post on Knowledge Share meetings. I hope I have conveyed how important these
scheduled “structured unstructured learning” times have been for us.</p>

<h2 id="the-results">The Results</h2>

<p>So where does that leave us? It’s been a year and change, where are we now? Well I’m happy to say that we’ve made a
huge impact. We’ve gone from only having (at most) one product team writing iOS software at a time to having nearly
<em>every</em> product team building iOS software. Artsy is through the woods of its transition to a mobile-first product
strategy. We still have a ways to go, but it feels like we have finally realized the dream we had in 2016 where
every team is fully equipped and empowered to deliver on their own business goals, across all of Artsy’s canvasses.</p>

<p>Our App Store ranking has shot through the roof – not surprising considering our “make it not suck” and then “make
it amazing” approach. Artsy’s iOS app rating now sits at a stout 4.7.</p>

<p><img src="/images/2020-09-29-becoming-mobile-first-at-artsy/ratings.png" alt="Screenshot of a graph showing an increasing average App Store rating" /></p>

<p>We’ve also started tracking our iOS developer experience within Artsy. We know exactly where we still need work
because we ask our engineers where they need support.</p>

<p>It’s taken a mammoth effort, and there’s so much more that I could talk about, but this blog post is long enough
already! Looking at the work we’ve done, the ways we’ve done it, and the results of our effort… I feel ecstatic.</p>

<h2 id="next-steps">Next Steps</h2>

<p>All that said, Artsy’s product team is currently embarking on another reorganization. With so much technical and
product debt paid off, Artsy has evolved past the need for a dedicated Mobile Experience team. It’s bittersweet,
but I’m proud to say that the new Collector Experience team is about to be born. Our team will continue to own the
mobile platform, including its holistic user experience and day-to-day developer experience, but we’ll have an
expanded mandate. That mandate includes a cross-platform Artsy app that will work for collectors on Android as well
as iOS.</p>

<p>The Mobile Experience team has grown, too. Since we started last year with just a few engineers and limited product
support, we now boast a full roster of engineers and product support. I want to thank everyone on the team,
currently: David, Sam, Brian, Mike, Brittney, Pavlos, and Mounir. You have made the past year an incredibly
rewarding experience for me as I learn the ropes of technical leadership. I’m so proud of what we’ve built together
and I’m excited for what the new Collector Experience team is going to do next!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS Retrospectives]]></title>
    <link href="https://artsy.github.io/blog/2017/05/27/ios-retrospectives/"/>
    <updated>2017-05-27T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2017/05/27/ios-retrospectives</id>
    <content type="html"><![CDATA[<p>In the 1990s, Harvard researcher Amy Edmonson made the unexpected discovery that in hospitals, <a href="https://www.researchgate.net/publication/250959492_Learning_from_Mistakes_Is_Easier_Said_Than_Done_Group_and_Organizational_Influences_on_the_Detection_and_Correction_of_Human_Error">higher performing teams reported making more mistakes</a>. This is unexpected because one would assume that <em>better</em> performers would make <em>fewer</em> mistakes. In fact, the number of mistakes isn’t what distinguishes higher-performing teams, but rather it’s their attitude towards discussing – and learning from – their failures.</p>

<p>I’ve spent the past eight months reading more about <a href="https://en.wikipedia.org/wiki/Psychological_safety">psychological safety</a>: the shared belief that team members won’t be punished for speaking up with mistakes or questions or ideas. As a result, I’ve been trying to operationalize psychological safety on my own team, and part of that includes discussing and learning from our mistakes. At Artsy, we candidly discuss site outages or production bugs on the web, but haven’t historically been great at communicating about iOS problems.</p>

<p>I want to start doing more retrospectives after things go wrong. So this week, I held my first iOS retrospective.</p>

<!-- more -->

<p>It consisted of three parts:</p>

<ol>
  <li>Preparation.</li>
  <li>A meeting.</li>
  <li>Follow-up.</li>
</ol>

<p>Let’s discuss each one. And remember: the most important part of a bug retrospective is to <em>learn</em>. Encourage others to ask questions, or propose ideas.</p>

<h3 id="prep-work">Prep Work</h3>

<p>Prep work involved adapting Artsy’s <a href="https://artsy.github.io/blog/2014/11/19/how-to-write-great-outage-post-mortems/">site outage post-mortem</a> for this less serious bug. I drafted a short document with the following information:</p>

<ul>
  <li><strong>Summary</strong>: A short paragraph about what happened, and a timeline of when the bug was reported, when it was first introduced, when it was fixed, and when the fix was submitted to the App Store. Include screenshots if available.</li>
  <li><strong>Cause</strong>: Technical details about the cause of the problem. Include code snippets if appropriate.</li>
  <li><strong>Resolution</strong>: Technical details about the fix for the problem, including links to pull requests. The fix was one-line, so I included a git diff as well.</li>
  <li><strong>Post-Mortem</strong>: A discussion of what contributed to the bug, and how can the team can avoid those problems in the future.</li>
</ul>

<p>Remember, each section is frame around learning from what went wrong with the goal of preventing similar issues from happening in the future.</p>

<p>The preparation took me about a half hour, but would have been faster if I had taken more notes earlier. The bug in question had taken place three weeks ago – I wish I had held the retrospective earlier.</p>

<h3 id="meeting">Meeting</h3>

<p>I invited our Auctions dev team to the meeting and our product manager, but I made it clear that everyone’s attendence was optional. During the meeting, I went through the retrospective document I had prepared, answered some questions, and took some notes for further follow-up.</p>

<h3 id="follow-up">Follow-up</h3>

<p>After the meeting, I addressed the follow-up items. In our case, this involved fixing a problem where our staging servers use data that’s not reprepsentive of the data used in production. Additionally, we’ve made changes to how we test certain scenarious in our iOS app.</p>

<p>Finally, I shared the document with the wider team. In this case, it was the Auctions Operations team. As a developer, I want to empower my teammates to understand why software sometimes behaves unexpectedly.</p>

<hr />

<p>So when should you do a retrospective? The answer is “probably more often than you do now.” I know our team could benefit from more of them, and I think the Artsy Engineering team could too. I’m not concerned about doing them too often – I would rather that than not doing them enough.</p>

<p>Remember that the benefits of a retrospective aren’t limited to learning from a single mistake; retrospectives encourage a <em>culture</em> of learning from mistakes, which (as Edmonson discovered in hospital settings) is far more valuable.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Artsy's Technology Stack, 2017]]></title>
    <link href="https://artsy.github.io/blog/2017/04/14/artsy-technology-stack-2017/"/>
    <updated>2017-04-14T00:00:00+00:00</updated>
    <id>https://artsy.github.io/blog/2017/04/14/artsy-technology-stack-2017</id>
    <content type="html"><![CDATA[<h1 id="history">History</h1>

<p>Artsy was <a href="http://www.nytimes.com/2012/10/09/arts/design/artsy-is-mapping-the-world-of-art-on-the-web.html">launched in 2012 as the “Art Genome Project”</a> and grew exponentially ever since.</p>

<p>By 2014 we had 230,000 works of art from 600 museums and institutions and launched our first business, a subscription service for commercial galleries, bringing over 80,000 works for sale and partnerships with 37 art fairs and a handful of benefit auctions. That year collectors from 82 countries inquired on over $5.5B of art.</p>

<p>By 2015 we doubled our “for sale” inventory and aggregated 4,000 of the world’s leading galleries and 60 art fairs. We also launched two new businesses: commercial auctions and online media.</p>

<p>Finally, in 2016 we, again, doubled our paid gallery network size to become the largest gallery network in the world and grew to become the most-read online art publication as our highly engaging editorial traffic ballooned 320%. We also launched a platform to bid in live auctions and a consignments service with all major auction houses.</p>

<h1 id="the-artsy-business-in-2017">The Artsy Business in 2017</h1>

<p>Artsy in 2017 is a very wide platform and it can be challenging to characterize simply. But when you boil it down to its essence, Artsy offers information and a marketplace. Our written content and fair coverage keep people informed about the art world, and the Art Genome powers our tools for exploration. Through our partnerships with the major player in the art market, galleries and auction houses, we offer our users a unified platform for buying and selling art.</p>

<p>Internally we consider Artsy to have three businesses: <em>Auctions</em>, <em>Content</em> and <em>Listings</em>.</p>

<ul>
  <li>
    <p><em>Auctions</em>: Auction houses and charities use Artsy as a sales channel for a commission because collectors want to discover and buy art in a single, central platform that excels at surfacing the art they want from a global market.</p>
  </li>
  <li>
    <p><em>Content</em>: Brands pay Artsy to reach the first art audience at scale by enabling evergreen content online and for offline engagement during art world events.</p>
  </li>
  <li>
    <p><em>Listings</em>: Galleries, Fairs and Institutions subscribe to Artsy for a fee because we bring a very large audience of art collectors and enthusiasts to their virtual doors.</p>
  </li>
</ul>

<p>The Artsy team is now 166 employees across three offices in New York, Berlin and London. The Engineering organization is now 28 engineers, including 4 leads, 3 directors and a CTO. In this post, we’d like to comprehensively cover what, and how we make the technical and human sides of Artsy businesses work.</p>

<!-- more -->

<center>
 <img src="/images/tech-2017/businesses.svg" style="width:100%;" />
</center>

<h1 id="organizational-structures">Organizational Structures</h1>

<p>In 2016, we <a href="/blog/2016/03/28/artsy-engineering-organization-stack">updated the Engineering organization</a> to be oriented around product verticals for businesses. We used to focus more on practices to group engineers working with the same technologies across product teams to facilitate knowledge sharing and avoid redundant efforts.</p>

<p>Since then, web and mobile “practices” have largely been subsumed into the separate product teams. Mobile’s increasing reliance on React Native has aligned nicely with web tooling. It no longer made sense to keep the teams separate, so where product teams used to have 2 separate sub-teams of engineers, they’ve now merged into 1.</p>

<p>The Platform “practice” has remained as a way to coordinate and share work among product teams, as well as monitor and upgrade Artsy’s platform over time. Most platform engineers operate from within product teams, while a few focusing on data and infrastructure form a core, dedicated Platform team.</p>

<center>
 <img src="/images/tech-2017/engineering-teams.svg" style="width:100%;" />
</center>

<h1 id="artsy-technology-infrastructure-2017---splitting-the-monolith">Artsy Technology Infrastructure 2017 - Splitting the Monolith</h1>

<p><a href="/images/tech-2017/artsy-stack.svg" style="">
  <img src="/images/tech-2017/artsy-stack.svg" alt="The Artsy Tech Stack 2017" style="width:100%;" />
</a></p>

<h2 id="user-facing">User Facing</h2>

<p>A lot of the user-facing focus is on being able to present interfaces with a quality worthy of art.</p>

<p>What you see today when you go to <a href="https://artsy.net">www.artsy.net</a> is a website built with <a href="https://github.com/artsy/ezel">Ezel.js</a>, which is a boilerplate for <a href="http://backbonejs.org">Backbone</a> projects running on <a href="https://nodejs.org">Node</a> and using <a href="http://expressjs.com">Express</a> and <a href="http://browserify.org">Browserify</a>. We used to have separate projects for mobile and desktop web, but they <a href="https://github.com/artsy/force/pull/890">are now merged</a>. The combined app is hosted on <a href="http://heroku.com">Heroku</a> and uses <a href="http://redis.io">Redis</a> for caching. Assets, including artwork images, are served from <a href="http://aws.amazon.com/s3">Amazon S3</a> via the <a href="http://aws.amazon.com/cloudfront">CloudFront CDN</a>. This <a href="https://github.com/artsy/force">code is open-source</a>.</p>

<p>What you see today when you open the <a href="https://itunes.apple.com/us/app/artsy-collect-and-bid-on-fine-art-design/id703796080?mt=8">Artsy iOS app</a> is a mix of Objective-C, Swift and React Native. Objective-C and Swift continue to provide a lot of over-arching cross-View Controller code. While individual representations of Artsy resources tend to be built in React Native. All of our React Native code uses Relay to handle API integration. This <a href="https://github.com/artsy/eigen">code is open-source</a>.</p>

<p>You can also find Artsy on <a href="http://alexa.artsy.net">Alexa</a> and <a href="http://assistant.artsy.net">Google Home</a>, which are both open-source Node.js applications. There is also an open-source <a href="https://github.com/artsy/emergence/">Apple TV</a> app built in Swift.</p>

<p>Our core API serves the public facets of our product, many of our own internal applications, and even <a href="https://developers.artsy.net">some of your own projects</a>. It’s built with <a href="https://www.ruby-lang.org/en">Ruby</a>, <a href="http://rack.github.io">Rack</a>, <a href="http://rubyonrails.org">Rails</a>, and <a href="https://github.com/intridea/grape">Grape</a> serving primarily JSON. The API is hosted on <a href="http://aws.amazon.com/opsworks">AWS OpsWorks</a> and retrieves data from several <a href="http://www.mongodb.com">MongoDB</a> databases hosted with <a href="https://www.compose.io">Compose</a>. It also uses <a href="http://memcached.org">Memcached</a> for caching and <a href="https://redis.io">Redis</a> for background queues with <a href="https://github.com/mperham/sidekiq/">Sidekiq</a>. It runs background jobs with <a href="https://github.com/collectiveidea/delayed_job">delayed_job</a>. We used to employ <a href="http://lucene.apache.org/solr">Apache Solr</a> and even <a href="https://www.google.com/cse">Google Custom Search</a> for the many search functions, but have since consolidated on <a href="https://www.elastic.co">Elasticsearch</a>.</p>

<p>Most modern code for both the website and the iOS app use an orchestration layer which is powered by <a href="http://graphql.org">GraphQL</a> to streamline their data fetching and reduce front-end complexity. Our GraphQL server is an <a href="http://expressjs.com">Express</a> app, using <a href="https://github.com/graphql/express-graphql">express-graphql</a> to provide a single API end-point. The API does not access our data directly, but forwards requests to the core API or other services. We have been migrating shared display logic into the GraphQL server, to make it easier to build consistent clients. This <a href="https://github.com/artsy/metaphysics">code is open-source</a>.</p>

<p>Consistently, our front-end code <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/">has moved towards</a> using React across all platforms along with introducing stricter JavaScript languages like TypeScript over CoffeeScript in order to provide better tooling.</p>

<p>We continue to have a <a href="https://developers.artsy.net">public HAL+JSON API</a> for external developers. This API is in active use for contemporary production services inside Artsy and the <a href="https://github.com/artsy/doppler">website is open-source</a>, too.</p>

<center>
 <img src="/images/tech-2017/languages.svg" style="width:100%;" />
</center>

<h2 id="partner-facing">Partner-Facing</h2>

<p>The vast customer-facing business is powered by a Content Management System (CMS) for gallery and institutional partners. This CMS lets them upload and manage gallery shows, fair booths, create artists, and edit artwork metadata. All CMS components talk to our core API. We also have a number of CMS-like internal applications to manage partners, auctions, art genomes, configuring fairs or performing recurrent billing (we use Stripe for storing and charging credit cards and ACH) with invoicing.</p>

<p>CMS applications are based on stable, mature technologies like <a href="http://rubyonrails.org">Rails</a>, <a href="http://getbootstrap.com">Bootstrap</a>, <a href="https://github.com/turbolinks/turbolinks">Turbolinks</a> and <a href="http://coffeescript.org">CoffeeScript</a>, and gradually adopts modern client-side technologies like <a href="https://facebook.github.io/react">React</a> and <a href="http://browserify.org">Browserify</a>. They share a lot of common infrastructure.</p>

<p>We have a generic image-processing service in-house, which uses <a href="http://rubyonrails.org">Rails</a>, <a href="https://github.com/mperham/sidekiq/">Sidekiq</a>, <a href="https://redis.io">Redis</a>, and <a href="https://github.com/rmagick/rmagick">RMagick</a> with <a href="http://www.imagemagick.org/script/index.php">ImageMagick</a>. It receives image processing requests from many Artsy applications and generates thumbnails, tiles and watermarks images on S3.</p>

<h2 id="collector-facing">Collector-Facing</h2>

<p>Collectors inquire on artworks and engage in conversations with partners. For this purpose we have built a generic messaging system that manages communications between different parties. It receives messages via API or e-mail, finds or creates a conversation based on the recipients and forwards them to the proper addresses in that conversation. Its doesn’t assume anything about the contents of the messages, which makes it a generic system for any type of conversation. The conversations surface to our partners via CMS.</p>

<h2 id="running-auctions">Running Auctions</h2>

<p>The Auctions business began with doing the occasional benefit auctions for charities. Most of these auctions are online-only, timed sales. The initial version of our auction systems came together before we began our move to microservices, and so it is baked into our core API. Last year, we launched a live auction integration product to allow users to bid on works at commercial sales at the actual auction house sale rooms. The real-time requirements of this system required a rethinking of how we process our bids.</p>

<p>The core API for a commercial auction is a Scala micro-service that uses <a href="http://akka.io">Akka</a> for distributed computing. It stores information in an append-only storage engine, based on Akka Persistence, with a small library we developed called <a href="https://github.com/artsy/atomic-store">atomic-store</a>. Communication with external clients can either be done via a REST API, or via WebSockets. People visiting a Live Auction on the web are interacting with a <a href="https://medium.com/@mjackson/universal-javascript-4761051b7ae9#.ev1yd3juy">universal</a> <a href="https://facebook.github.io/react">React</a>+<a href="http://redux.js.org">Redux</a> JavaScript app, served from an <a href="http://expressjs.com">Express</a> server. Bidders visiting a Live Auction on iOS are interacting with a Swift application built with <a href="https://github.com/JensRavens/Interstellar">Interstellar</a>, <a href="https://github.com/daltoniam/starscream">Starscream</a> and <a href="https://github.com/SwiftyJSON/SwiftyJSON">SwiftyJSON</a>.</p>

<p>A more detailed overview of the Auctions stack can be found in <a href="/blog/2016/08/09/the-tech-behind-live-auction-integration">The Tech Behind Live Auction Integration</a>.</p>

<h2 id="publishing">Publishing</h2>

<p>Our in-house editorial team and partners use an <a href="https://github.com/artsy/positron">open-source</a> platform called “Writer” (which we’ve built) to publish rich content across the web. Writer is split in two parts: the editorial-focused CMS and a JSON API that stores and distributes content separately from the rest of Artsy’s stack.</p>

<p>Writer’s frontend is built with <a href="https://github.com/artsy/ezel">Ezel.js</a>, which is a boilerplate for <a href="http://backbonejs.org">Backbone</a> projects running on <a href="https://nodejs.org">Node</a> and using <a href="http://expressjs.com">Express</a> and <a href="http://browserify.org">Browserify</a>. We also heavily use <a href="https://facebook.github.io/react">React</a> and write in <a href="http://coffeescript.org">CoffeeScript</a>. Writer’s backend exposes <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>-based and <a href="http://graphql.org">GraphQL</a> APIs that are consumed by our applications.</p>

<p>You can see Writer being put to work when you see articles on <a href="https://www.artsy.net">www.artsy.net</a>, Facebook Instant Articles, Google AMP, RSS, Apple News, and email. We handle the distribution and display in all of these channels. We also support brand sponsorship deals and produce front-end heavy projects such as <a href="https://www.artsy.net/2016-year-in-art">Year in Art 2016</a>, and <a href="https://www.artsy.net/article/artsy-editorial-2015-the-year-in-art">Year in Art 2015</a>.</p>

<h2 id="data-pipeline">Data Pipeline</h2>

<p>Data generally flows from consumer applications and services into <a href="https://aws.amazon.com/redshift">AWS RedShift</a>. We use a set of <a href="https://github.com/ruby/rake">rake</a> tasks run on <a href="https://wiki.jenkins-ci.org/display/JENKINS/Build+Flow+Plugin">Jenkins</a> to move data from our several MongoDB and PostgreSQL databases to Redshift via <a href="https://aws.amazon.com/s3">S3</a>. These rake tasks shell out to <a href="https://www.postgresql.org/docs/9.3/static/sql-copy.html">psql</a> or <a href="https://docs.mongodb.com/manual/reference/program/mongoexport">mongo-export</a> to generate CSV files for a list of services and upload them to an S3 bucket, then load those CSV files plus others found in that bucket (placed there by other services) into Redshift. If a <a href="http://docs.aws.amazon.com/redshift/latest/dg/r_COPY.html">Redshift copy</a> fails due to data changes we sample the CSV and generate a working schema from its contents.</p>

<p>We also store application usage data provided by <a href="https://segment.com/warehouses">Segment Warehouses</a> as well as data from vendors such as <a href="https://www.salesforce.com">Salesforce</a> and <a href="http://www.sailthru.com">Sailthru</a>.</p>

<p>For production data processing (such as recommendations), large-scale machine learning or even simpler parallel processing such as generating website sitemaps, we have our own Hadoop cluster configured and managed by <a href="https://www.cloudera.com/products/product-components/cloudera-manager.html">Cloudera Manager</a> and running on EC2. We leverage <a href="http://spark.apache.org">Apache Spark</a> and <a href="https://www.cloudera.com/products/open-source/apache-hadoop.html">Hadoop</a> with some <a href="http://oozie.apache.org">Ooozie</a> workflow scheduling. The same data pipeline that writes data to S3 also pumps data to HDFS with either Ruby code or <a href="http://sqoop.apache.org">Sqoop</a> and is read by Spark jobs written in Scala using <a href="https://hive.apache.org">Hive</a>. Spark has improved performance and capacity tenfold over our older in-house systems and we will be moving all lengthy processing implemented in Ruby to this system gradually.</p>

<h2 id="analytics">Analytics</h2>

<p>For general data access and dashboards we rely on <a href="https://looker.com">Looker</a>. This system empowers all non-engineers to access all of our data. At the time of writing, there are 50 users running 3,500 queries a day against Redshift via Looker. We’ve found it expedient to pre-compute common denormalized views, and to create our own session rollups from raw pageviews and events for the additional flexibility it gives us in understanding user behavior.</p>

<p>For more in-depth work, we use <a href="https://ipython.org/notebook.html">Jupyter Notebooks</a> to connect to our Redshift cluster and by default import <a href="http://pandas.pydata.org">pandas</a>, <a href="http://scikit-learn.org/stable">sci-kit learn</a>, and <a href="http://matplotlib.org/api/pyplot_api.html">pyplot</a> for data analysis.</p>

<h2 id="search">Search</h2>

<p>We completed our full migration from <a href="http://lucene.apache.org/solr">Solr</a> to <a href="https://www.elastic.co">Elasticsearch</a> in the last 18 months, and now use Elasticsearch across all front-ends. This ranges from our artwork filter interfaces through to our real-time artwork similarity features. Elasticsearch gives us high availability clustering features out of the box and easy horizontal scaling on demand.</p>

<h2 id="platform-services">Platform Services</h2>

<p>As Artsy’s business has grown more complex, so has the data and concepts handled by its core API. We’ve begun supporting certain product areas with separate, dedicated API services, and even extracting existing API domains into separate services when practical. These services tend to expose simple <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a>-ful HTTP APIs, maintain separate data sources, and even do their own <a href="/blog/2016/10/26/jwt-artsy-journey">authentication</a>. This has certain advantages:</p>

<ul>
  <li>Each system can be deployed and scaled independently.</li>
  <li>Each chooses the best-suited languages and technologies for its purpose.</li>
  <li>Code bases remain more focused and developers’ cognitive overhead is minimized.</li>
</ul>

<p>Balancing these out are some very real disadvantages:</p>

<ul>
  <li>Development must sometimes touch multiple systems.</li>
  <li>Some data is copied between services. These can become out-of-sync, though we always try to have a single <em>authoritative</em> source in such cases.</li>
  <li>Deploys must be coordinated.</li>
</ul>

<p>At our size and complexity, a single code base is simply impractical. So, we’ve tried to be consistent in the coding, deployment, monitoring, and logging practices of these services. The more repeatable and disciplined our process, the less overhead is introduced by additional systems.</p>

<p>We’ve also explored alternate communication patterns, so systems aren’t as dependent on each other’s APIs. Recently we’ve begun publishing a stream of data events from our core systems that other systems can consume. Other systems can simply subscribe to the notifications they care about, so the source system doesn’t need to be concerned about integrating with one more destination. After experimenting with <a href="https://kafka.apache.org">Kafka</a> but finding it hard to manage, we switched to <a href="https://www.rabbitmq.com">RabbitMQ</a> for this purpose. To provide consistency when publishing events we have <a href="https://github.com/artsy/artsy-eventservice">our own gem</a>.</p>

<h2 id="operations">Operations</h2>

<p>All our recent AWS infrastructure is configured in code using <a href="https://www.terraform.io">Terraform</a>. This approach has allowed us to quickly replicate entire deployments along with their dependencies and has increased visibility into the state of our infrastructure across our teams. We started developing an open source <a href="https://www.docker.com">Docker</a> workflow toolkit named <a href="https://github.com/artsy/hokusai">Hokusai</a> in order to manage a containerized workflow, CI and deployment to <a href="https://kubernetes.io">Kubernetes</a>. Our Kubernetes clusters are managed using <a href="https://github.com/kubernetes/kops">Kops</a> and similarly provisioned using Terraform. This new workflow is reducing our dependence on Heroku, giving us more flexibility in our deployments and a more efficient use of server resources.</p>

<h2 id="closing-remarks">Closing Remarks</h2>

<p>Like any attempts at mapping something as large as the daily work for a thirty-ish person engineering team, <a href="https://en.wikipedia.org/wiki/Map–territory_relation">the map is not the territory</a>. However, the exploration is worth the time it takes to keep notes for reading again in the next two years.</p>

<p>If you’re interested in helping us make this an even longer post in two more years, or <em>more interestingly</em> shorter - we nearly always have a <a href="https://www.artsy.net/jobs">position open for engineers</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Retrospective: Swift at Artsy]]></title>
    <link href="https://artsy.github.io/blog/2017/02/05/Retrospective-Swift-at-Artsy/"/>
    <updated>2017-02-05T12:18:00+00:00</updated>
    <id>https://artsy.github.io/blog/2017/02/05/Retrospective-Swift-at-Artsy</id>
    <content type="html"><![CDATA[<center>
<img src="/images/swift-in-rn/swift-in-react-native.svg" style="width:300px;" />
</center>

<p>Swift became public in June 2014, by August we had started using it in Artsy. By October, we had <a href="http://artsy.github.io/blog/2014/11/13/eidolon-retrospective/">Swift in production</a> channelling hundreds of thousands of dollars in auction bids.</p>

<p>It is pretty obvious that Swift is the future of native development on Apple platforms. It was a no-brainer to then build an <a href="https://github.com/artsy/emergence">Apple TV app</a> in Swift, integrated Swift-support into our key app Eigen and built non-trivial parts of that <a href="http://artsy.github.io/blog/2016/08/09/the-tech-behind-live-auction-integration/">application in Swift</a>.</p>

<p>We first started experimenting with React Native in February 2016, and by August 2016, we announced that <a href="/blog/2016/08/15/React-Native-at-Artsy/">Artsy moved to React Native</a> effectively meaning new code would be in JavaScript from here onwards.</p>

<p>We’re regularly asked <em>why</em> we moved, and it was touched on briefly in our announcement but I’d like to dig in to this and try to cover a lot of our decision process. So, if you’re into understanding why a small team of iOS developers with decades of native experience switched to JavaScript, read on.</p>

<p>This post will cover: <a href="/blog/2017/02/05/Retrospective-Swift-at-Artsy/#What.are.Artsy.s.apps.">What are Artsy’s apps?</a>, Swifts <a href="/blog/2017/02/05/Retrospective-Swift-at-Artsy/#Swift.s.upsides">positives</a> and <a href="/blog/2017/02/05/Retrospective-Swift-at-Artsy/#Native.Downsides">negatives</a> for us, <a href="/blog/2017/02/05/Retrospective-Swift-at-Artsy/#React.Native">React Native</a>, and our <a href="/blog/2017/02/05/Retrospective-Swift-at-Artsy/#React.Native..one.year.later">1-year summary</a>.</p>

<!-- more -->

<p>We were finding that our current patterns of building apps were not scaling as the team and app scope grew. Building anything inside Eigen rarely re-used existing native code, and progressively took longer to build features. Our app and test target build times were increasing, till eventually it would take 2 iOS engineers to build a feature in a similar time-frame as a single web engineer. Our iOS engineers have a lot of experience across many platforms, are well versed in best practices and understand the value of building better tools to make it faster. We had the knowledge, but we weren’t finding ourselves in a great position product development wise.</p>

<p>By <a href="https://github.com/artsy/mobile/issues/22">March 2015</a>, we gave up trying to keep pace with the web.</p>

<p>Once we came to this conclusion, our discussion came to “what can we do to fix this?” Over the course of the 2015 winter break we explored ideas on how we could write more re-usable code.</p>

<h1 id="what-are-artsys-apps">What are Artsy’s apps?</h1>

<p>We have different apps with different trade-offs.</p>

<p><a href="https://github.com/artsy/eigen">Eigen</a> is an app where we take JSON data from the server, and convert it into a user interface. Each view controller can nearly always be described as a function taking data and mapping it to a UI. <a href="https://github.com/artsy/eidolon">Eidolon</a> (our Auctions Kiosk app) which contains a lot of Artsy-wide unique business logic which is handled with local state like card reader input, or unique user identification modes. <a href="https://github.com/artsy/emergence">Emergence</a> is a trivial-ish tvOS app which has a few view controllers, and is mostly handled by Xcode’s storyboards.</p>

<p><a href="/images/emission/eigen.svg" style="">
  <img src="/images/emission/eigen.svg" alt="Eigen separated into app + components" style="" />
</a></p>

<p>Eigen is where we worried about how we were building apps, other apps are limited in their scope, but Eigen is basically the mobile representation of Artsy. We’re never <em>not</em> going to have something like Eigen.</p>

<p>We eventually came to the conclusion that we needed to re-think our entire UIKit stack for Eigen. Strictly speaking, Objective-C was not a problem for us, our issues came from abstractions around the way we built apps.</p>

<p>Re-writing from scratch was not an option. That takes <a href="https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/">a lot of time and effort</a>, which will happily remove technical debt, but that’s not our issue. We also don’t need or have a big redesign. However, a lot of companies used the Objective-C -&gt; Swift transition as a time to re-write from scratch. We asked for the experiences from developers who had opted to do this, they said it was a great marketing tool for hiring - but was a lot of pain to actually work with day to day. They tend to talk about technical debt, and clean slates - but not that Objective-C was painful and Swift solves major architectural problems. With the notable exception of functional programming purists.</p>

<p>In the end, for Eigen, we came to the conclusion that we wanted to work with a component-based architecture. This architectural choice comes from studying how other larger apps handle code-reuse.</p>

<p>We were considering:</p>

<ul>
  <li>View Controllers being a mix of Components which could be extended using protocols in Swift.</li>
  <li>JSON defined Components ( which would have ended up like Spotify’s (<a href="https://cocoapods.org/pods/HubFramework">hub</a>) or Hyperslo’s (<a href="https://cocoapods.org/pods/Spots">Spots</a>) ).</li>
  <li>Building a Component structure heavily inspired by React ( like Bending Spoons’s (<a href="https://cocoapods.org/pods/Katana">Katana</a>) ).</li>
</ul>

<center>
 <img src="/images/js2017/swift.svg" style="width:250px;" />
</center>

<h1 id="swifts-upsides">Swift’s upsides</h1>

<p>Had we continued with native apps via native code, we’d have put more resources behind Swift, which had quite a bit running for it:</p>

<ul>
  <li>
    <p><strong>It was consistent with our existing code.</strong> We wrote hundreds of thousands of lines of code in Objective-C and maybe around a hundred thousand of Swift. The majority of the team had 5+ years of Cocoa experience and no-one needs to essentially argue that <em>continuing</em> with that has value.</p>
  </li>
  <li>
    <p><strong>Swift code can interact with Objective-C and can work on its own.</strong> We can write Swift libraries that can build on-top of our existing infrastructure to work at a higher level of abstraction. Building a component-based infrastructure via Swift could allow easy-reuse of existing code, while providing a language difference for “new app code” vs “infra.”</p>
  </li>
  <li>
    <p><strong>People are excited about Swift.</strong> It’s an interesting, growing language, and one of the few ones non-technical people ask about. “Oh you’re an iOS developer, do you use Swift?” is something I’ve been asked a lot. The developers outside of the mobile team have signed up multiple times for Swift workshops and want to know what Swift is, and what its trade-offs are.</p>
  </li>
  <li>
    <p><strong>It’s evolving</strong> the language changes at a fast rate, with new ideas coming from, and influencing other languages. People inside the community influence and shape its growth. There are some great claims being made <a href="https://twitter.com/wilshipley/status/565001293975257091">about Swift</a> by people we respect.</p>
  </li>
  <li>
    <p><strong>Swift improves on a lot of Objective-C.</strong> Most of the patterns that we use in Objective-C are verbose, and they can become extremely terse inside Swift. Potentially making it easier to read and understand.</p>
  </li>
  <li>
    <p><strong>We would be using the official route.</strong> Apple obviously <em>wants</em> you to be using Swift, they are putting a <em>lot</em> of resources into the language. There are smart people working on the project, and it’s become more stable and useful every year. There aren’t any <em>Swift-only</em> APIs yet, but obviously they’ll be coming.</p>
  </li>
  <li>
    <p><strong>It’s a <a href="https://en.wikipedia.org/wiki/There_are_known_knowns">known-unknown</a> territory.</strong> We have a lot of knowledge around building better tooling for iOS apps. From libraries like <a href="https://github.com/moya/moya">Moya</a>, to foundational projects like <a href="https://cocoapods.org">CocoaPods</a>. Coming up with, and executing dramatic tooling improvements is possible. Perhaps we had overlooked a smarter abstraction which would have worked around the downsides, and thus making it worth expanding our search.</p>

    <p>If we end up building something which gains popularity, we get the advantage of working with a lot of fresh perspectives, and being able to gain from other people working on the same project. This is what happened with <a href="https://github.com/moya/moya">Moya</a>. It’s a pattern Basecamp discuss when they <a href="https://signalvnoise.com/posts/660-ask-37signals-the-genesis-and-benefits-of-rails">talk about rails</a> by beginning with a real project and abstracting outwards.</p>
  </li>
</ul>

<h1 id="native-downsides">Native Downsides</h1>

<p>The dominant two issues come from differences in opinions in how software should be built</p>

<ul>
  <li>
    <p><strong>Types.</strong> Types are useful. Overly strict typing systems make it too hard to <em>quickly</em> change codebases.</p>

    <p>Strictly typed languages work <em>really</em> well for <a href="http://mjtsai.com/blog/2014/10/14/hypothetical-objective-c-3-0/#comment-2177091">building systems</a>, or completely atomic apps - the sort Apple have to build on a day to day basis. When I say an atomic app, I mean one where the majority of the inputs and outputs exist within the domain of the application. Think of apps with their own filetypes, that can control inputs and outputs really easily.</p>

    <p>Even in Objective-C, a looser-typed language where you were not discouraged from using meta–programming, handling JSON required <em>a tonne</em> of boilerplate laden, inelegant code when working with an API. Considering how bread-and-butter working with an API is for most 3rd party developers it should come as no surprise that the most popular CocoaPods are about handling JSON parsing, and making network requests.</p>

    <p>Problems which Apple, generally speaking, don’t have. They use iCloud, or CloudKit, or whatever, and expect you will also. The official Apple opinion was neatly summed up on the official Swift blog on how to handle JSON parsing <a href="https://developer.apple.com/swift/blog/?id=37">exhibits the problem well</a>.</p>

    <blockquote>
      <p>Swift’s built-in language features make it easy to safely extract and work with JSON data decoded with Foundation APIs — without the need for an external library or framework.</p>
    </blockquote>

    <p>They do, but it’s not great code to write nor maintain. I don’t know anyone who does what they recommend in production.</p>

    <p>The stricter type system in Swift made it harder to work on JSON-driven apps.</p>
  </li>
  <li>
    <p><strong>Slow.</strong> Native development when put next to web development is slow. Application development requires full compilation cycles, and full state restart of the application that you’re working on. A trivial string change in Eigen takes <a href="https://twitter.com/orta/status/778242899821621249">25 seconds</a> to show up. When I tell some developers that time, they laugh and say I have it good.</p>

    <center><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Making a single edit in a string takes 25 seconds to see the difference in the swift parts of Eigen <a href="https://t.co/MOPGPEWqxX">pic.twitter.com/MOPGPEWqxX</a></p>&mdash; 💍rta Therox (@orta) <a href="https://twitter.com/orta/status/778242899821621249">September 20, 2016</a></blockquote></center>

    <p>The moment that this really stood out for me was when I <a href="https://twitter.com/orta/status/271559616888967168">re</a>-discovered <a href="https://twitter.com/orta/status/705890397810257921">Injection for Xcode</a> which ruined my appetite for building apps the traditional way. It reduced an iteration cycle to about <a href="https://twitter.com/orta/status/706165678177390592">a second</a>. With Apple’s resources, and the fact that Injection for Xcode has existed for years by a single developer, it’s frustrating that iOS is a <a href="https://developer.android.com/studio/run/index.html#instant-run">mobile platform</a> with no support for code reloading. I filed bug reports (<a href="https://forums.developer.apple.com/thread/8796">radars</a>), they were marked as duped with no comment. I talked to Apple engineers at WWDC, the idea was dismissed as “didn’t work” when it was <a href="http://stpeterandpaul.ca/tiger/documentation/DeveloperTools/Conceptual/XcodeUserGuide/Contents/Resources/en.lproj/06_06_db_fix_and_continue/chapter_44_section_1.html">tried before</a>.</p>

    <p>I’ve heard developers say they use Playgrounds to work around some of these problems, and the Kickstarter app has probably the closest I’ve seen to an <a href="https://github.com/kickstarter/ios-oss/tree/master/Kickstarter-iOS.playground/Pages">actual implementation of this</a>, so check that out if you’re hitting these issues.</p>

    <p>The Swift compiler is slow. Yes, it will improve. One of my favourite Swift features, inferred typing, can accidentally increase compile times non-obviously. Which can make it feel arbitrary about what code takes longer to compile or not. We eventually <a href="https://github.com/artsy/eigen/pull/1465">automated having our CI warn us</a> whether the code we were adding was slow as it felt hard to predict.</p>
  </li>
</ul>

<center>
 <img src="/images/react-native/artsy_react_logo.svg" style="width:300px;" />
</center>

<h1 id="react-native">React Native</h1>

<p>You may want to read our announcement of switching to <a href="/blog/2016/08/15/React-Native-at-Artsy/">React Native</a> in anticipation of this. However the big three reasons are:</p>

<ul>
  <li>Better developer experience.</li>
  <li>Same conceptual levels as the rest of the team.</li>
  <li>Ownership of the whole stack.</li>
</ul>

<p>However, the key part of this post is how does this compare to native development? Also, have these arguments stood up to the test of time a year later?</p>

<p><em>Sidenote:</em> I found it hard to write this without being able to comprehensively reference what we are doing now, and so, I’ll be referencing a sibling article: <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/">JS 2017</a>.</p>

<h3 id="developer-experience">Developer Experience</h3>

<p>The JavaScript ecosystem cares about how someone using the tool will feel. This is a part of what separates the good from the great in the community. It’s not enough to just provide a great API, and comprehensive documentation but it should substantially improve the way you work.</p>

<blockquote>
  <p>References from JS 2017: <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/#Relay">Relay</a>, <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/#Jest">Jest</a></p>
</blockquote>

<p>As <em>everyone</em> inside the community has both the ability and the tools to contribute to the ecosystem you get better tools.</p>

<p>Apple make <em>great</em> tools. I do miss Xcode sometimes. It’s cohesive, beautifully designed and doesn’t show its age. It’s a perfect Mac citizen.</p>

<p>Though it’s important to note that they make tools for Apple first and then for us 3rd party devs. Outside influence obviously exists, but they’re shipping whatever <em>they</em> want and you can only influence that via Radars and through going to a conference once a year and talking directly to the dev tools team. Only the Swift language is Open Source (and <a href="https://github.com/apple/swift-package-manager">SwiftPM</a>)</p>

<p>There are so few well built, large developer tools for the Apple ecosystem. Developers are wary <a href="https://twitter.com/orta/status/608013279433138176">of</a> <a href="https://twitter.com/mattt/status/473544723118837760">being copied by Apple</a> - something so prevalent that there is a common word for it, being <a href="https://www.cocoanetics.com/2011/06/on-getting-sherlocked/">Sherlocked</a>. The project I’ve worked on for 5 years, CocoaPods, had an announcement of being sherlocked in late-2015 - you just have to deal with it. The idea that only Apple should be shipping these kind of things kills community momentum.</p>

<center><blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Alfred, Dropbox, Snapchat, Parse, OpenGL, Objective-C… <br /><br />Quite the body count this WWDC.</p>&mdash; Mattt (@mattt) <a href="https://twitter.com/mattt/status/473544723118837760">June 2, 2014</a></blockquote> <script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script></center>

<p>If you’re going to build something amazing, only to have all support pulled out from under you once it gets popular because Apple copied it and made it for free and with a full time team behind it - why bother?</p>

<p>This makes it tough for us, as the 3rd party community, to build useful tools on the kind of scale that is normal in other developer ecosystems.</p>

<p>This contrasts drastically with the JavaScript ecosystem, check out my explanation of Jest - and compare Jest to either Quick or Specta. Then remind yourself that only Apple has the power to do most of what Jest does.</p>

<blockquote>
  <p>Reference from JS 2017: <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/#Jest">Jest</a></p>
</blockquote>

<center>
 <img src="/images/js2017/relay.svg" style="width:300px;" />
</center>

<h3 id="better-abstractions-better-developer-experience">Better Abstractions, Better Developer Experience</h3>

<p>I’ve mentioned that the apps we build have problems specific to API-driven applications. This means that the majority of our work tends to be that we have the full data already, and need to iterate to get the right styling and logic mapping correct, in doing so we want to also make it easy to re-use code.</p>

<p>The React component-oriented architecture makes it very easy to build these types of applications. Born out of the <a href="/blog/2016/11/14/JS-Glossary/#javascript-fatigue">JavaScript primordial soup</a>, where conceptual frameworks come and go every year or so. React has been around for a while now, and seems to have a lot of momentum.</p>

<p>All of these frameworks have the same domain problems that our iOS apps have, external API stores, complex user device state and a mature user-interface API (either the DOM, or UIKit.)</p>

<p>With React, the core concept of a virtual DOM means that you can simplify a lot of complicated state-management for your application. It becomes trivial, removing the need for more complicated state-handling ideas like functional or reactive programming.</p>

<p>With Relay, we got an genuinely ground-breaking change in how interactions get handled with our API. I don’t want to  work against an API without a tool like Relay again.</p>

<blockquote>
  <p>References from JS 2017: <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/#React...React.Native">React</a>, <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/#Relay">Relay</a></p>
</blockquote>

<p>Both of these tools provide a developer experience better than iOS native tooling. React’s strict state management rules allow external tools to extend a React application easily, so the onus is not on the React team to make better tools. Other projects provide tools like: <a href="https://github.com/jhen0409/react-native-debugger">debuggers</a>, <a href="https://github.com/infinitered/reactotron">external state viewers</a>, <a href="https://github.com/gaearon/react-hot-loader">runtime code injection</a>, <a href="https://github.com/storybooks/react-storybook">component storyboarding</a> all of which can be running simultaneously as you are building your application. Imagine being given the flow of all state in your app in <a href="https://logrocket.com">every bug report</a>.</p>

<p>A single press of save would take your changes, inject it into your current running application, keep you in the exact same place, depending on the type of change it could re-layout your views, and so you can stay in your editor and make your changes. <em>From 25 seconds, to less than one</em>. For a lot of my work, I can put my tests, debuggers and the application on another screen, and just move my head to watch changes propagate on pressing save.</p>

<p>So, you’re thinking <em>“Yeah, but JavaScript…“</em> - well, we use <a href="http://typescriptlang.org">TypeScript</a> and it fixes pretty much every issue with JavaScript. It’s also no problem for us to write native code when we need to, we are still adding to an existing native codebase. The last project I did on our React Native codebase required bi-directional JS &lt;-&gt; Swift communication.</p>

<p>React Native feels like the best of both worlds: Elegant, fast to work with application code, which the whole dev team understands. Falling back to native tooling when we think it will be best for the project.</p>

<blockquote>
  <p>Reference from JS 2017: <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/#TypeScript">TypeScript</a></p>
</blockquote>

<p>There’s one more thing that I want to really stress around developer experience, it’s really easy to write tests for our React components. Testing in JavaScript is night-and-day better than native testing. Because we can run our tests outside of the simulator (due to React’s virtual DOM) we run tests whenever you press save. These tests are only the ones related to the current <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/#Jest">changes in git</a>. The only thing we miss is visual snapshots <a href="https://www.objc.io/issues/15-testing/snapshot-testing/">from the simulator</a>, not having to restart a simulator to run tests makes it worth it though.</p>

<h4 id="same-tools-different-dev">Same Tools, Different Dev</h4>

<p>We wanted to stop being highly unique inside the dev team. Artsy has around 25 developers, the majority of which work with Ruby and JavaScript on a day-to-day basis. The mobile team was the single development team that didn’t make their own API changes, used different toolchains and were much slower in shipping anything.</p>

<p>This isn’t a great position to be in.</p>

<p>We wanted all developers to feel like they can contribute to any area of the company. For the past 5 years, the native mobile projects had close to zero contributions from anyone outside of the mobile team. Due to differences in tooling, and the idea that there was a cultural difference between us. Since the mobile team moved to React Native we have received features and bug fixes from the web team, and fit in better overall.</p>

<p>This expansion of a mobile team developer’s scope has made it much easier for us to reason about finding better ways to share code with the web team. At the end of 2015, the Collector Web team introduced GraphQL to Artsy. I wrote about how this affected the <a href="http://artsy.github.io/blog/2016/06/19/graphql-for-mobile/">mobile team</a>. This acts as an API layer owned by the front-end side of Artsy. Meaning that it could contain a lot of API-derived client-specific logic. Previously, this work was done by the web team, and then consumed by mobile - now both teams build their APIs and consume them.</p>

<blockquote>
  <p>Reference from JS 2017: <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/#GraphQL">GraphQL</a></p>
</blockquote>

<p>This is not something we have explored too deeply, however we expect to be able to port a lot of our React Native to Android. I got a rough prototype ported in 2 days work. By working at React-level, and allowing the React Native bindings to handle the interactions with the host OS, we’ve been writing cross-platform code.</p>

<p>We consider ourselves blocked on Android support, specifically by not having an engineer in our team with <em>deep</em> experience in Android. Moving to React Native does not obviate our native skills, you’re going to be significantly better in that environment with those skills than without. As we mentioned in our <a href="/blog/2016/08/15/React-Native-at-Artsy/">announcement</a>:</p>

<blockquote>
  <p>If you’re not already knowledgeable about iOS development, are not motivated to put in the time to learn about the
  platform specific details, and think making rich iOS applications with React Native will be a breeze, you’ll
  <a href="http://www.dwotd.nl/2008/06/443-van-een-kouwe-kermis-thuiskomen.html">come home from a very cold fair</a> indeed.</p>
</blockquote>

<p>We need someone with a similar depth of knowledge in the Android ecosystem as our iOS, but we may need one or two for the entire team. The rest can continue to be a mix of Web and iOS engineers. You gain a subset of cross-platform skills using React Native. Had we continued down the path of using Swift, our skills would continue to be siloed.</p>

<p>There is an argument that Swift will be running servers soon, and so you can re-use Swift code across platforms. I could see myself writing server-side back-end code in Swift (you’re writing systems, not apps) but it has a <a href="https://ashfurrow.com/blog/swift-on-linux/">long way to go</a>. It also isn’t an argument towards using it in our native apps, we’d have to re-write servers and implement our own GraphQL and Relay stack. This also would not impact the front-end code for the web - they would still be using JavaScript.</p>

<p>With respect to Swift on Android, potentially, logic code could be shared between platforms but realistically for our setup that’s just not worth it. We’re moving that kind of logic into the GraphQL instance and sharing across <em>all</em> clients, not only native platforms. If you’re sharing model code, you could generate that per-project instead from the server. Since GraphQL is strongly-typed, we’re doing this for both <a href="https://github.com/alloy/relational-theory/pull/18">TypeScript + GraphQL</a> and <a href="https://github.com/alloy/vscode-relay">TypeScript + Relay</a>.</p>

<p>We don’t know where this will end, but we’ve prototyped porting one of our view controllers from React Native <a href="https://github.com/alloy/relational-theory/pull/16">to a website</a>. It’s almost source-compatible. This such a completely different mindset from where we were a year ago.</p>

<h4 id="owning-the-stack">Owning the stack</h4>

<p>Pick an abstraction level of our application above UIKit and we can fork it. All our tools can be also be forked. We can fix our own issues.</p>

<p>In native, there are no concepts like, <em>“We’ll use Steipete’s fork of UIKit for UIPopover rotation fixes”</em> or <em>“My version of Xcode will run tests when you press save.”</em>. Well, hopefully the latter <a href="https://twitter.com/orta/status/790589579552296966">may be fixed</a> in time, but the “you have no choice but to wait, and maybe it won’t happen” aspect is part of the problem.</p>

<p>You have your tools given to you, in a year you get some new ones and lose some old ones. In contrast, we’ve built <a href="https://github.com/orta/vscode-jest#vscode-jest-">many</a> <a href="https://github.com/orta/vscode-react-native-storybooks">extensions</a> <a href="https://github.com/alloy/vscode-relay">for</a> <a href="https://github.com/orta/vscode-ios-common-files">VS</a> <a href="https://github.com/orta/vscode-danger">Code</a> for our own use, and helped out on <a href="https://github.com/flowtype/flow-for-vscode/blob/master/CHANGELOG.md">major ones</a>. When VS Code didn’t do what I wanted, I started using <a href="https://github.com/orta/Essence">use my own fork</a>.</p>

<blockquote>
  <p>Reference from JS 2017: <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/#Visual.Studio.Code">VS Code</a></p>
</blockquote>

<p>In the last year, we have submitted code to major JavaScript dependencies of ours: React Native, Relay, VS Code, Jest and a few libraries in-between - fixing problems where we see them, offering features if we need them. Some of these changes are <a href="https://github.com/Microsoft/vscode/pull/12628">small</a>, but some <a href="https://github.com/facebook/relay/issues/1061">are</a> <a href="https://github.com/facebook/jest/pull/2192">big</a> <a href="https://github.com/facebook/react-native/pull/6114">moves</a>. Being able to help out on any problem makes it much easier to live with the <a href="/blog/2016/08/15/React-Native-at-Artsy/">593 dependencies</a> that using React Native brings.</p>

<p>It’s worth highlighting that all of this is done on GitHub, in the open. We can write issues, get responses, and have direct line to the people who are working on something we depend on. This is a stark contrast to the Radar system used internally at Apple, and which external developers have write-only access to. For external contributors radar is opaque, and <a href="https://thenextweb.com/apple/2012/04/13/app-developers-frustrated-with-bug-reporting-tools-call-on-apple-to-fix-radar-or-gtfo/">often feels like a waste of time</a>. On the other hand, a GitHub issue doesn’t have to wait for the repo maintainers, others can get value from it and it’s publicly indexed. If we had put all our effort into Radars instead of <a href="https://github.com/artsy/eigen/issues/586">issues like</a> this, the whole community would be worse off.</p>

<p>This isn’t all doom and gloom. With Swift the language, and SwiftPM the package manager, Apple are more open with the feedback cycle using tools like <a href="https://lists.swift.org/pipermail/swift-build-dev/Week-of-Mon-20160530/000497.html">Slack</a>, Mailing Lists, JIRA and Twitter.</p>

<p>One aspect of working with JavaScript that has been particularly pleasant is the idea that your language is effectively a buffet. If you want to use the latest features of the language you can opt-in to it. We’ve slowly added language features, while retaining backwards compatibility. First using <a href="https://babeljs.io">Babel</a>, then <a href="https://flowtype.org">Flow</a> and finally with <a href="http://www.typescriptlang.org">TypeScript</a>.</p>

<p>In contrast, and this may be the last major time it happens, but people refer to the time it took to migrate <a href="https://engblog.nextdoor.com/migrating-to-swift-3-7add0ce0655#.rvyrohyhq">in</a> <a href="https://tech.zalando.com/blog/app-migration-to-swift-3/">the</a> <a href="https://github.com/kickstarter/ios-oss/pull/26">scale</a> <a href="https://twitter.com/guidomb/status/817363981216129025">of</a> <em>weeks</em> during the Swift 2 -&gt; 3 migration. Having the language evolve is great, sometimes in ways that you <a href="https://swift.org/documentation/api-design-guidelines/">agree with</a> and sometimes in ways <a href="http://mjtsai.com/blog/2016/07/17/swift-classes-to-be-non-publicly-subclassable-by-default/">you don’t</a>. Being able to use your own version of your tools frees you to make it work for you and your business. We have been talking about <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/#TypeScript-Extension">extending TypeScript</a> specifically for our applications.</p>

<h1 id="react-native-one-year-later">React Native, one year later</h1>

<p>In our announcement we talked about the lack of nuanced post-mortems on React Native. We’re now a year in, we can at least try to help out in that space. We’re sticking with React Native for the foreseeable future. It would take some <em>drastic</em> changes in the Apple ecosystem for us to re-consider this decision. So here’s the summary after 1 year.</p>

<ul>
  <li>We can share concepts with web</li>
  <li>Tools are built for apps like ours</li>
  <li>To do it right requires engineers willing to dive deep in JS</li>
  <li>You need native experience to have a polished app</li>
  <li>Dependency stack is still obscenely big</li>
  <li>Opens native engineers to more projects, makes yours more welcoming to others</li>
  <li>Problems do, and will occur, but everything is fixable by forking</li>
  <li>Extensive communication with native code gets tricky to test and maintain</li>
  <li>We ended up re-using quite a lot of existing native code</li>
  <li>It makes working in native code feel more like a chore, as you lose the JS developer experience</li>
  <li>Spending so much time in another environment will erode native knowledge</li>
  <li>Makes a lot of sense in an <a href="/blog/2016/08/24/On-Emission/">additive approach</a> to existing apps</li>
  <li>We’re not making plans to re-write other Apps into React Native, they are fine as-is</li>
  <li>New apps going forward we will default to React Native apps, unless there is a good reason to not</li>
</ul>

<p>So, should you use React Native? Maybe. If you have an API driven app, <em>probably.</em></p>

<p>It’s definitely worth a week of prototyping for any engineering team, then if that goes well you should look into GraphQL and Relay. They really make React Native shine.</p>

<h1 id="want-to-get-started">Want to get started?</h1>

<ul>
  <li>Here’s the <a href="https://facebook.github.io/react-native/">official site</a>.</li>
  <li>These <a href="https://egghead.io/courses/react-native-fundamentals">two</a> <a href="https://egghead.io/courses/build-a-react-native-todo-application">series</a> are high-quality. I studied JavaScript by watching hours of egghead videos.</li>
  <li>Run through the <a href="https://github.com/fbsamples/f8app/">f8 app</a> series on  <a href="http://makeitopen.com/">makeitopen.com</a>.</li>
  <li>Clone our React Native app, <a href="https://github.com/artsy/emission/">Emission</a>.</li>
  <li>Read the rest of our <a href="/series/react-native-at-artsy/">series on React Native</a>.</li>
  <li>Read our summary on <a href="/blog/2017/02/05/Front-end-JavaScript-at-Artsy-2017/">our JavaScript stack choices</a>.</li>
</ul>

<p>If you’d like to look into GraphQL + Relay, but don’t want to start building a server yourself, consider these GraphQL as a Services:</p>

<ul>
  <li><a href="https://scaphold.io">scraphold</a>.</li>
  <li><a href="https://www.graph.cool/">graphcool</a>.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Accessing the app's Source Code from your Simulator]]></title>
    <link href="https://artsy.github.io/blog/2016/10/14/Accessing-the-Source-Code-from-your-Simulator/"/>
    <updated>2016-10-14T12:17:00+00:00</updated>
    <id>https://artsy.github.io/blog/2016/10/14/Accessing-the-Source-Code-from-your-Simulator</id>
    <content type="html"><![CDATA[<p>In the last few months twice I’ve wanted to access the source code of our application. The first time I did it I came up with a pretty neat hack, but it wouldn’t really work in many places. The second time however, I <a href="https://twitter.com/orta/status/786470282093625344">asked the internet</a>, and the <a href="https://twitter.com/saniul/status/786470857635827712">internet</a> <a href="https://twitter.com/0xced/status/786619335116750848">replied</a>.</p>

<p>TLDR: You can use your <a href="https://github.com/artsy/emission/pull/350/commits/2a39c743bcaaf2e3b848ad60621198f40365fdd2">project’s scheme</a> to expose derived Xcode environment variables to your source code.</p>

<p>The rest of the blog post is a little bit about <em>why</em> I wanted to do that and what I did with it.</p>

<!-- more -->

<p>Both times I’ve wanted to access the source code of our apps is because I’ve wanted to make better admin tools. It should come as no surprise to people who know me that I care about tooling, but I also care a lot about making it possible for our admins to do their own thing. As such, our <a href="https://github.com/artsy/eigen/blob/master/Artsy/View_Controllers/Admin/ARAdminSettingsViewController.m">admin settings panel</a> in Eigen is extensive.</p>

<h3 id="root-react-components">Root React Components</h3>

<p>The first time came when I started to think about what admin options I’d like to see for people using our React Native side. These are the options I came up with:</p>

<p><img src="/images/source-code-sim/react-admin-eigen.png" alt="/images/source-code-sim/react-admin-eigen.png" /></p>

<p>There are two interesting things about it:</p>

<ul>
  <li>We support running any master commit of our React Native code inside Eigen, for Admins, <a href="https://apphub.io">via AppHub</a></li>
  <li>We allow loading arbitrary React components as an admin.</li>
</ul>

<p>It’s this last bit that’s interesting, right now I’m working on a new root Gene component (read: new view controller) in Emission, our React Native implementation. As this work has not moved upstream into Eigen, I can access it through a commit on AppHub, and then open it using our custom module loader:</p>

<p><img src="/images/source-code-sim/react-module-eigen.png" alt="/images/source-code-sim/react-module-eigen.png" /></p>

<p>In order to show the available root components (Artist/Home/Gene), we use GitHub’s raw URLs to download the source code of our Open Source apps. Hah, a nice hack right? I <a href="https://github.com/artsy/eigen/blob/master/Artsy/View_Controllers/Admin/ARAdminNetworkModel.m">created</a> a <code class="language-plaintext highlighter-rouge">ARAdminNetworkModel</code> with an API like this:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">@interface</span> <span class="nc">ARAdminNetworkModel</span> <span class="p">:</span> <span class="nc">NSObject</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">getEmissionJSON</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">path</span> <span class="nf">completion</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">json</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completion</span><span class="p">;</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">getEmissionFile</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">path</span> <span class="nf">completion</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">fileContents</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completion</span><span class="p">;</span>

<span class="k">@end</span>
</code></pre></div></div>

<p>Which simply uses <code class="language-plaintext highlighter-rouge">NSURLSession</code> under the hood:</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">getEmissionData</span><span class="p">:(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">path</span> <span class="nf">completion</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">))</span><span class="nv">completion</span><span class="p">;</span>
<span class="p">{</span>
    <span class="n">NSURLSession</span> <span class="o">*</span><span class="n">session</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLSession</span> <span class="nf">sharedSession</span><span class="p">];</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">urlFormat</span> <span class="o">=</span> <span class="s">@"https://raw.githubusercontent.com/artsy/emission/master/%@"</span><span class="p">;</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithFormat</span><span class="p">:</span> <span class="n">urlFormat</span><span class="p">,</span> <span class="n">path</span><span class="p">];</span>
    <span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">request</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLRequest</span> <span class="nf">requestWithURL</span><span class="p">:[</span><span class="n">NSURL</span> <span class="nf">URLWithString</span><span class="p">:</span><span class="n">url</span><span class="p">]];</span>
    <span class="n">NSURLSessionDataTask</span> <span class="o">*</span><span class="n">task</span> <span class="o">=</span> <span class="p">[</span><span class="n">session</span> <span class="nf">dataTaskWithRequest</span><span class="p">:</span><span class="n">request</span> <span class="nf">completionHandler</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">completion</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
    <span class="p">}];</span>
    <span class="p">[</span><span class="n">task</span> <span class="nf">resume</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Nothing special, but it required a cognitive jump to get there.</p>

<h3 id="submodule-introspection">Submodule Introspection</h3>

<p>The second time I wanted this is inside <a href="https://github.com/artsy/emission/tree/master/Example">the example app</a> for Emission. This is a typical example application for a library made by <code class="language-plaintext highlighter-rouge">pod lib create</code>. This example app is basically just the admin settings panel from Eigen, shown above.</p>

<p>When I <a href="https://github.com/artsy/emission/pull/347">switched the</a> example app to use a similar theme and menu DSL as Eigen, I also took the chance to expand on the buttons we had available. Previously there was the ability to load the view controller for one specific artist, but I knew we had a <a href="https://github.com/artsy/metaphysics/blob/master/schema/artist/maps/artist_title_slugs.js">giant list of artist slugs</a> inside one of our optional sub-modules. What I wanted to do, was offer a random Artist from that if the submodule was <code class="language-plaintext highlighter-rouge">init</code>‘d.</p>

<p>This required introspecting the source, which I could have also done via the GitHub API, but it was also feasible to do by accessing the filesystem outside of the simulator. This is totally possible ( and is <a href="https://www.objc.io/issues/15-testing/snapshot-testing/">how FBSnapshots works</a> ) but I needed to access the project root, then I could build relative links. Thus, <a href="https://twitter.com/orta/status/786470282093625344">I asked the internet</a>. I knew these variables existed, but that they were a part of the build process - and not exposed to the app runtime.</p>

<p>There are two ways to do it, both make sense for different contexts:</p>

<ul>
  <li><a href="https://github.com/artsy/emission/blob/74d0bc6cc45da906436f8bbc33710ea030657ee8/Example/Emission/Info.plist#L5-L6">Baking the value into your Info.plist</a> - which makes it available for all consumers at runtime, e.g. you could deploy this value, but it’s not too useful for my problem.</li>
  <li><a href="https://github.com/artsy/emission/pull/350/commits/2a39c743bcaaf2e3b848ad60621198f40365fdd2">Exposing it as an environment variable via your scheme</a> - perfect for this case, the variable won’t be exported when you deploy.</li>
</ul>

<p>Now our scheme looks like this:</p>

<p>&lt;/div&gt;&lt;/div&gt;<a href="/images/source-code-sim/scheme-settings-emission.png"><img src="/images/source-code-sim/scheme-settings-emission.png" /></a>&lt;div class='meta-container'&gt;&lt;header&gt; &lt;/header&gt;&lt;/div&gt;&lt;div class='date-container'&gt; &lt;/div&gt;&lt;div class='content-container'&gt;&lt;div class='entry-content'&gt;</p>

<p>I can then use the value of <code class="language-plaintext highlighter-rouge">SRCROOT</code> as the start of an absolute path to get to any of the source code in our project. Making the <a href="https://github.com/artsy/emission/blob/dda57636e424ab7d4517de57f3e8bd917fcb3c6f/Example/Emission/ARRootViewController.m#L85-L108">final code</a>:</p>

<div class="language-obj-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">-</span> <span class="p">(</span><span class="n">ARCellData</span> <span class="o">*</span><span class="p">)</span><span class="n">jumpToRandomArtist</span>
<span class="p">{</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">sourceRoot</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSProcessInfo</span> <span class="nf">processInfo</span><span class="p">].</span><span class="n">environment</span><span class="p">[</span><span class="s">@"SRCROOT"</span><span class="p">];</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">artistListFromExample</span> <span class="o">=</span> <span class="s">@"../externals/metaphysics/schema/artist/maps/artist_title_slugs.js"</span><span class="p">;</span>
  <span class="n">NSString</span> <span class="o">*</span><span class="n">slugsPath</span> <span class="o">=</span> <span class="p">[</span><span class="n">sourceRoot</span> <span class="nf">stringByAppendingPathComponent</span><span class="p">:</span><span class="n">artistListFromExample</span><span class="p">];</span>

  <span class="n">NSFileManager</span> <span class="o">*</span><span class="n">manager</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSFileManager</span> <span class="nf">defaultManager</span><span class="p">];</span>

  <span class="c1">// Don't have the submodule? bail, it's no biggie</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="n">manager</span> <span class="nf">fileExistsAtPath</span><span class="p">:</span><span class="n">slugsPath</span><span class="p">])</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// Otherwise lets support jumping to a random Artist</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nf">tappableCellDataWithTitle</span><span class="p">:</span><span class="s">@"Artist (random from metaphysics)"</span> <span class="nf">selection</span><span class="p">:</span> <span class="o">^</span><span class="p">{</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSString</span> <span class="nf">stringWithContentsOfFile</span><span class="p">:</span><span class="n">slugsPath</span> <span class="nf">encoding</span><span class="p">:</span><span class="n">NSUTF8StringEncoding</span> <span class="n">error</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>

    <span class="p">...</span> <span class="n">and</span> <span class="n">so</span> <span class="n">on</span>
</code></pre></div></div>

<h3 id="tooling">Tooling</h3>

<p>Paying attention to your admin tools, and improving your development experience for the whole team is a great way to win friends and influence people. Introspecting your source code may help that.</p>
]]></content>
  </entry>
  
</feed>
